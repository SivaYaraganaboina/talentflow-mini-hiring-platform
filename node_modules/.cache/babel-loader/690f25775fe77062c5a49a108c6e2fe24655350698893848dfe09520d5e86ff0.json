{"ast":null,"code":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n    exports: {}\n  }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\n\n// node_modules/cookie/index.js\nvar require_cookie = __commonJS({\n  \"node_modules/cookie/index.js\"(exports) {\n    \"use strict\";\n\n    exports.parse = parse;\n    exports.serialize = serialize;\n    var __toString = Object.prototype.toString;\n    var __hasOwnProperty = Object.prototype.hasOwnProperty;\n    var cookieNameRegExp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\n    var cookieValueRegExp = /^(\"?)[\\u0021\\u0023-\\u002B\\u002D-\\u003A\\u003C-\\u005B\\u005D-\\u007E]*\\1$/;\n    var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;\n    var pathValueRegExp = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/;\n    function parse(str, opt) {\n      if (typeof str !== \"string\") {\n        throw new TypeError(\"argument str must be a string\");\n      }\n      var obj = {};\n      var len = str.length;\n      if (len < 2) return obj;\n      var dec = opt && opt.decode || decode;\n      var index = 0;\n      var eqIdx = 0;\n      var endIdx = 0;\n      do {\n        eqIdx = str.indexOf(\"=\", index);\n        if (eqIdx === -1) break;\n        endIdx = str.indexOf(\";\", index);\n        if (endIdx === -1) {\n          endIdx = len;\n        } else if (eqIdx > endIdx) {\n          index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n          continue;\n        }\n        var keyStartIdx = startIndex(str, index, eqIdx);\n        var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);\n        var key = str.slice(keyStartIdx, keyEndIdx);\n        if (!__hasOwnProperty.call(obj, key)) {\n          var valStartIdx = startIndex(str, eqIdx + 1, endIdx);\n          var valEndIdx = endIndex(str, endIdx, valStartIdx);\n          if (str.charCodeAt(valStartIdx) === 34 && str.charCodeAt(valEndIdx - 1) === 34) {\n            valStartIdx++;\n            valEndIdx--;\n          }\n          var val = str.slice(valStartIdx, valEndIdx);\n          obj[key] = tryDecode(val, dec);\n        }\n        index = endIdx + 1;\n      } while (index < len);\n      return obj;\n    }\n    function startIndex(str, index, max) {\n      do {\n        var code = str.charCodeAt(index);\n        if (code !== 32 && code !== 9) return index;\n      } while (++index < max);\n      return max;\n    }\n    function endIndex(str, index, min) {\n      while (index > min) {\n        var code = str.charCodeAt(--index);\n        if (code !== 32 && code !== 9) return index + 1;\n      }\n      return min;\n    }\n    function serialize(name, val, opt) {\n      var enc = opt && opt.encode || encodeURIComponent;\n      if (typeof enc !== \"function\") {\n        throw new TypeError(\"option encode is invalid\");\n      }\n      if (!cookieNameRegExp.test(name)) {\n        throw new TypeError(\"argument name is invalid\");\n      }\n      var value = enc(val);\n      if (!cookieValueRegExp.test(value)) {\n        throw new TypeError(\"argument val is invalid\");\n      }\n      var str = name + \"=\" + value;\n      if (!opt) return str;\n      if (null != opt.maxAge) {\n        var maxAge = Math.floor(opt.maxAge);\n        if (!isFinite(maxAge)) {\n          throw new TypeError(\"option maxAge is invalid\");\n        }\n        str += \"; Max-Age=\" + maxAge;\n      }\n      if (opt.domain) {\n        if (!domainValueRegExp.test(opt.domain)) {\n          throw new TypeError(\"option domain is invalid\");\n        }\n        str += \"; Domain=\" + opt.domain;\n      }\n      if (opt.path) {\n        if (!pathValueRegExp.test(opt.path)) {\n          throw new TypeError(\"option path is invalid\");\n        }\n        str += \"; Path=\" + opt.path;\n      }\n      if (opt.expires) {\n        var expires = opt.expires;\n        if (!isDate(expires) || isNaN(expires.valueOf())) {\n          throw new TypeError(\"option expires is invalid\");\n        }\n        str += \"; Expires=\" + expires.toUTCString();\n      }\n      if (opt.httpOnly) {\n        str += \"; HttpOnly\";\n      }\n      if (opt.secure) {\n        str += \"; Secure\";\n      }\n      if (opt.partitioned) {\n        str += \"; Partitioned\";\n      }\n      if (opt.priority) {\n        var priority = typeof opt.priority === \"string\" ? opt.priority.toLowerCase() : opt.priority;\n        switch (priority) {\n          case \"low\":\n            str += \"; Priority=Low\";\n            break;\n          case \"medium\":\n            str += \"; Priority=Medium\";\n            break;\n          case \"high\":\n            str += \"; Priority=High\";\n            break;\n          default:\n            throw new TypeError(\"option priority is invalid\");\n        }\n      }\n      if (opt.sameSite) {\n        var sameSite = typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n        switch (sameSite) {\n          case true:\n            str += \"; SameSite=Strict\";\n            break;\n          case \"lax\":\n            str += \"; SameSite=Lax\";\n            break;\n          case \"strict\":\n            str += \"; SameSite=Strict\";\n            break;\n          case \"none\":\n            str += \"; SameSite=None\";\n            break;\n          default:\n            throw new TypeError(\"option sameSite is invalid\");\n        }\n      }\n      return str;\n    }\n    function decode(str) {\n      return str.indexOf(\"%\") !== -1 ? decodeURIComponent(str) : str;\n    }\n    function isDate(val) {\n      return __toString.call(val) === \"[object Date]\";\n    }\n    function tryDecode(str, decode2) {\n      try {\n        return decode2(str);\n      } catch (e) {\n        return str;\n      }\n    }\n  }\n});\n\n// source.js\nvar import_cookie = __toESM(require_cookie(), 1);\nvar source_default = import_cookie.default;\nexport { source_default as default };\n/*! Bundled license information:\n\ncookie/index.js:\n  (*!\n   * cookie\n   * Copyright(c) 2012-2014 Roman Shtylman\n   * Copyright(c) 2015 Douglas Christopher Wilson\n   * MIT Licensed\n   *)\n*/","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}