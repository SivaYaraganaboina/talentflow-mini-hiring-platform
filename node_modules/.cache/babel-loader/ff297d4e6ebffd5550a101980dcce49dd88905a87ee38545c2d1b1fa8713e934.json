{"ast":null,"code":"/**\n * Implement a factory allowing to plug different implementations of suffix\n * lookup (e.g.: using a trie or the packed hashes datastructures). This is used\n * and exposed in `tldts.ts` and `tldts-experimental.ts` bundle entrypoints.\n */\nimport getDomain from './domain';\nimport getDomainWithoutSuffix from './domain-without-suffix';\nimport extractHostname from './extract-hostname';\nimport isIp from './is-ip';\nimport isValidHostname from './is-valid';\nimport { setDefaults } from './options';\nimport getSubdomain from './subdomain';\nexport function getEmptyResult() {\n  return {\n    domain: null,\n    domainWithoutSuffix: null,\n    hostname: null,\n    isIcann: null,\n    isIp: null,\n    isPrivate: null,\n    publicSuffix: null,\n    subdomain: null\n  };\n}\nexport function resetResult(result) {\n  result.domain = null;\n  result.domainWithoutSuffix = null;\n  result.hostname = null;\n  result.isIcann = null;\n  result.isIp = null;\n  result.isPrivate = null;\n  result.publicSuffix = null;\n  result.subdomain = null;\n}\nexport function parseImpl(url, step, suffixLookup, partialOptions, result) {\n  const options = /*@__INLINE__*/setDefaults(partialOptions);\n  // Very fast approximate check to make sure `url` is a string. This is needed\n  // because the library will not necessarily be used in a typed setup and\n  // values of arbitrary types might be given as argument.\n  if (typeof url !== 'string') {\n    return result;\n  }\n  // Extract hostname from `url` only if needed. This can be made optional\n  // using `options.extractHostname`. This option will typically be used\n  // whenever we are sure the inputs to `parse` are already hostnames and not\n  // arbitrary URLs.\n  //\n  // `mixedInput` allows to specify if we expect a mix of URLs and hostnames\n  // as input. If only hostnames are expected then `extractHostname` can be\n  // set to `false` to speed-up parsing. If only URLs are expected then\n  // `mixedInputs` can be set to `false`. The `mixedInputs` is only a hint\n  // and will not change the behavior of the library.\n  if (!options.extractHostname) {\n    result.hostname = url;\n  } else if (options.mixedInputs) {\n    result.hostname = extractHostname(url, isValidHostname(url));\n  } else {\n    result.hostname = extractHostname(url, false);\n  }\n  // Check if `hostname` is a valid ip address\n  if (options.detectIp && result.hostname !== null) {\n    result.isIp = isIp(result.hostname);\n    if (result.isIp) {\n      return result;\n    }\n  }\n  // Perform hostname validation if enabled. If hostname is not valid, no need to\n  // go further as there will be no valid domain or sub-domain. This validation\n  // is applied before any early returns to ensure consistent behavior across\n  // all API methods including getHostname().\n  if (options.validateHostname && options.extractHostname && result.hostname !== null && !isValidHostname(result.hostname)) {\n    result.hostname = null;\n    return result;\n  }\n  if (step === 0 /* FLAG.HOSTNAME */ || result.hostname === null) {\n    return result;\n  }\n  // Extract public suffix\n  suffixLookup(result.hostname, options, result);\n  if (step === 2 /* FLAG.PUBLIC_SUFFIX */ || result.publicSuffix === null) {\n    return result;\n  }\n  // Extract domain\n  result.domain = getDomain(result.publicSuffix, result.hostname, options);\n  if (step === 3 /* FLAG.DOMAIN */ || result.domain === null) {\n    return result;\n  }\n  // Extract subdomain\n  result.subdomain = getSubdomain(result.hostname, result.domain);\n  if (step === 4 /* FLAG.SUB_DOMAIN */) {\n    return result;\n  }\n  // Extract domain without suffix\n  result.domainWithoutSuffix = getDomainWithoutSuffix(result.domain, result.publicSuffix);\n  return result;\n}","map":{"version":3,"names":["getDomain","getDomainWithoutSuffix","extractHostname","isIp","isValidHostname","setDefaults","getSubdomain","getEmptyResult","domain","domainWithoutSuffix","hostname","isIcann","isPrivate","publicSuffix","subdomain","resetResult","result","parseImpl","url","step","suffixLookup","partialOptions","options","mixedInputs","detectIp","validateHostname"],"sources":["C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\tldts-core\\src\\factory.ts"],"sourcesContent":["/**\n * Implement a factory allowing to plug different implementations of suffix\n * lookup (e.g.: using a trie or the packed hashes datastructures). This is used\n * and exposed in `tldts.ts` and `tldts-experimental.ts` bundle entrypoints.\n */\n\nimport getDomain from './domain';\nimport getDomainWithoutSuffix from './domain-without-suffix';\nimport extractHostname from './extract-hostname';\nimport isIp from './is-ip';\nimport isValidHostname from './is-valid';\nimport { IPublicSuffix, ISuffixLookupOptions } from './lookup/interface';\nimport { IOptions, setDefaults } from './options';\nimport getSubdomain from './subdomain';\n\nexport interface IResult {\n  // `hostname` is either a registered name (including but not limited to a\n  // hostname), or an IP address. IPv4 addresses must be in dot-decimal\n  // notation, and IPv6 addresses must be enclosed in brackets ([]). This is\n  // directly extracted from the input URL.\n  hostname: string | null;\n\n  // Is `hostname` an IP? (IPv4 or IPv6)\n  isIp: boolean | null;\n\n  // `hostname` split between subdomain, domain and its public suffix (if any)\n  subdomain: string | null;\n  domain: string | null;\n  publicSuffix: string | null;\n  domainWithoutSuffix: string | null;\n\n  // Specifies if `publicSuffix` comes from the ICANN or PRIVATE section of the list\n  isIcann: boolean | null;\n  isPrivate: boolean | null;\n}\n\nexport function getEmptyResult(): IResult {\n  return {\n    domain: null,\n    domainWithoutSuffix: null,\n    hostname: null,\n    isIcann: null,\n    isIp: null,\n    isPrivate: null,\n    publicSuffix: null,\n    subdomain: null,\n  };\n}\n\nexport function resetResult(result: IResult): void {\n  result.domain = null;\n  result.domainWithoutSuffix = null;\n  result.hostname = null;\n  result.isIcann = null;\n  result.isIp = null;\n  result.isPrivate = null;\n  result.publicSuffix = null;\n  result.subdomain = null;\n}\n\n// Flags representing steps in the `parse` function. They are used to implement\n// an early stop mechanism (simulating some form of laziness) to avoid doing\n// more work than necessary to perform a given action (e.g.: we don't need to\n// extract the domain and subdomain if we are only interested in public suffix).\nexport const enum FLAG {\n  HOSTNAME,\n  IS_VALID,\n  PUBLIC_SUFFIX,\n  DOMAIN,\n  SUB_DOMAIN,\n  ALL,\n}\n\nexport function parseImpl(\n  url: string,\n  step: FLAG,\n  suffixLookup: (\n    _1: string,\n    _2: ISuffixLookupOptions,\n    _3: IPublicSuffix,\n  ) => void,\n  partialOptions: Partial<IOptions>,\n  result: IResult,\n): IResult {\n  const options: IOptions = /*@__INLINE__*/ setDefaults(partialOptions);\n\n  // Very fast approximate check to make sure `url` is a string. This is needed\n  // because the library will not necessarily be used in a typed setup and\n  // values of arbitrary types might be given as argument.\n  if (typeof url !== 'string') {\n    return result;\n  }\n\n  // Extract hostname from `url` only if needed. This can be made optional\n  // using `options.extractHostname`. This option will typically be used\n  // whenever we are sure the inputs to `parse` are already hostnames and not\n  // arbitrary URLs.\n  //\n  // `mixedInput` allows to specify if we expect a mix of URLs and hostnames\n  // as input. If only hostnames are expected then `extractHostname` can be\n  // set to `false` to speed-up parsing. If only URLs are expected then\n  // `mixedInputs` can be set to `false`. The `mixedInputs` is only a hint\n  // and will not change the behavior of the library.\n  if (!options.extractHostname) {\n    result.hostname = url;\n  } else if (options.mixedInputs) {\n    result.hostname = extractHostname(url, isValidHostname(url));\n  } else {\n    result.hostname = extractHostname(url, false);\n  }\n\n  // Check if `hostname` is a valid ip address\n  if (options.detectIp && result.hostname !== null) {\n    result.isIp = isIp(result.hostname);\n    if (result.isIp) {\n      return result;\n    }\n  }\n\n  // Perform hostname validation if enabled. If hostname is not valid, no need to\n  // go further as there will be no valid domain or sub-domain. This validation\n  // is applied before any early returns to ensure consistent behavior across\n  // all API methods including getHostname().\n  if (\n    options.validateHostname &&\n    options.extractHostname &&\n    result.hostname !== null &&\n    !isValidHostname(result.hostname)\n  ) {\n    result.hostname = null;\n    return result;\n  }\n\n  if (step === FLAG.HOSTNAME || result.hostname === null) {\n    return result;\n  }\n\n  // Extract public suffix\n  suffixLookup(result.hostname, options, result);\n  if (step === FLAG.PUBLIC_SUFFIX || result.publicSuffix === null) {\n    return result;\n  }\n\n  // Extract domain\n  result.domain = getDomain(result.publicSuffix, result.hostname, options);\n  if (step === FLAG.DOMAIN || result.domain === null) {\n    return result;\n  }\n\n  // Extract subdomain\n  result.subdomain = getSubdomain(result.hostname, result.domain);\n  if (step === FLAG.SUB_DOMAIN) {\n    return result;\n  }\n\n  // Extract domain without suffix\n  result.domainWithoutSuffix = getDomainWithoutSuffix(\n    result.domain,\n    result.publicSuffix,\n  );\n\n  return result;\n}\n"],"mappings":"AAAA;;;;;AAMA,OAAOA,SAAS,MAAM,UAAU;AAChC,OAAOC,sBAAsB,MAAM,yBAAyB;AAC5D,OAAOC,eAAe,MAAM,oBAAoB;AAChD,OAAOC,IAAI,MAAM,SAAS;AAC1B,OAAOC,eAAe,MAAM,YAAY;AAExC,SAAmBC,WAAW,QAAQ,WAAW;AACjD,OAAOC,YAAY,MAAM,aAAa;AAuBtC,OAAM,SAAUC,cAAcA,CAAA;EAC5B,OAAO;IACLC,MAAM,EAAE,IAAI;IACZC,mBAAmB,EAAE,IAAI;IACzBC,QAAQ,EAAE,IAAI;IACdC,OAAO,EAAE,IAAI;IACbR,IAAI,EAAE,IAAI;IACVS,SAAS,EAAE,IAAI;IACfC,YAAY,EAAE,IAAI;IAClBC,SAAS,EAAE;GACZ;AACH;AAEA,OAAM,SAAUC,WAAWA,CAACC,MAAe;EACzCA,MAAM,CAACR,MAAM,GAAG,IAAI;EACpBQ,MAAM,CAACP,mBAAmB,GAAG,IAAI;EACjCO,MAAM,CAACN,QAAQ,GAAG,IAAI;EACtBM,MAAM,CAACL,OAAO,GAAG,IAAI;EACrBK,MAAM,CAACb,IAAI,GAAG,IAAI;EAClBa,MAAM,CAACJ,SAAS,GAAG,IAAI;EACvBI,MAAM,CAACH,YAAY,GAAG,IAAI;EAC1BG,MAAM,CAACF,SAAS,GAAG,IAAI;AACzB;AAeA,OAAM,SAAUG,SAASA,CACvBC,GAAW,EACXC,IAAU,EACVC,YAIS,EACTC,cAAiC,EACjCL,MAAe;EAEf,MAAMM,OAAO,GAAa,eAAgBjB,WAAW,CAACgB,cAAc,CAAC;EAErE;EACA;EACA;EACA,IAAI,OAAOH,GAAG,KAAK,QAAQ,EAAE;IAC3B,OAAOF,MAAM;EACf;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAI,CAACM,OAAO,CAACpB,eAAe,EAAE;IAC5Bc,MAAM,CAACN,QAAQ,GAAGQ,GAAG;EACvB,CAAC,MAAM,IAAII,OAAO,CAACC,WAAW,EAAE;IAC9BP,MAAM,CAACN,QAAQ,GAAGR,eAAe,CAACgB,GAAG,EAAEd,eAAe,CAACc,GAAG,CAAC,CAAC;EAC9D,CAAC,MAAM;IACLF,MAAM,CAACN,QAAQ,GAAGR,eAAe,CAACgB,GAAG,EAAE,KAAK,CAAC;EAC/C;EAEA;EACA,IAAII,OAAO,CAACE,QAAQ,IAAIR,MAAM,CAACN,QAAQ,KAAK,IAAI,EAAE;IAChDM,MAAM,CAACb,IAAI,GAAGA,IAAI,CAACa,MAAM,CAACN,QAAQ,CAAC;IACnC,IAAIM,MAAM,CAACb,IAAI,EAAE;MACf,OAAOa,MAAM;IACf;EACF;EAEA;EACA;EACA;EACA;EACA,IACEM,OAAO,CAACG,gBAAgB,IACxBH,OAAO,CAACpB,eAAe,IACvBc,MAAM,CAACN,QAAQ,KAAK,IAAI,IACxB,CAACN,eAAe,CAACY,MAAM,CAACN,QAAQ,CAAC,EACjC;IACAM,MAAM,CAACN,QAAQ,GAAG,IAAI;IACtB,OAAOM,MAAM;EACf;EAEA,IAAIG,IAAI,8BAAsBH,MAAM,CAACN,QAAQ,KAAK,IAAI,EAAE;IACtD,OAAOM,MAAM;EACf;EAEA;EACAI,YAAY,CAACJ,MAAM,CAACN,QAAQ,EAAEY,OAAO,EAAEN,MAAM,CAAC;EAC9C,IAAIG,IAAI,mCAA2BH,MAAM,CAACH,YAAY,KAAK,IAAI,EAAE;IAC/D,OAAOG,MAAM;EACf;EAEA;EACAA,MAAM,CAACR,MAAM,GAAGR,SAAS,CAACgB,MAAM,CAACH,YAAY,EAAEG,MAAM,CAACN,QAAQ,EAAEY,OAAO,CAAC;EACxE,IAAIH,IAAI,4BAAoBH,MAAM,CAACR,MAAM,KAAK,IAAI,EAAE;IAClD,OAAOQ,MAAM;EACf;EAEA;EACAA,MAAM,CAACF,SAAS,GAAGR,YAAY,CAACU,MAAM,CAACN,QAAQ,EAAEM,MAAM,CAACR,MAAM,CAAC;EAC/D,IAAIW,IAAI,8BAAsB;IAC5B,OAAOH,MAAM;EACf;EAEA;EACAA,MAAM,CAACP,mBAAmB,GAAGR,sBAAsB,CACjDe,MAAM,CAACR,MAAM,EACbQ,MAAM,CAACH,YAAY,CACpB;EAED,OAAOG,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}