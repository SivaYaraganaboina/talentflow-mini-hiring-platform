{"ast":null,"code":"import { fastPathLookup } from 'tldts-core';\nimport { exceptions, rules } from './data/trie';\n/**\n * Lookup parts of domain in Trie\n */\nfunction lookupInTrie(parts, trie, index, allowedMask) {\n  let result = null;\n  let node = trie;\n  while (node !== undefined) {\n    // We have a match!\n    if ((node[0] & allowedMask) !== 0) {\n      result = {\n        index: index + 1,\n        isIcann: node[0] === 1 /* RULE_TYPE.ICANN */,\n        isPrivate: node[0] === 2 /* RULE_TYPE.PRIVATE */\n      };\n    }\n    // No more `parts` to look for\n    if (index === -1) {\n      break;\n    }\n    const succ = node[1];\n    node = Object.prototype.hasOwnProperty.call(succ, parts[index]) ? succ[parts[index]] : succ['*'];\n    index -= 1;\n  }\n  return result;\n}\n/**\n * Check if `hostname` has a valid public suffix in `trie`.\n */\nexport default function suffixLookup(hostname, options, out) {\n  var _a;\n  if (fastPathLookup(hostname, options, out)) {\n    return;\n  }\n  const hostnameParts = hostname.split('.');\n  const allowedMask = (options.allowPrivateDomains ? 2 /* RULE_TYPE.PRIVATE */ : 0) | (options.allowIcannDomains ? 1 /* RULE_TYPE.ICANN */ : 0);\n  // Look for exceptions\n  const exceptionMatch = lookupInTrie(hostnameParts, exceptions, hostnameParts.length - 1, allowedMask);\n  if (exceptionMatch !== null) {\n    out.isIcann = exceptionMatch.isIcann;\n    out.isPrivate = exceptionMatch.isPrivate;\n    out.publicSuffix = hostnameParts.slice(exceptionMatch.index + 1).join('.');\n    return;\n  }\n  // Look for a match in rules\n  const rulesMatch = lookupInTrie(hostnameParts, rules, hostnameParts.length - 1, allowedMask);\n  if (rulesMatch !== null) {\n    out.isIcann = rulesMatch.isIcann;\n    out.isPrivate = rulesMatch.isPrivate;\n    out.publicSuffix = hostnameParts.slice(rulesMatch.index).join('.');\n    return;\n  }\n  // No match found...\n  // Prevailing rule is '*' so we consider the top-level domain to be the\n  // public suffix of `hostname` (e.g.: 'example.org' => 'org').\n  out.isIcann = false;\n  out.isPrivate = false;\n  out.publicSuffix = (_a = hostnameParts[hostnameParts.length - 1]) !== null && _a !== void 0 ? _a : null;\n}","map":{"version":3,"names":["fastPathLookup","exceptions","rules","lookupInTrie","parts","trie","index","allowedMask","result","node","undefined","isIcann","isPrivate","succ","Object","prototype","hasOwnProperty","call","suffixLookup","hostname","options","out","hostnameParts","split","allowPrivateDomains","allowIcannDomains","exceptionMatch","length","publicSuffix","slice","join","rulesMatch","_a"],"sources":["C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\tldts\\src\\suffix-trie.ts"],"sourcesContent":["import {\n  fastPathLookup,\n  IPublicSuffix,\n  ISuffixLookupOptions,\n} from 'tldts-core';\nimport { exceptions, ITrie, rules } from './data/trie';\n\n// Flags used to know if a rule is ICANN or Private\nconst enum RULE_TYPE {\n  ICANN = 1,\n  PRIVATE = 2,\n}\n\ninterface IMatch {\n  index: number;\n  isIcann: boolean;\n  isPrivate: boolean;\n}\n\n/**\n * Lookup parts of domain in Trie\n */\nfunction lookupInTrie(\n  parts: string[],\n  trie: ITrie,\n  index: number,\n  allowedMask: number,\n): IMatch | null {\n  let result: IMatch | null = null;\n  let node: ITrie | undefined = trie;\n  while (node !== undefined) {\n    // We have a match!\n    if ((node[0] & allowedMask) !== 0) {\n      result = {\n        index: index + 1,\n        isIcann: node[0] === RULE_TYPE.ICANN,\n        isPrivate: node[0] === RULE_TYPE.PRIVATE,\n      };\n    }\n\n    // No more `parts` to look for\n    if (index === -1) {\n      break;\n    }\n\n    const succ: { [label: string]: ITrie } = node[1];\n    node = Object.prototype.hasOwnProperty.call(succ, parts[index]!)\n      ? succ[parts[index]!]\n      : succ['*'];\n    index -= 1;\n  }\n\n  return result;\n}\n\n/**\n * Check if `hostname` has a valid public suffix in `trie`.\n */\nexport default function suffixLookup(\n  hostname: string,\n  options: ISuffixLookupOptions,\n  out: IPublicSuffix,\n): void {\n  if (fastPathLookup(hostname, options, out)) {\n    return;\n  }\n\n  const hostnameParts = hostname.split('.');\n\n  const allowedMask =\n    (options.allowPrivateDomains ? RULE_TYPE.PRIVATE : 0) |\n    (options.allowIcannDomains ? RULE_TYPE.ICANN : 0);\n\n  // Look for exceptions\n  const exceptionMatch = lookupInTrie(\n    hostnameParts,\n    exceptions,\n    hostnameParts.length - 1,\n    allowedMask,\n  );\n\n  if (exceptionMatch !== null) {\n    out.isIcann = exceptionMatch.isIcann;\n    out.isPrivate = exceptionMatch.isPrivate;\n    out.publicSuffix = hostnameParts.slice(exceptionMatch.index + 1).join('.');\n    return;\n  }\n\n  // Look for a match in rules\n  const rulesMatch = lookupInTrie(\n    hostnameParts,\n    rules,\n    hostnameParts.length - 1,\n    allowedMask,\n  );\n\n  if (rulesMatch !== null) {\n    out.isIcann = rulesMatch.isIcann;\n    out.isPrivate = rulesMatch.isPrivate;\n    out.publicSuffix = hostnameParts.slice(rulesMatch.index).join('.');\n    return;\n  }\n\n  // No match found...\n  // Prevailing rule is '*' so we consider the top-level domain to be the\n  // public suffix of `hostname` (e.g.: 'example.org' => 'org').\n  out.isIcann = false;\n  out.isPrivate = false;\n  out.publicSuffix = hostnameParts[hostnameParts.length - 1] ?? null;\n}\n"],"mappings":"AAAA,SACEA,cAAc,QAGT,YAAY;AACnB,SAASC,UAAU,EAASC,KAAK,QAAQ,aAAa;AActD;;;AAGA,SAASC,YAAYA,CACnBC,KAAe,EACfC,IAAW,EACXC,KAAa,EACbC,WAAmB;EAEnB,IAAIC,MAAM,GAAkB,IAAI;EAChC,IAAIC,IAAI,GAAsBJ,IAAI;EAClC,OAAOI,IAAI,KAAKC,SAAS,EAAE;IACzB;IACA,IAAI,CAACD,IAAI,CAAC,CAAC,CAAC,GAAGF,WAAW,MAAM,CAAC,EAAE;MACjCC,MAAM,GAAG;QACPF,KAAK,EAAEA,KAAK,GAAG,CAAC;QAChBK,OAAO,EAAEF,IAAI,CAAC,CAAC,CAAC;QAChBG,SAAS,EAAEH,IAAI,CAAC,CAAC,CAAC;OACnB;IACH;IAEA;IACA,IAAIH,KAAK,KAAK,CAAC,CAAC,EAAE;MAChB;IACF;IAEA,MAAMO,IAAI,GAA+BJ,IAAI,CAAC,CAAC,CAAC;IAChDA,IAAI,GAAGK,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,IAAI,EAAET,KAAK,CAACE,KAAK,CAAE,CAAC,GAC5DO,IAAI,CAACT,KAAK,CAACE,KAAK,CAAE,CAAC,GACnBO,IAAI,CAAC,GAAG,CAAC;IACbP,KAAK,IAAI,CAAC;EACZ;EAEA,OAAOE,MAAM;AACf;AAEA;;;AAGA,eAAc,SAAUU,YAAYA,CAClCC,QAAgB,EAChBC,OAA6B,EAC7BC,GAAkB;;EAElB,IAAIrB,cAAc,CAACmB,QAAQ,EAAEC,OAAO,EAAEC,GAAG,CAAC,EAAE;IAC1C;EACF;EAEA,MAAMC,aAAa,GAAGH,QAAQ,CAACI,KAAK,CAAC,GAAG,CAAC;EAEzC,MAAMhB,WAAW,GACf,CAACa,OAAO,CAACI,mBAAmB,GAAE,4BAAqB,CAAC,KACnDJ,OAAO,CAACK,iBAAiB,GAAE,0BAAmB,CAAC,CAAC;EAEnD;EACA,MAAMC,cAAc,GAAGvB,YAAY,CACjCmB,aAAa,EACbrB,UAAU,EACVqB,aAAa,CAACK,MAAM,GAAG,CAAC,EACxBpB,WAAW,CACZ;EAED,IAAImB,cAAc,KAAK,IAAI,EAAE;IAC3BL,GAAG,CAACV,OAAO,GAAGe,cAAc,CAACf,OAAO;IACpCU,GAAG,CAACT,SAAS,GAAGc,cAAc,CAACd,SAAS;IACxCS,GAAG,CAACO,YAAY,GAAGN,aAAa,CAACO,KAAK,CAACH,cAAc,CAACpB,KAAK,GAAG,CAAC,CAAC,CAACwB,IAAI,CAAC,GAAG,CAAC;IAC1E;EACF;EAEA;EACA,MAAMC,UAAU,GAAG5B,YAAY,CAC7BmB,aAAa,EACbpB,KAAK,EACLoB,aAAa,CAACK,MAAM,GAAG,CAAC,EACxBpB,WAAW,CACZ;EAED,IAAIwB,UAAU,KAAK,IAAI,EAAE;IACvBV,GAAG,CAACV,OAAO,GAAGoB,UAAU,CAACpB,OAAO;IAChCU,GAAG,CAACT,SAAS,GAAGmB,UAAU,CAACnB,SAAS;IACpCS,GAAG,CAACO,YAAY,GAAGN,aAAa,CAACO,KAAK,CAACE,UAAU,CAACzB,KAAK,CAAC,CAACwB,IAAI,CAAC,GAAG,CAAC;IAClE;EACF;EAEA;EACA;EACA;EACAT,GAAG,CAACV,OAAO,GAAG,KAAK;EACnBU,GAAG,CAACT,SAAS,GAAG,KAAK;EACrBS,GAAG,CAACO,YAAY,GAAG,CAAAI,EAAA,GAAAV,aAAa,CAACA,aAAa,CAACK,MAAM,GAAG,CAAC,CAAC,cAAAK,EAAA,cAAAA,EAAA,GAAI,IAAI;AACpE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}