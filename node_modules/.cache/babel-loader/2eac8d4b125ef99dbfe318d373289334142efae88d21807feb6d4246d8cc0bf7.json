{"ast":null,"code":"import { offlineQueue } from '../services/offlineQueue';\n\n// API utility with retry logic and offline support\nexport const apiCall = async (url, options, retries = 3) => {\n  // Check if online\n  if (!navigator.onLine && options && (options.method === 'POST' || options.method === 'PATCH' || options.method === 'DELETE')) {\n    // Queue write operations when offline\n    offlineQueue.addRequest(url, options);\n    // Return a mock successful response for optimistic updates\n    return new Response(JSON.stringify({\n      success: true,\n      queued: true\n    }), {\n      status: 200,\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n  }\n  for (let i = 0; i < retries; i++) {\n    try {\n      const response = await fetch(url, options);\n\n      // Check if response is HTML (indicates MSW not working)\n      const contentType = response.headers.get('content-type');\n      if (contentType && contentType.includes('text/html')) {\n        throw new Error('Received HTML instead of JSON - MSW may not be ready');\n      }\n      return response;\n    } catch (error) {\n      console.warn(`API call attempt ${i + 1} failed:`, error);\n      if (i === retries - 1) {\n        // If this is a write operation and we've exhausted retries, queue it\n        if (options && (options.method === 'POST' || options.method === 'PATCH' || options.method === 'DELETE')) {\n          offlineQueue.addRequest(url, options);\n          return new Response(JSON.stringify({\n            success: true,\n            queued: true\n          }), {\n            status: 200,\n            headers: {\n              'Content-Type': 'application/json'\n            }\n          });\n        }\n        throw error;\n      }\n\n      // Wait before retry\n      await new Promise(resolve => setTimeout(resolve, 200 * (i + 1)));\n    }\n  }\n  throw new Error('All retry attempts failed');\n};","map":{"version":3,"names":["offlineQueue","apiCall","url","options","retries","navigator","onLine","method","addRequest","Response","JSON","stringify","success","queued","status","headers","i","response","fetch","contentType","get","includes","Error","error","console","warn","Promise","resolve","setTimeout"],"sources":["C:/Users/shiva/Desktop/talentflow-mini-hiring-platform/TalentFlow/src/utils/apiUtils.ts"],"sourcesContent":["import { offlineQueue } from '../services/offlineQueue';\n\n// API utility with retry logic and offline support\nexport const apiCall = async (url: string, options?: RequestInit, retries = 3): Promise<Response> => {\n  // Check if online\n  if (!navigator.onLine && options && (options.method === 'POST' || options.method === 'PATCH' || options.method === 'DELETE')) {\n    // Queue write operations when offline\n    offlineQueue.addRequest(url, options);\n    // Return a mock successful response for optimistic updates\n    return new Response(JSON.stringify({ success: true, queued: true }), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' }\n    });\n  }\n\n  for (let i = 0; i < retries; i++) {\n    try {\n      const response = await fetch(url, options);\n      \n      // Check if response is HTML (indicates MSW not working)\n      const contentType = response.headers.get('content-type');\n      if (contentType && contentType.includes('text/html')) {\n        throw new Error('Received HTML instead of JSON - MSW may not be ready');\n      }\n      \n      return response;\n    } catch (error) {\n      console.warn(`API call attempt ${i + 1} failed:`, error);\n      \n      if (i === retries - 1) {\n        // If this is a write operation and we've exhausted retries, queue it\n        if (options && (options.method === 'POST' || options.method === 'PATCH' || options.method === 'DELETE')) {\n          offlineQueue.addRequest(url, options);\n          return new Response(JSON.stringify({ success: true, queued: true }), {\n            status: 200,\n            headers: { 'Content-Type': 'application/json' }\n          });\n        }\n        throw error;\n      }\n      \n      // Wait before retry\n      await new Promise(resolve => setTimeout(resolve, 200 * (i + 1)));\n    }\n  }\n  \n  throw new Error('All retry attempts failed');\n};"],"mappings":"AAAA,SAASA,YAAY,QAAQ,0BAA0B;;AAEvD;AACA,OAAO,MAAMC,OAAO,GAAG,MAAAA,CAAOC,GAAW,EAAEC,OAAqB,EAAEC,OAAO,GAAG,CAAC,KAAwB;EACnG;EACA,IAAI,CAACC,SAAS,CAACC,MAAM,IAAIH,OAAO,KAAKA,OAAO,CAACI,MAAM,KAAK,MAAM,IAAIJ,OAAO,CAACI,MAAM,KAAK,OAAO,IAAIJ,OAAO,CAACI,MAAM,KAAK,QAAQ,CAAC,EAAE;IAC5H;IACAP,YAAY,CAACQ,UAAU,CAACN,GAAG,EAAEC,OAAO,CAAC;IACrC;IACA,OAAO,IAAIM,QAAQ,CAACC,IAAI,CAACC,SAAS,CAAC;MAAEC,OAAO,EAAE,IAAI;MAAEC,MAAM,EAAE;IAAK,CAAC,CAAC,EAAE;MACnEC,MAAM,EAAE,GAAG;MACXC,OAAO,EAAE;QAAE,cAAc,EAAE;MAAmB;IAChD,CAAC,CAAC;EACJ;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,OAAO,EAAEY,CAAC,EAAE,EAAE;IAChC,IAAI;MACF,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAChB,GAAG,EAAEC,OAAO,CAAC;;MAE1C;MACA,MAAMgB,WAAW,GAAGF,QAAQ,CAACF,OAAO,CAACK,GAAG,CAAC,cAAc,CAAC;MACxD,IAAID,WAAW,IAAIA,WAAW,CAACE,QAAQ,CAAC,WAAW,CAAC,EAAE;QACpD,MAAM,IAAIC,KAAK,CAAC,sDAAsD,CAAC;MACzE;MAEA,OAAOL,QAAQ;IACjB,CAAC,CAAC,OAAOM,KAAK,EAAE;MACdC,OAAO,CAACC,IAAI,CAAC,oBAAoBT,CAAC,GAAG,CAAC,UAAU,EAAEO,KAAK,CAAC;MAExD,IAAIP,CAAC,KAAKZ,OAAO,GAAG,CAAC,EAAE;QACrB;QACA,IAAID,OAAO,KAAKA,OAAO,CAACI,MAAM,KAAK,MAAM,IAAIJ,OAAO,CAACI,MAAM,KAAK,OAAO,IAAIJ,OAAO,CAACI,MAAM,KAAK,QAAQ,CAAC,EAAE;UACvGP,YAAY,CAACQ,UAAU,CAACN,GAAG,EAAEC,OAAO,CAAC;UACrC,OAAO,IAAIM,QAAQ,CAACC,IAAI,CAACC,SAAS,CAAC;YAAEC,OAAO,EAAE,IAAI;YAAEC,MAAM,EAAE;UAAK,CAAC,CAAC,EAAE;YACnEC,MAAM,EAAE,GAAG;YACXC,OAAO,EAAE;cAAE,cAAc,EAAE;YAAmB;UAChD,CAAC,CAAC;QACJ;QACA,MAAMQ,KAAK;MACb;;MAEA;MACA,MAAM,IAAIG,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,GAAG,IAAIX,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAClE;EACF;EAEA,MAAM,IAAIM,KAAK,CAAC,2BAA2B,CAAC;AAC9C,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}