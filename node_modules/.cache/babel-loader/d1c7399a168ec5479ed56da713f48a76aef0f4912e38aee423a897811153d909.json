{"ast":null,"code":"import _defineProperty from \"C:/Users/shiva/Desktop/talentflow-mini-hiring-platform/TalentFlow/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { DeferredPromise } from \"@open-draft/deferred-promise\";\nconst DB_NAME = \"msw-websocket-clients\";\nconst DB_STORE_NAME = \"clients\";\nclass WebSocketIndexedDBClientStore {\n  constructor() {\n    _defineProperty(this, \"db\", void 0);\n    this.db = this.createDatabase();\n  }\n  async add(client) {\n    const promise = new DeferredPromise();\n    const store = await this.getStore();\n    const request = store.put({\n      id: client.id,\n      url: client.url.href\n    });\n    request.onsuccess = () => {\n      promise.resolve();\n    };\n    request.onerror = () => {\n      console.error(request.error);\n      promise.reject(new Error(\"Failed to add WebSocket client \\\"\".concat(client.id, \"\\\". There is likely an additional output above.\")));\n    };\n    return promise;\n  }\n  async getAll() {\n    const promise = new DeferredPromise();\n    const store = await this.getStore();\n    const request = store.getAll();\n    request.onsuccess = () => {\n      promise.resolve(request.result);\n    };\n    request.onerror = () => {\n      console.log(request.error);\n      promise.reject(new Error(\"Failed to get all WebSocket clients. There is likely an additional output above.\"));\n    };\n    return promise;\n  }\n  async deleteMany(clientIds) {\n    const promise = new DeferredPromise();\n    const store = await this.getStore();\n    for (const clientId of clientIds) {\n      store.delete(clientId);\n    }\n    store.transaction.oncomplete = () => {\n      promise.resolve();\n    };\n    store.transaction.onerror = () => {\n      console.error(store.transaction.error);\n      promise.reject(new Error(\"Failed to delete WebSocket clients [\".concat(clientIds.join(\", \"), \"]. There is likely an additional output above.\")));\n    };\n    return promise;\n  }\n  async createDatabase() {\n    const promise = new DeferredPromise();\n    const request = indexedDB.open(DB_NAME, 1);\n    request.onsuccess = _ref => {\n      let {\n        currentTarget\n      } = _ref;\n      const db = Reflect.get(currentTarget, \"result\");\n      if (db.objectStoreNames.contains(DB_STORE_NAME)) {\n        return promise.resolve(db);\n      }\n    };\n    request.onupgradeneeded = async _ref2 => {\n      let {\n        currentTarget\n      } = _ref2;\n      const db = Reflect.get(currentTarget, \"result\");\n      if (db.objectStoreNames.contains(DB_STORE_NAME)) {\n        return;\n      }\n      const store = db.createObjectStore(DB_STORE_NAME, {\n        keyPath: \"id\"\n      });\n      store.transaction.oncomplete = () => {\n        promise.resolve(db);\n      };\n      store.transaction.onerror = () => {\n        console.error(store.transaction.error);\n        promise.reject(new Error(\"Failed to create WebSocket client store. There is likely an additional output above.\"));\n      };\n    };\n    request.onerror = () => {\n      console.error(request.error);\n      promise.reject(new Error(\"Failed to open an IndexedDB database. There is likely an additional output above.\"));\n    };\n    return promise;\n  }\n  async getStore() {\n    const db = await this.db;\n    return db.transaction(DB_STORE_NAME, \"readwrite\").objectStore(DB_STORE_NAME);\n  }\n}\nexport { WebSocketIndexedDBClientStore };","map":{"version":3,"names":["DeferredPromise","DB_NAME","DB_STORE_NAME","WebSocketIndexedDBClientStore","constructor","_defineProperty","db","createDatabase","add","client","promise","store","getStore","request","put","id","url","href","onsuccess","resolve","onerror","console","error","reject","Error","concat","getAll","result","log","deleteMany","clientIds","clientId","delete","transaction","oncomplete","join","indexedDB","open","_ref","currentTarget","Reflect","get","objectStoreNames","contains","onupgradeneeded","_ref2","createObjectStore","keyPath","objectStore"],"sources":["C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\core\\ws\\WebSocketIndexedDBClientStore.ts"],"sourcesContent":["import { DeferredPromise } from '@open-draft/deferred-promise'\nimport { WebSocketClientConnectionProtocol } from '@mswjs/interceptors/lib/browser/interceptors/WebSocket'\nimport {\n  type SerializedWebSocketClient,\n  WebSocketClientStore,\n} from './WebSocketClientStore'\n\nconst DB_NAME = 'msw-websocket-clients'\nconst DB_STORE_NAME = 'clients'\n\nexport class WebSocketIndexedDBClientStore implements WebSocketClientStore {\n  private db: Promise<IDBDatabase>\n\n  constructor() {\n    this.db = this.createDatabase()\n  }\n\n  public async add(client: WebSocketClientConnectionProtocol): Promise<void> {\n    const promise = new DeferredPromise<void>()\n    const store = await this.getStore()\n\n    /**\n     * @note Use `.put()` instead of `.add()` to allow setting clients\n     * that already exist in the database. This can happen if a single page\n     * has multiple event handlers. Each handler will receive the \"connection\"\n     * event in parallel, and try to set that WebSocket client in the database.\n     */\n    const request = store.put({\n      id: client.id,\n      url: client.url.href,\n    } satisfies SerializedWebSocketClient)\n\n    request.onsuccess = () => {\n      promise.resolve()\n    }\n    request.onerror = () => {\n      console.error(request.error)\n      promise.reject(\n        new Error(\n          `Failed to add WebSocket client \"${client.id}\". There is likely an additional output above.`,\n        ),\n      )\n    }\n\n    return promise\n  }\n\n  public async getAll(): Promise<Array<SerializedWebSocketClient>> {\n    const promise = new DeferredPromise<Array<SerializedWebSocketClient>>()\n    const store = await this.getStore()\n    const request = store.getAll() as IDBRequest<\n      Array<SerializedWebSocketClient>\n    >\n\n    request.onsuccess = () => {\n      promise.resolve(request.result)\n    }\n    request.onerror = () => {\n      // eslint-disable-next-line no-console\n      console.log(request.error)\n      promise.reject(\n        new Error(\n          `Failed to get all WebSocket clients. There is likely an additional output above.`,\n        ),\n      )\n    }\n\n    return promise\n  }\n\n  public async deleteMany(clientIds: Array<string>): Promise<void> {\n    const promise = new DeferredPromise<void>()\n    const store = await this.getStore()\n\n    for (const clientId of clientIds) {\n      store.delete(clientId)\n    }\n\n    store.transaction.oncomplete = () => {\n      promise.resolve()\n    }\n    store.transaction.onerror = () => {\n      console.error(store.transaction.error)\n      promise.reject(\n        new Error(\n          `Failed to delete WebSocket clients [${clientIds.join(', ')}]. There is likely an additional output above.`,\n        ),\n      )\n    }\n\n    return promise\n  }\n\n  private async createDatabase(): Promise<IDBDatabase> {\n    const promise = new DeferredPromise<IDBDatabase>()\n    const request = indexedDB.open(DB_NAME, 1)\n\n    request.onsuccess = ({ currentTarget }) => {\n      const db = Reflect.get(currentTarget!, 'result') as IDBDatabase\n\n      if (db.objectStoreNames.contains(DB_STORE_NAME)) {\n        return promise.resolve(db)\n      }\n    }\n\n    request.onupgradeneeded = async ({ currentTarget }) => {\n      const db = Reflect.get(currentTarget!, 'result') as IDBDatabase\n      if (db.objectStoreNames.contains(DB_STORE_NAME)) {\n        return\n      }\n\n      const store = db.createObjectStore(DB_STORE_NAME, { keyPath: 'id' })\n      store.transaction.oncomplete = () => {\n        promise.resolve(db)\n      }\n      store.transaction.onerror = () => {\n        console.error(store.transaction.error)\n        promise.reject(\n          new Error(\n            'Failed to create WebSocket client store. There is likely an additional output above.',\n          ),\n        )\n      }\n    }\n    request.onerror = () => {\n      console.error(request.error)\n      promise.reject(\n        new Error(\n          'Failed to open an IndexedDB database. There is likely an additional output above.',\n        ),\n      )\n    }\n\n    return promise\n  }\n\n  private async getStore(): Promise<IDBObjectStore> {\n    const db = await this.db\n    return db.transaction(DB_STORE_NAME, 'readwrite').objectStore(DB_STORE_NAME)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}