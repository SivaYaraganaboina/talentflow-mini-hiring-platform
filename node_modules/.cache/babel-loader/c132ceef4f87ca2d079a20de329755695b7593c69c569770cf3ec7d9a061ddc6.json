{"ast":null,"code":"import _classPrivateMethodInitSpec from \"C:/Users/shiva/Desktop/talentflow-mini-hiring-platform/TalentFlow/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _defineProperty from \"C:/Users/shiva/Desktop/talentflow-mini-hiring-platform/TalentFlow/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/shiva/Desktop/talentflow-mini-hiring-platform/TalentFlow/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _assertClassBrand from \"C:/Users/shiva/Desktop/talentflow-mini-hiring-platform/TalentFlow/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldGet from \"C:/Users/shiva/Desktop/talentflow-mini-hiring-platform/TalentFlow/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"C:/Users/shiva/Desktop/talentflow-mini-hiring-platform/TalentFlow/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nvar _executor, _Class_brand;\n// src/createDeferredExecutor.ts\nfunction createDeferredExecutor() {\n  const executor = (resolve, reject) => {\n    executor.state = \"pending\";\n    executor.resolve = data => {\n      if (executor.state !== \"pending\") {\n        return;\n      }\n      executor.result = data;\n      const onFulfilled = value => {\n        executor.state = \"fulfilled\";\n        return value;\n      };\n      return resolve(data instanceof Promise ? data : Promise.resolve(data).then(onFulfilled));\n    };\n    executor.reject = reason => {\n      if (executor.state !== \"pending\") {\n        return;\n      }\n      queueMicrotask(() => {\n        executor.state = \"rejected\";\n      });\n      return reject(executor.rejectionReason = reason);\n    };\n  };\n  return executor;\n}\n\n// src/DeferredPromise.ts\nvar DeferredPromise = (_executor = /*#__PURE__*/new WeakMap(), _Class_brand = /*#__PURE__*/new WeakSet(), class DeferredPromise extends Promise {\n  constructor() {\n    let executor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const deferredExecutor = createDeferredExecutor();\n    super((originalResolve, originalReject) => {\n      deferredExecutor(originalResolve, originalReject);\n      executor === null || executor === void 0 || executor(deferredExecutor.resolve, deferredExecutor.reject);\n    });\n    _classPrivateMethodInitSpec(this, _Class_brand);\n    _classPrivateFieldInitSpec(this, _executor, void 0);\n    _defineProperty(this, \"resolve\", void 0);\n    _defineProperty(this, \"reject\", void 0);\n    _classPrivateFieldSet(_executor, this, deferredExecutor);\n    this.resolve = _classPrivateFieldGet(_executor, this).resolve;\n    this.reject = _classPrivateFieldGet(_executor, this).reject;\n  }\n  get state() {\n    return _classPrivateFieldGet(_executor, this).state;\n  }\n  get rejectionReason() {\n    return _classPrivateFieldGet(_executor, this).rejectionReason;\n  }\n  then(onFulfilled, onRejected) {\n    return _assertClassBrand(_Class_brand, this, _decorate).call(this, super.then(onFulfilled, onRejected));\n  }\n  catch(onRejected) {\n    return _assertClassBrand(_Class_brand, this, _decorate).call(this, super.catch(onRejected));\n  }\n  finally(onfinally) {\n    return _assertClassBrand(_Class_brand, this, _decorate).call(this, super.finally(onfinally));\n  }\n});\nfunction _decorate(promise) {\n  return Object.defineProperties(promise, {\n    resolve: {\n      configurable: true,\n      value: this.resolve\n    },\n    reject: {\n      configurable: true,\n      value: this.reject\n    }\n  });\n}\nexport { DeferredPromise, createDeferredExecutor };","map":{"version":3,"names":["createDeferredExecutor","executor","resolve","reject","state","data","result","onFulfilled","value","Promise","then","reason","queueMicrotask","rejectionReason","DeferredPromise","_executor","WeakMap","_Class_brand","WeakSet","constructor","arguments","length","undefined","deferredExecutor","originalResolve","originalReject","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_defineProperty","_classPrivateFieldSet","_classPrivateFieldGet","onRejected","_assertClassBrand","_decorate","call","catch","finally","onfinally","promise","Object","defineProperties","configurable"],"sources":["C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\@open-draft\\deferred-promise\\src\\createDeferredExecutor.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\@open-draft\\deferred-promise\\src\\DeferredPromise.ts"],"sourcesContent":["export type PromiseState = 'pending' | 'fulfilled' | 'rejected'\n\nexport type Executor<Value> = ConstructorParameters<typeof Promise<Value>>[0]\nexport type ResolveFunction<Value> = Parameters<Executor<Value>>[0]\nexport type RejectFunction<Reason> = Parameters<Executor<Reason>>[1]\n\nexport type DeferredPromiseExecutor<Input = never, Output = Input> = {\n  (resolve?: ResolveFunction<Input>, reject?: RejectFunction<any>): void\n\n  resolve: ResolveFunction<Input>\n  reject: RejectFunction<any>\n  result?: Output\n  state: PromiseState\n  rejectionReason?: unknown\n}\nexport function createDeferredExecutor<\n  Input = never,\n  Output = Input\n>(): DeferredPromiseExecutor<Input, Output> {\n  const executor = <DeferredPromiseExecutor<Input, Output>>((\n    resolve,\n    reject\n  ) => {\n    executor.state = 'pending'\n\n    executor.resolve = (data) => {\n      if (executor.state !== 'pending') {\n        return\n      }\n\n      executor.result = data as Output\n\n      const onFulfilled = <Value>(value: Value) => {\n        executor.state = 'fulfilled'\n        return value\n      }\n\n      return resolve(\n        data instanceof Promise ? data : Promise.resolve(data).then(onFulfilled)\n      )\n    }\n\n    executor.reject = (reason) => {\n      if (executor.state !== 'pending') {\n        return\n      }\n\n      queueMicrotask(() => {\n        executor.state = 'rejected'\n      })\n\n      return reject((executor.rejectionReason = reason))\n    }\n  })\n\n  return executor\n}\n","import {\n  type Executor,\n  type RejectFunction,\n  type ResolveFunction,\n  type DeferredPromiseExecutor,\n  createDeferredExecutor,\n} from './createDeferredExecutor'\n\nexport class DeferredPromise<Input, Output = Input> extends Promise<Input> {\n  #executor: DeferredPromiseExecutor\n\n  public resolve: ResolveFunction<Output>\n  public reject: RejectFunction<Output>\n\n  constructor(executor: Executor<Input> | null = null) {\n    const deferredExecutor = createDeferredExecutor()\n    super((originalResolve, originalReject) => {\n      deferredExecutor(originalResolve, originalReject)\n      executor?.(deferredExecutor.resolve, deferredExecutor.reject)\n    })\n\n    this.#executor = deferredExecutor\n    this.resolve = this.#executor.resolve\n    this.reject = this.#executor.reject\n  }\n\n  public get state() {\n    return this.#executor.state\n  }\n\n  public get rejectionReason() {\n    return this.#executor.rejectionReason\n  }\n\n  public then<ThenResult = Input, CatchResult = never>(\n    onFulfilled?: (value: Input) => ThenResult | PromiseLike<ThenResult>,\n    onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>\n  ) {\n    return this.#decorate(super.then(onFulfilled, onRejected))\n  }\n\n  public catch<CatchResult = never>(\n    onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>\n  ) {\n    return this.#decorate(super.catch(onRejected))\n  }\n\n  public finally(onfinally?: () => void | Promise<any>) {\n    return this.#decorate(super.finally(onfinally))\n  }\n\n  #decorate<ChildInput>(\n    promise: Promise<ChildInput>\n  ): DeferredPromise<ChildInput, Output> {\n    return Object.defineProperties(promise, {\n      resolve: { configurable: true, value: this.resolve },\n      reject: { configurable: true, value: this.reject },\n    }) as DeferredPromise<ChildInput, Output>\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}