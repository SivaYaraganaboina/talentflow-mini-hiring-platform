{"ast":null,"code":"import _objectSpread from \"C:/Users/shiva/Desktop/talentflow-mini-hiring-platform/TalentFlow/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classPrivateMethodInitSpec from \"C:/Users/shiva/Desktop/talentflow-mini-hiring-platform/TalentFlow/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _defineProperty from \"C:/Users/shiva/Desktop/talentflow-mini-hiring-platform/TalentFlow/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/shiva/Desktop/talentflow-mini-hiring-platform/TalentFlow/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _assertClassBrand from \"C:/Users/shiva/Desktop/talentflow-mini-hiring-platform/TalentFlow/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldGet from \"C:/Users/shiva/Desktop/talentflow-mini-hiring-platform/TalentFlow/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"C:/Users/shiva/Desktop/talentflow-mini-hiring-platform/TalentFlow/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nvar _executor, _Class_brand, _returnType, _listeners, _Class5_brand, _workerEvent;\n// node_modules/.pnpm/outvariant@1.4.3/node_modules/outvariant/lib/index.mjs\nvar POSITIONALS_EXP = /(%?)(%([sdijo]))/g;\nfunction serializePositional(positional, flag) {\n  switch (flag) {\n    case \"s\":\n      return positional;\n    case \"d\":\n    case \"i\":\n      return Number(positional);\n    case \"j\":\n      return JSON.stringify(positional);\n    case \"o\":\n      {\n        if (typeof positional === \"string\") {\n          return positional;\n        }\n        const json = JSON.stringify(positional);\n        if (json === \"{}\" || json === \"[]\" || /^\\[object .+?\\]$/.test(json)) {\n          return positional;\n        }\n        return json;\n      }\n  }\n}\nfunction format(message) {\n  for (var _len = arguments.length, positionals = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    positionals[_key - 1] = arguments[_key];\n  }\n  if (positionals.length === 0) {\n    return message;\n  }\n  let positionalIndex = 0;\n  let formattedMessage = message.replace(POSITIONALS_EXP, (match, isEscaped, _, flag) => {\n    const positional = positionals[positionalIndex];\n    const value = serializePositional(positional, flag);\n    if (!isEscaped) {\n      positionalIndex++;\n      return value;\n    }\n    return match;\n  });\n  if (positionalIndex < positionals.length) {\n    formattedMessage += \" \".concat(positionals.slice(positionalIndex).join(\" \"));\n  }\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, \"%\");\n  return formattedMessage;\n}\nvar STACK_FRAMES_TO_IGNORE = 2;\nfunction cleanErrorStack(error2) {\n  if (!error2.stack) {\n    return;\n  }\n  const nextStack = error2.stack.split(\"\\n\");\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE);\n  error2.stack = nextStack.join(\"\\n\");\n}\nvar InvariantError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = \"Invariant Violation\";\n    for (var _len2 = arguments.length, positionals = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      positionals[_key2 - 1] = arguments[_key2];\n    }\n    this.message = format(message, ...positionals);\n    cleanErrorStack(this);\n  }\n};\nvar invariant = function (predicate, message) {\n  if (!predicate) {\n    for (var _len3 = arguments.length, positionals = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      positionals[_key3 - 2] = arguments[_key3];\n    }\n    throw new InvariantError(message, ...positionals);\n  }\n};\ninvariant.as = function (ErrorConstructor, predicate, message) {\n  if (!predicate) {\n    for (var _len4 = arguments.length, positionals = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n      positionals[_key4 - 3] = arguments[_key4];\n    }\n    const formatMessage = positionals.length === 0 ? message : format(message, ...positionals);\n    let error2;\n    try {\n      error2 = Reflect.construct(ErrorConstructor, [formatMessage]);\n    } catch (err) {\n      error2 = ErrorConstructor(formatMessage);\n    }\n    throw error2;\n  }\n};\n\n// node_modules/.pnpm/is-node-process@1.2.0/node_modules/is-node-process/lib/index.mjs\nfunction isNodeProcess() {\n  if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n    return true;\n  }\n  if (typeof process !== \"undefined\") {\n    const type = process.type;\n    if (type === \"renderer\" || type === \"worker\") {\n      return false;\n    }\n    return !!(process.versions && process.versions.node);\n  }\n  return false;\n}\n\n// src/browser/setupWorker/start/utils/prepareStartHandler.ts\nimport { mergeRight } from '../core/utils/internal/mergeRight.mjs';\nvar DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: \"/mockServiceWorker.js\",\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: \"warn\",\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n};\n\n// src/browser/setupWorker/start/createStartHandler.ts\nimport { devUtils as devUtils6 } from '../core/utils/internal/devUtils.mjs';\n\n// node_modules/.pnpm/@open-draft+until@2.1.0/node_modules/@open-draft/until/lib/index.mjs\nvar until = async promise => {\n  try {\n    const data = await promise().catch(error2 => {\n      throw error2;\n    });\n    return {\n      error: null,\n      data\n    };\n  } catch (error2) {\n    return {\n      error: error2,\n      data: null\n    };\n  }\n};\n\n// src/browser/setupWorker/start/utils/getWorkerInstance.ts\nimport { devUtils } from '../core/utils/internal/devUtils.mjs';\n\n// src/browser/utils/getAbsoluteWorkerUrl.ts\nfunction getAbsoluteWorkerUrl(workerUrl) {\n  return new URL(workerUrl, location.href).href;\n}\n\n// src/browser/setupWorker/start/utils/getWorkerByRegistration.ts\nfunction getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker) {\n  const allStates = [registration.active, registration.installing, registration.waiting];\n  const relevantStates = allStates.filter(state => {\n    return state != null;\n  });\n  const worker = relevantStates.find(worker2 => {\n    return findWorker(worker2.scriptURL, absoluteWorkerUrl);\n  });\n  return worker || null;\n}\n\n// src/browser/setupWorker/start/utils/getWorkerInstance.ts\nvar getWorkerInstance = async function (url) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let findWorker = arguments.length > 2 ? arguments[2] : undefined;\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n  const mockRegistrations = await navigator.serviceWorker.getRegistrations().then(registrations => registrations.filter(registration => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)));\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    location.reload();\n  }\n  const [existingRegistration] = mockRegistrations;\n  if (existingRegistration) {\n    existingRegistration.update();\n    return [getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker), existingRegistration];\n  }\n  const registrationResult = await until(async () => {\n    const registration = await navigator.serviceWorker.register(url, options);\n    return [\n    // Compare existing worker registration by its worker URL,\n    // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n    getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker), registration];\n  });\n  if (registrationResult.error) {\n    const isWorkerMissing = registrationResult.error.message.includes(\"(404)\");\n    if (isWorkerMissing) {\n      const scopeUrl = new URL((options === null || options === void 0 ? void 0 : options.scope) || \"/\", location.href);\n      throw new Error(devUtils.formatMessage(\"Failed to register a Service Worker for scope ('\".concat(scopeUrl.href, \"') with script ('\").concat(absoluteWorkerUrl, \"'): Service Worker script does not exist at the given path.\\n\\nDid you forget to run \\\"npx msw init <PUBLIC_DIR>\\\"?\\n\\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init\")));\n    }\n    throw new Error(devUtils.formatMessage(\"Failed to register the Service Worker:\\n\\n%s\", registrationResult.error.message));\n  }\n  return registrationResult.data;\n};\n\n// node_modules/.pnpm/@open-draft+deferred-promise@2.2.0/node_modules/@open-draft/deferred-promise/build/index.mjs\nfunction createDeferredExecutor() {\n  const executor = (resolve, reject) => {\n    executor.state = \"pending\";\n    executor.resolve = data => {\n      if (executor.state !== \"pending\") {\n        return;\n      }\n      executor.result = data;\n      const onFulfilled = value => {\n        executor.state = \"fulfilled\";\n        return value;\n      };\n      return resolve(data instanceof Promise ? data : Promise.resolve(data).then(onFulfilled));\n    };\n    executor.reject = reason => {\n      if (executor.state !== \"pending\") {\n        return;\n      }\n      queueMicrotask(() => {\n        executor.state = \"rejected\";\n      });\n      return reject(executor.rejectionReason = reason);\n    };\n  };\n  return executor;\n}\nvar DeferredPromise = (_executor = /*#__PURE__*/new WeakMap(), _Class_brand = /*#__PURE__*/new WeakSet(), class DeferredPromise extends Promise {\n  constructor() {\n    let executor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const deferredExecutor = createDeferredExecutor();\n    super((originalResolve, originalReject) => {\n      deferredExecutor(originalResolve, originalReject);\n      executor === null || executor === void 0 || executor(deferredExecutor.resolve, deferredExecutor.reject);\n    });\n    _classPrivateMethodInitSpec(this, _Class_brand);\n    _classPrivateFieldInitSpec(this, _executor, void 0);\n    _defineProperty(this, \"resolve\", void 0);\n    _defineProperty(this, \"reject\", void 0);\n    _classPrivateFieldSet(_executor, this, deferredExecutor);\n    this.resolve = _classPrivateFieldGet(_executor, this).resolve;\n    this.reject = _classPrivateFieldGet(_executor, this).reject;\n  }\n  get state() {\n    return _classPrivateFieldGet(_executor, this).state;\n  }\n  get rejectionReason() {\n    return _classPrivateFieldGet(_executor, this).rejectionReason;\n  }\n  then(onFulfilled, onRejected) {\n    return _assertClassBrand(_Class_brand, this, _decorate).call(this, super.then(onFulfilled, onRejected));\n  }\n  catch(onRejected) {\n    return _assertClassBrand(_Class_brand, this, _decorate).call(this, super.catch(onRejected));\n  }\n  finally(onfinally) {\n    return _assertClassBrand(_Class_brand, this, _decorate).call(this, super.finally(onfinally));\n  }\n});\n\n// src/browser/setupWorker/start/utils/printStartMessage.ts\nfunction _decorate(promise) {\n  return Object.defineProperties(promise, {\n    resolve: {\n      configurable: true,\n      value: this.resolve\n    },\n    reject: {\n      configurable: true,\n      value: this.reject\n    }\n  });\n}\nimport { devUtils as devUtils2 } from '../core/utils/internal/devUtils.mjs';\nfunction printStartMessage() {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (args.quiet) {\n    return;\n  }\n  const message = args.message || \"Mocking enabled.\";\n  console.groupCollapsed(\"%c\".concat(devUtils2.formatMessage(message)), \"color:orangered;font-weight:bold;\");\n  console.log(\"%cDocumentation: %chttps://mswjs.io/docs\", \"font-weight:bold\", \"font-weight:normal\");\n  console.log(\"Found an issue? https://github.com/mswjs/msw/issues\");\n  if (args.workerUrl) {\n    console.log(\"Worker script URL:\", args.workerUrl);\n  }\n  if (args.workerScope) {\n    console.log(\"Worker scope:\", args.workerScope);\n  }\n  if (args.client) {\n    console.log(\"Client ID: %s (%s)\", args.client.id, args.client.frameType);\n  }\n  console.groupEnd();\n}\n\n// src/browser/setupWorker/start/utils/enableMocking.ts\nfunction enableMocking(context, options) {\n  const mockingEnabledPromise = new DeferredPromise();\n  context.workerChannel.postMessage(\"MOCK_ACTIVATE\");\n  context.workerChannel.once(\"MOCKING_ENABLED\", async event => {\n    var _context$registration;\n    context.isMockingEnabled = true;\n    const worker = await context.workerPromise;\n    printStartMessage({\n      quiet: options.quiet,\n      workerScope: (_context$registration = context.registration) === null || _context$registration === void 0 ? void 0 : _context$registration.scope,\n      workerUrl: worker.scriptURL,\n      client: event.data.client\n    });\n    mockingEnabledPromise.resolve(true);\n  });\n  return mockingEnabledPromise;\n}\n\n// src/browser/utils/pruneGetRequestBody.ts\nfunction pruneGetRequestBody(request) {\n  if ([\"HEAD\", \"GET\"].includes(request.method)) {\n    return void 0;\n  }\n  return request.body;\n}\n\n// src/browser/utils/deserializeRequest.ts\nfunction deserializeRequest(serializedRequest) {\n  return new Request(serializedRequest.url, _objectSpread(_objectSpread({}, serializedRequest), {}, {\n    body: pruneGetRequestBody(serializedRequest)\n  }));\n}\n\n// src/browser/setupWorker/start/createRequestListener.ts\nimport { RequestHandler } from '../core/handlers/RequestHandler.mjs';\nimport { handleRequest } from '../core/utils/handleRequest.mjs';\nimport { devUtils as devUtils3 } from '../core/utils/internal/devUtils.mjs';\nimport { toResponseInit } from '../core/utils/toResponseInit.mjs';\nimport { isHandlerKind } from '../core/utils/internal/isHandlerKind.mjs';\nvar createRequestListener = (context, options) => {\n  return async event => {\n    if (!context.isMockingEnabled && context.workerStoppedAt && event.data.interceptedAt > context.workerStoppedAt) {\n      event.postMessage(\"PASSTHROUGH\");\n      return;\n    }\n    const requestId = event.data.id;\n    const request = deserializeRequest(event.data);\n    const requestCloneForLogs = request.clone();\n    const requestClone = request.clone();\n    RequestHandler.cache.set(request, requestClone);\n    try {\n      await handleRequest(request, requestId, context.getRequestHandlers().filter(isHandlerKind(\"RequestHandler\")), options, context.emitter, {\n        onPassthroughResponse() {\n          event.postMessage(\"PASSTHROUGH\");\n        },\n        async onMockedResponse(response, _ref) {\n          let {\n            handler,\n            parsedResult\n          } = _ref;\n          const responseClone = response.clone();\n          const responseCloneForLogs = response.clone();\n          const responseInit = toResponseInit(response);\n          if (context.supports.readableStreamTransfer) {\n            const responseStreamOrNull = response.body;\n            event.postMessage(\"MOCK_RESPONSE\", _objectSpread(_objectSpread({}, responseInit), {}, {\n              body: responseStreamOrNull\n            }), responseStreamOrNull ? [responseStreamOrNull] : void 0);\n          } else {\n            const responseBufferOrNull = response.body === null ? null : await responseClone.arrayBuffer();\n            event.postMessage(\"MOCK_RESPONSE\", _objectSpread(_objectSpread({}, responseInit), {}, {\n              body: responseBufferOrNull\n            }));\n          }\n          if (!options.quiet) {\n            context.emitter.once(\"response:mocked\", () => {\n              handler.log({\n                request: requestCloneForLogs,\n                response: responseCloneForLogs,\n                parsedResult\n              });\n            });\n          }\n        }\n      });\n    } catch (error2) {\n      if (error2 instanceof Error) {\n        var _error2$stack;\n        devUtils3.error(\"Uncaught exception in the request handler for \\\"%s %s\\\":\\n\\n%s\\n\\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/http/mocking-responses/error-responses\", request.method, request.url, (_error2$stack = error2.stack) !== null && _error2$stack !== void 0 ? _error2$stack : error2);\n        event.postMessage(\"MOCK_RESPONSE\", {\n          status: 500,\n          statusText: \"Request Handler Error\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            name: error2.name,\n            message: error2.message,\n            stack: error2.stack\n          })\n        });\n      }\n    }\n  };\n};\n\n// src/browser/utils/checkWorkerIntegrity.ts\nimport { devUtils as devUtils4 } from '../core/utils/internal/devUtils.mjs';\nfunction checkWorkerIntegrity(context) {\n  const integrityCheckPromise = new DeferredPromise();\n  context.workerChannel.postMessage(\"INTEGRITY_CHECK_REQUEST\");\n  context.workerChannel.once(\"INTEGRITY_CHECK_RESPONSE\", event => {\n    const {\n      checksum,\n      packageVersion\n    } = event.data;\n    if (checksum !== \"4db4a41e972cec1b64cc569c66952d82\") {\n      devUtils4.warn(\"The currently registered Service Worker has been generated by a different version of MSW (\".concat(packageVersion, \") and may not be fully compatible with the installed version.\\n\\nIt's recommended you update your worker script by running this command:\\n\\n  \\u2022 npx msw init <PUBLIC_DIR>\\n\\nYou can also automate this process and make the worker script update automatically upon the library installations. Read more: https://mswjs.io/docs/cli/init.\"));\n    }\n    integrityCheckPromise.resolve();\n  });\n  return integrityCheckPromise;\n}\n\n// node_modules/.pnpm/@mswjs+interceptors@0.39.1/node_modules/@mswjs/interceptors/lib/browser/chunk-6HYIRFX2.mjs\nvar encoder = new TextEncoder();\nfunction encodeBuffer(text) {\n  return encoder.encode(text);\n}\nfunction decodeBuffer(buffer, encoding) {\n  const decoder = new TextDecoder(encoding);\n  return decoder.decode(buffer);\n}\nfunction toArrayBuffer(array) {\n  return array.buffer.slice(array.byteOffset, array.byteOffset + array.byteLength);\n}\n\n// node_modules/.pnpm/@mswjs+interceptors@0.39.1/node_modules/@mswjs/interceptors/lib/browser/chunk-3RXCRGL2.mjs\nvar IS_PATCHED_MODULE = Symbol(\"isPatchedModule\");\nfunction canParseUrl(url) {\n  try {\n    new URL(url);\n    return true;\n  } catch (_error) {\n    return false;\n  }\n}\nfunction getValueBySymbol(symbolName, source) {\n  const ownSymbols = Object.getOwnPropertySymbols(source);\n  const symbol = ownSymbols.find(symbol2 => {\n    return symbol2.description === symbolName;\n  });\n  if (symbol) {\n    return Reflect.get(source, symbol);\n  }\n  return;\n}\nvar _FetchResponse = class extends Response {\n  static isConfigurableStatusCode(status) {\n    return status >= 200 && status <= 599;\n  }\n  static isRedirectResponse(status) {\n    return _FetchResponse.STATUS_CODES_WITH_REDIRECT.includes(status);\n  }\n  /**\n   * Returns a boolean indicating whether the given response status\n   * code represents a response that can have a body.\n   */\n  static isResponseWithBody(status) {\n    return !_FetchResponse.STATUS_CODES_WITHOUT_BODY.includes(status);\n  }\n  static setUrl(url, response) {\n    if (!url || url === \"about:\" || !canParseUrl(url)) {\n      return;\n    }\n    const state = getValueBySymbol(\"state\", response);\n    if (state) {\n      state.urlList.push(new URL(url));\n    } else {\n      Object.defineProperty(response, \"url\", {\n        value: url,\n        enumerable: true,\n        configurable: true,\n        writable: false\n      });\n    }\n  }\n  /**\n   * Parses the given raw HTTP headers into a Fetch API `Headers` instance.\n   */\n  static parseRawHeaders(rawHeaders) {\n    const headers = new Headers();\n    for (let line = 0; line < rawHeaders.length; line += 2) {\n      headers.append(rawHeaders[line], rawHeaders[line + 1]);\n    }\n    return headers;\n  }\n  constructor(body) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    const status = (_a = init.status) != null ? _a : 200;\n    const safeStatus = _FetchResponse.isConfigurableStatusCode(status) ? status : 200;\n    const finalBody = _FetchResponse.isResponseWithBody(status) ? body : null;\n    super(finalBody, {\n      status: safeStatus,\n      statusText: init.statusText,\n      headers: init.headers\n    });\n    if (status !== safeStatus) {\n      const state = getValueBySymbol(\"state\", this);\n      if (state) {\n        state.status = status;\n      } else {\n        Object.defineProperty(this, \"status\", {\n          value: status,\n          enumerable: true,\n          configurable: true,\n          writable: false\n        });\n      }\n    }\n    _FetchResponse.setUrl(init.url, this);\n  }\n};\nvar FetchResponse = _FetchResponse;\nFetchResponse.STATUS_CODES_WITHOUT_BODY = [101, 103, 204, 205, 304];\nFetchResponse.STATUS_CODES_WITH_REDIRECT = [301, 302, 303, 307, 308];\nvar kRawRequest = Symbol(\"kRawRequest\");\nfunction setRawRequest(request, rawRequest) {\n  Reflect.set(request, kRawRequest, rawRequest);\n}\n\n// node_modules/.pnpm/@open-draft+logger@0.3.0/node_modules/@open-draft/logger/lib/index.mjs\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar colors_exports = {};\n__export(colors_exports, {\n  blue: () => blue,\n  gray: () => gray,\n  green: () => green,\n  red: () => red,\n  yellow: () => yellow\n});\nfunction yellow(text) {\n  return \"\\x1B[33m\".concat(text, \"\\x1B[0m\");\n}\nfunction blue(text) {\n  return \"\\x1B[34m\".concat(text, \"\\x1B[0m\");\n}\nfunction gray(text) {\n  return \"\\x1B[90m\".concat(text, \"\\x1B[0m\");\n}\nfunction red(text) {\n  return \"\\x1B[31m\".concat(text, \"\\x1B[0m\");\n}\nfunction green(text) {\n  return \"\\x1B[32m\".concat(text, \"\\x1B[0m\");\n}\nvar IS_NODE = isNodeProcess();\nvar _Logger = class Logger {\n  constructor(name) {\n    _defineProperty(this, \"prefix\", void 0);\n    this.name = name;\n    this.prefix = \"[\".concat(this.name, \"]\");\n    const LOGGER_NAME = getVariable(\"DEBUG\");\n    const LOGGER_LEVEL = getVariable(\"LOG_LEVEL\");\n    const isLoggingEnabled = LOGGER_NAME === \"1\" || LOGGER_NAME === \"true\" || typeof LOGGER_NAME !== \"undefined\" && this.name.startsWith(LOGGER_NAME);\n    if (isLoggingEnabled) {\n      this.debug = isDefinedAndNotEquals(LOGGER_LEVEL, \"debug\") ? noop : this.debug;\n      this.info = isDefinedAndNotEquals(LOGGER_LEVEL, \"info\") ? noop : this.info;\n      this.success = isDefinedAndNotEquals(LOGGER_LEVEL, \"success\") ? noop : this.success;\n      this.warning = isDefinedAndNotEquals(LOGGER_LEVEL, \"warning\") ? noop : this.warning;\n      this.error = isDefinedAndNotEquals(LOGGER_LEVEL, \"error\") ? noop : this.error;\n    } else {\n      this.info = noop;\n      this.success = noop;\n      this.warning = noop;\n      this.error = noop;\n      this.only = noop;\n    }\n  }\n  extend(domain) {\n    return new _Logger(\"\".concat(this.name, \":\").concat(domain));\n  }\n  /**\n   * Print a debug message.\n   * @example\n   * logger.debug('no duplicates found, creating a document...')\n   */\n  debug(message) {\n    for (var _len5 = arguments.length, positionals = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      positionals[_key5 - 1] = arguments[_key5];\n    }\n    this.logEntry({\n      level: \"debug\",\n      message: gray(message),\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"gray\"\n      }\n    });\n  }\n  /**\n   * Print an info message.\n   * @example\n   * logger.info('start parsing...')\n   */\n  info(message) {\n    var _this = this;\n    for (var _len6 = arguments.length, positionals = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n      positionals[_key6 - 1] = arguments[_key6];\n    }\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"blue\"\n      }\n    });\n    const performance2 = new PerformanceEntry();\n    return function (message2) {\n      performance2.measure();\n      for (var _len7 = arguments.length, positionals2 = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n        positionals2[_key7 - 1] = arguments[_key7];\n      }\n      _this.logEntry({\n        level: \"info\",\n        message: \"\".concat(message2, \" \").concat(gray(\"\".concat(performance2.deltaTime, \"ms\"))),\n        positionals: positionals2,\n        prefix: _this.prefix,\n        colors: {\n          prefix: \"blue\"\n        }\n      });\n    };\n  }\n  /**\n   * Print a success message.\n   * @example\n   * logger.success('successfully created document')\n   */\n  success(message) {\n    for (var _len8 = arguments.length, positionals = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n      positionals[_key8 - 1] = arguments[_key8];\n    }\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: \"\\u2714 \".concat(this.prefix),\n      colors: {\n        timestamp: \"green\",\n        prefix: \"green\"\n      }\n    });\n  }\n  /**\n   * Print a warning.\n   * @example\n   * logger.warning('found legacy document format')\n   */\n  warning(message) {\n    for (var _len9 = arguments.length, positionals = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n      positionals[_key9 - 1] = arguments[_key9];\n    }\n    this.logEntry({\n      level: \"warning\",\n      message,\n      positionals,\n      prefix: \"\\u26A0 \".concat(this.prefix),\n      colors: {\n        timestamp: \"yellow\",\n        prefix: \"yellow\"\n      }\n    });\n  }\n  /**\n   * Print an error message.\n   * @example\n   * logger.error('something went wrong')\n   */\n  error(message) {\n    for (var _len0 = arguments.length, positionals = new Array(_len0 > 1 ? _len0 - 1 : 0), _key0 = 1; _key0 < _len0; _key0++) {\n      positionals[_key0 - 1] = arguments[_key0];\n    }\n    this.logEntry({\n      level: \"error\",\n      message,\n      positionals,\n      prefix: \"\\u2716 \".concat(this.prefix),\n      colors: {\n        timestamp: \"red\",\n        prefix: \"red\"\n      }\n    });\n  }\n  /**\n   * Execute the given callback only when the logging is enabled.\n   * This is skipped in its entirety and has no runtime cost otherwise.\n   * This executes regardless of the log level.\n   * @example\n   * logger.only(() => {\n   *   logger.info('additional info')\n   * })\n   */\n  only(callback) {\n    callback();\n  }\n  createEntry(level, message) {\n    return {\n      timestamp: /* @__PURE__ */new Date(),\n      level,\n      message\n    };\n  }\n  logEntry(args) {\n    const {\n      level,\n      message,\n      prefix,\n      colors: customColors,\n      positionals = []\n    } = args;\n    const entry = this.createEntry(level, message);\n    const timestampColor = (customColors === null || customColors === void 0 ? void 0 : customColors.timestamp) || \"gray\";\n    const prefixColor = (customColors === null || customColors === void 0 ? void 0 : customColors.prefix) || \"gray\";\n    const colorize = {\n      timestamp: colors_exports[timestampColor],\n      prefix: colors_exports[prefixColor]\n    };\n    const write = this.getWriter(level);\n    write([colorize.timestamp(this.formatTimestamp(entry.timestamp))].concat(prefix != null ? colorize.prefix(prefix) : []).concat(serializeInput(message)).join(\" \"), ...positionals.map(serializeInput));\n  }\n  formatTimestamp(timestamp) {\n    return \"\".concat(timestamp.toLocaleTimeString(\"en-GB\"), \":\").concat(timestamp.getMilliseconds());\n  }\n  getWriter(level) {\n    switch (level) {\n      case \"debug\":\n      case \"success\":\n      case \"info\":\n        {\n          return log;\n        }\n      case \"warning\":\n        {\n          return warn;\n        }\n      case \"error\":\n        {\n          return error;\n        }\n    }\n  }\n};\nvar PerformanceEntry = class PerformanceEntry {\n  constructor() {\n    _defineProperty(this, \"startTime\", void 0);\n    _defineProperty(this, \"endTime\", void 0);\n    _defineProperty(this, \"deltaTime\", void 0);\n    this.startTime = performance.now();\n  }\n  measure() {\n    this.endTime = performance.now();\n    const deltaTime = this.endTime - this.startTime;\n    this.deltaTime = deltaTime.toFixed(2);\n  }\n};\nvar noop = () => void 0;\nfunction log(message) {\n  for (var _len1 = arguments.length, positionals = new Array(_len1 > 1 ? _len1 - 1 : 0), _key1 = 1; _key1 < _len1; _key1++) {\n    positionals[_key1 - 1] = arguments[_key1];\n  }\n  if (IS_NODE) {\n    process.stdout.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.log(message, ...positionals);\n}\nfunction warn(message) {\n  for (var _len10 = arguments.length, positionals = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\n    positionals[_key10 - 1] = arguments[_key10];\n  }\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.warn(message, ...positionals);\n}\nfunction error(message) {\n  for (var _len11 = arguments.length, positionals = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n    positionals[_key11 - 1] = arguments[_key11];\n  }\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.error(message, ...positionals);\n}\nfunction getVariable(variableName) {\n  var _globalThis$variableN;\n  if (IS_NODE) {\n    return process.env[variableName];\n  }\n  return (_globalThis$variableN = globalThis[variableName]) === null || _globalThis$variableN === void 0 ? void 0 : _globalThis$variableN.toString();\n}\nfunction isDefinedAndNotEquals(value, expected) {\n  return value !== void 0 && value !== expected;\n}\nfunction serializeInput(message) {\n  if (typeof message === \"undefined\") {\n    return \"undefined\";\n  }\n  if (message === null) {\n    return \"null\";\n  }\n  if (typeof message === \"string\") {\n    return message;\n  }\n  if (typeof message === \"object\") {\n    return JSON.stringify(message);\n  }\n  return message.toString();\n}\n\n// node_modules/.pnpm/strict-event-emitter@0.5.1/node_modules/strict-event-emitter/lib/index.mjs\nvar MemoryLeakError = class extends Error {\n  constructor(emitter, type, count) {\n    super(\"Possible EventEmitter memory leak detected. \".concat(count, \" \").concat(type.toString(), \" listeners added. Use emitter.setMaxListeners() to increase limit\"));\n    this.emitter = emitter;\n    this.type = type;\n    this.count = count;\n    this.name = \"MaxListenersExceededWarning\";\n  }\n};\nvar _Emitter = class {\n  static listenerCount(emitter, eventName) {\n    return emitter.listenerCount(eventName);\n  }\n  constructor() {\n    this.events = /* @__PURE__ */new Map();\n    this.maxListeners = _Emitter.defaultMaxListeners;\n    this.hasWarnedAboutPotentialMemoryLeak = false;\n  }\n  _emitInternalEvent(internalEventName, eventName, listener) {\n    this.emit(internalEventName, ...[eventName, listener]);\n  }\n  _getListeners(eventName) {\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || [];\n  }\n  _removeListener(listeners, listener) {\n    const index = listeners.indexOf(listener);\n    if (index > -1) {\n      listeners.splice(index, 1);\n    }\n    return [];\n  }\n  _wrapOnceListener(eventName, listener) {\n    var _this2 = this;\n    const onceListener = function () {\n      _this2.removeListener(eventName, onceListener);\n      for (var _len12 = arguments.length, data = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        data[_key12] = arguments[_key12];\n      }\n      return listener.apply(_this2, data);\n    };\n    Object.defineProperty(onceListener, \"name\", {\n      value: listener.name\n    });\n    return onceListener;\n  }\n  setMaxListeners(maxListeners) {\n    this.maxListeners = maxListeners;\n    return this;\n  }\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n  getMaxListeners() {\n    return this.maxListeners;\n  }\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n  eventNames() {\n    return Array.from(this.events.keys());\n  }\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n  emit(eventName) {\n    for (var _len13 = arguments.length, data = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {\n      data[_key13 - 1] = arguments[_key13];\n    }\n    const listeners = this._getListeners(eventName);\n    listeners.forEach(listener => {\n      listener.apply(this, data);\n    });\n    return listeners.length > 0;\n  }\n  addListener(eventName, listener) {\n    this._emitInternalEvent(\"newListener\", eventName, listener);\n    const nextListeners = this._getListeners(eventName).concat(listener);\n    this.events.set(eventName, nextListeners);\n    if (this.maxListeners > 0 && this.listenerCount(eventName) > this.maxListeners && !this.hasWarnedAboutPotentialMemoryLeak) {\n      this.hasWarnedAboutPotentialMemoryLeak = true;\n      const memoryLeakWarning = new MemoryLeakError(this, eventName, this.listenerCount(eventName));\n      console.warn(memoryLeakWarning);\n    }\n    return this;\n  }\n  on(eventName, listener) {\n    return this.addListener(eventName, listener);\n  }\n  once(eventName, listener) {\n    return this.addListener(eventName, this._wrapOnceListener(eventName, listener));\n  }\n  prependListener(eventName, listener) {\n    const listeners = this._getListeners(eventName);\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners);\n      this.events.set(eventName, nextListeners);\n    } else {\n      this.events.set(eventName, listeners.concat(listener));\n    }\n    return this;\n  }\n  prependOnceListener(eventName, listener) {\n    return this.prependListener(eventName, this._wrapOnceListener(eventName, listener));\n  }\n  removeListener(eventName, listener) {\n    const listeners = this._getListeners(eventName);\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener);\n      this.events.set(eventName, listeners);\n      this._emitInternalEvent(\"removeListener\", eventName, listener);\n    }\n    return this;\n  }\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n  off(eventName, listener) {\n    return this.removeListener(eventName, listener);\n  }\n  removeAllListeners(eventName) {\n    if (eventName) {\n      this.events.delete(eventName);\n    } else {\n      this.events.clear();\n    }\n    return this;\n  }\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n  listeners(eventName) {\n    return Array.from(this._getListeners(eventName));\n  }\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n  listenerCount(eventName) {\n    return this._getListeners(eventName).length;\n  }\n  rawListeners(eventName) {\n    return this.listeners(eventName);\n  }\n};\nvar Emitter = _Emitter;\nEmitter.defaultMaxListeners = 10;\n\n// node_modules/.pnpm/@mswjs+interceptors@0.39.1/node_modules/@mswjs/interceptors/lib/browser/chunk-QED3Q6Z2.mjs\nvar INTERNAL_REQUEST_ID_HEADER_NAME = \"x-interceptors-internal-request-id\";\nfunction getGlobalSymbol(symbol) {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || void 0\n  );\n}\nfunction setGlobalSymbol(symbol, value) {\n  globalThis[symbol] = value;\n}\nfunction deleteGlobalSymbol(symbol) {\n  delete globalThis[symbol];\n}\nvar Interceptor = class {\n  constructor(symbol) {\n    this.symbol = symbol;\n    this.readyState = \"INACTIVE\";\n    this.emitter = new Emitter();\n    this.subscriptions = [];\n    this.logger = new _Logger(symbol.description);\n    this.emitter.setMaxListeners(0);\n    this.logger.info(\"constructing the interceptor...\");\n  }\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  checkEnvironment() {\n    return true;\n  }\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  apply() {\n    const logger = this.logger.extend(\"apply\");\n    logger.info(\"applying the interceptor...\");\n    if (this.readyState === \"APPLIED\") {\n      logger.info(\"intercepted already applied!\");\n      return;\n    }\n    const shouldApply = this.checkEnvironment();\n    if (!shouldApply) {\n      logger.info(\"the interceptor cannot be applied in this environment!\");\n      return;\n    }\n    this.readyState = \"APPLYING\";\n    const runningInstance = this.getInstance();\n    if (runningInstance) {\n      logger.info(\"found a running instance, reusing...\");\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event);\n        runningInstance.emitter.addListener(event, listener);\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener);\n          logger.info('removed proxied \"%s\" listener!', event);\n        });\n        return this;\n      };\n      this.readyState = \"APPLIED\";\n      return;\n    }\n    logger.info(\"no running instance found, setting up a new instance...\");\n    this.setup();\n    this.setInstance();\n    this.readyState = \"APPLIED\";\n  }\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  setup() {}\n  /**\n   * Listen to the interceptor's public events.\n   */\n  on(event, listener) {\n    const logger = this.logger.extend(\"on\");\n    if (this.readyState === \"DISPOSING\" || this.readyState === \"DISPOSED\") {\n      logger.info(\"cannot listen to events, already disposed!\");\n      return this;\n    }\n    logger.info('adding \"%s\" event listener:', event, listener);\n    this.emitter.on(event, listener);\n    return this;\n  }\n  once(event, listener) {\n    this.emitter.once(event, listener);\n    return this;\n  }\n  off(event, listener) {\n    this.emitter.off(event, listener);\n    return this;\n  }\n  removeAllListeners(event) {\n    this.emitter.removeAllListeners(event);\n    return this;\n  }\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  dispose() {\n    const logger = this.logger.extend(\"dispose\");\n    if (this.readyState === \"DISPOSED\") {\n      logger.info(\"cannot dispose, already disposed!\");\n      return;\n    }\n    logger.info(\"disposing the interceptor...\");\n    this.readyState = \"DISPOSING\";\n    if (!this.getInstance()) {\n      logger.info(\"no interceptors running, skipping dispose...\");\n      return;\n    }\n    this.clearInstance();\n    logger.info(\"global symbol deleted:\", getGlobalSymbol(this.symbol));\n    if (this.subscriptions.length > 0) {\n      logger.info(\"disposing of %d subscriptions...\", this.subscriptions.length);\n      for (const dispose of this.subscriptions) {\n        dispose();\n      }\n      this.subscriptions = [];\n      logger.info(\"disposed of all subscriptions!\", this.subscriptions.length);\n    }\n    this.emitter.removeAllListeners();\n    logger.info(\"destroyed the listener!\");\n    this.readyState = \"DISPOSED\";\n  }\n  getInstance() {\n    var _a;\n    const instance = getGlobalSymbol(this.symbol);\n    this.logger.info(\"retrieved global instance:\", (_a = instance == null ? void 0 : instance.constructor) == null ? void 0 : _a.name);\n    return instance;\n  }\n  setInstance() {\n    setGlobalSymbol(this.symbol, this);\n    this.logger.info(\"set global instance!\", this.symbol.description);\n  }\n  clearInstance() {\n    deleteGlobalSymbol(this.symbol);\n    this.logger.info(\"cleared global instance!\", this.symbol.description);\n  }\n};\nfunction createRequestId() {\n  return Math.random().toString(16).slice(2);\n}\n\n// node_modules/.pnpm/@mswjs+interceptors@0.39.1/node_modules/@mswjs/interceptors/lib/browser/index.mjs\nvar BatchInterceptor = class extends Interceptor {\n  constructor(options) {\n    BatchInterceptor.symbol = Symbol(options.name);\n    super(BatchInterceptor.symbol);\n    this.interceptors = options.interceptors;\n  }\n  setup() {\n    const logger = this.logger.extend(\"setup\");\n    logger.info(\"applying all %d interceptors...\", this.interceptors.length);\n    for (const interceptor of this.interceptors) {\n      logger.info('applying \"%s\" interceptor...', interceptor.constructor.name);\n      interceptor.apply();\n      logger.info(\"adding interceptor dispose subscription\");\n      this.subscriptions.push(() => interceptor.dispose());\n    }\n  }\n  on(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.on(event, listener);\n    }\n    return this;\n  }\n  once(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.once(event, listener);\n    }\n    return this;\n  }\n  off(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.off(event, listener);\n    }\n    return this;\n  }\n  removeAllListeners(event) {\n    for (const interceptors of this.interceptors) {\n      interceptors.removeAllListeners(event);\n    }\n    return this;\n  }\n};\n\n// src/browser/setupWorker/start/createResponseListener.ts\nfunction createResponseListener(context) {\n  return event => {\n    var _responseMessage$resp;\n    const responseMessage = event.data;\n    const request = deserializeRequest(responseMessage.request);\n    if ((_responseMessage$resp = responseMessage.response.type) !== null && _responseMessage$resp !== void 0 && _responseMessage$resp.includes(\"opaque\")) {\n      return;\n    }\n    const response = responseMessage.response.status === 0 ? Response.error() : new FetchResponse(\n    /**\n     * Responses may be streams here, but when we create a response object\n     * with null-body status codes, like 204, 205, 304 Response will\n     * throw when passed a non-null body, so ensure it's null here\n     * for those codes\n     */\n    FetchResponse.isResponseWithBody(responseMessage.response.status) ? responseMessage.response.body : null, _objectSpread(_objectSpread({}, responseMessage), {}, {\n      /**\n       * Set response URL if it's not set already.\n       * @see https://github.com/mswjs/msw/issues/2030\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/Response/url\n       */\n      url: request.url\n    }));\n    context.emitter.emit(responseMessage.isMockedResponse ? \"response:mocked\" : \"response:bypass\", {\n      requestId: responseMessage.request.id,\n      request,\n      response\n    });\n  };\n}\n\n// src/browser/setupWorker/start/utils/validateWorkerScope.ts\nimport { devUtils as devUtils5 } from '../core/utils/internal/devUtils.mjs';\nfunction validateWorkerScope(registration, options) {\n  if (!(options !== null && options !== void 0 && options.quiet) && !location.href.startsWith(registration.scope)) {\n    devUtils5.warn(\"Cannot intercept requests on this page because it's outside of the worker's scope (\\\"\".concat(registration.scope, \"\\\"). If you wish to mock API requests on this page, you must resolve this scope issue.\\n\\n- (Recommended) Register the worker at the root level (\\\"/\\\") of your application.\\n- Set the \\\"Service-Worker-Allowed\\\" response header to allow out-of-scope workers.\"));\n  }\n}\n\n// src/browser/setupWorker/start/createStartHandler.ts\nvar createStartHandler = context => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      context.workerChannel.removeAllListeners();\n      context.workerChannel.on(\"REQUEST\", createRequestListener(context, options));\n      context.workerChannel.on(\"RESPONSE\", createResponseListener(context));\n      const instance = await getWorkerInstance(options.serviceWorker.url, options.serviceWorker.options, options.findWorker);\n      const [worker, registration] = instance;\n      if (!worker) {\n        const missingWorkerMessage = customOptions !== null && customOptions !== void 0 && customOptions.findWorker ? devUtils6.formatMessage(\"Failed to locate the Service Worker registration using a custom \\\"findWorker\\\" predicate.\\n\\nPlease ensure that the custom predicate properly locates the Service Worker registration at \\\"%s\\\".\\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\\n\", options.serviceWorker.url) : devUtils6.formatMessage(\"Failed to locate the Service Worker registration.\\n\\nThis most likely means that the worker script URL \\\"%s\\\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\\n\\nPlease consider using a custom \\\"serviceWorker.url\\\" option to point to the actual worker script location, or a custom \\\"findWorker\\\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start\", options.serviceWorker.url, location.host);\n        throw new Error(missingWorkerMessage);\n      }\n      context.workerPromise.resolve(worker);\n      context.registration = registration;\n      window.addEventListener(\"beforeunload\", () => {\n        if (worker.state !== \"redundant\") {\n          context.workerChannel.postMessage(\"CLIENT_CLOSED\");\n        }\n        window.clearInterval(context.keepAliveInterval);\n        window.postMessage({\n          type: \"msw/worker:stop\"\n        });\n      });\n      await checkWorkerIntegrity(context).catch(error2 => {\n        devUtils6.error(\"Error while checking the worker script integrity. Please report this on GitHub (https://github.com/mswjs/msw/issues) and include the original error below.\");\n        console.error(error2);\n      });\n      context.keepAliveInterval = window.setInterval(() => context.workerChannel.postMessage(\"KEEPALIVE_REQUEST\"), 5e3);\n      validateWorkerScope(registration, context.startOptions);\n      return registration;\n    };\n    const workerRegistration = startWorkerInstance().then(async registration => {\n      const pendingInstance = registration.installing || registration.waiting;\n      if (pendingInstance) {\n        const activationPromise = new DeferredPromise();\n        pendingInstance.addEventListener(\"statechange\", () => {\n          if (pendingInstance.state === \"activated\") {\n            activationPromise.resolve();\n          }\n        });\n        await activationPromise;\n      }\n      await enableMocking(context, options).catch(error2 => {\n        devUtils6.error(\"Failed to enable mocking. Please report this on GitHub (https://github.com/mswjs/msw/issues) and include the original error below.\");\n        throw error2;\n      });\n      return registration;\n    });\n    return workerRegistration;\n  };\n};\n\n// src/browser/setupWorker/setupWorker.ts\nimport { devUtils as devUtils8 } from '../core/utils/internal/devUtils.mjs';\nimport { SetupApi } from '../core/SetupApi.mjs';\nimport { mergeRight as mergeRight2 } from '../core/utils/internal/mergeRight.mjs';\n\n// src/browser/utils/supportsReadableStreamTransfer.ts\nfunction supportsReadableStreamTransfer() {\n  try {\n    const stream = new ReadableStream({\n      start: controller => controller.close()\n    });\n    const message = new MessageChannel();\n    message.port1.postMessage(stream, [stream]);\n    return true;\n  } catch (_unused) {\n    return false;\n  }\n}\n\n// src/browser/setupWorker/setupWorker.ts\nimport { webSocketInterceptor } from '../core/ws/webSocketInterceptor.mjs';\nimport { handleWebSocketEvent } from '../core/ws/handleWebSocketEvent.mjs';\nimport { attachWebSocketLogger } from '../core/ws/utils/attachWebSocketLogger.mjs';\n\n// node_modules/.pnpm/rettime@0.7.0/node_modules/rettime/build/index.js\nvar kDefaultPrevented = Symbol(\"kDefaultPrevented\");\nvar kPropagationStopped = Symbol(\"kPropagationStopped\");\nvar kImmediatePropagationStopped = Symbol(\"kImmediatePropagationStopped\");\nvar TypedEvent = (_returnType = /*#__PURE__*/new WeakMap(), class TypedEvent extends MessageEvent {\n  constructor() {\n    super(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1]);\n    /**\n     * @note Keep a placeholder property with the return type\n     * because the type must be set somewhere in order to be\n     * correctly associated and inferred from the event.\n     */\n    _classPrivateFieldInitSpec(this, _returnType, void 0);\n    _defineProperty(this, kDefaultPrevented, void 0);\n    _defineProperty(this, kPropagationStopped, void 0);\n    _defineProperty(this, kImmediatePropagationStopped, void 0);\n    this[kDefaultPrevented] = false;\n  }\n  get defaultPrevented() {\n    return this[kDefaultPrevented];\n  }\n  preventDefault() {\n    super.preventDefault();\n    this[kDefaultPrevented] = true;\n  }\n  stopImmediatePropagation() {\n    super.stopImmediatePropagation();\n    this[kImmediatePropagationStopped] = true;\n  }\n});\nvar kListenerOptions = Symbol(\"kListenerOptions\");\nvar Emitter2 = (_listeners = /*#__PURE__*/new WeakMap(), _Class5_brand = /*#__PURE__*/new WeakSet(), class Emitter2 {\n  constructor() {\n    _classPrivateMethodInitSpec(this, _Class5_brand);\n    _classPrivateFieldInitSpec(this, _listeners, void 0);\n    _classPrivateFieldSet(_listeners, this, {});\n  }\n  /**\n   * Adds a listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  on(type, listener, options) {\n    return _assertClassBrand(_Class5_brand, this, _addListener).call(this, type, listener, options);\n  }\n  /**\n   * Adds a one-time listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  once(type, listener, options) {\n    return this.on(type, listener, _objectSpread(_objectSpread({}, options || {}), {}, {\n      once: true\n    }));\n  }\n  /**\n   * Prepends a listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  earlyOn(type, listener, options) {\n    return _assertClassBrand(_Class5_brand, this, _addListener).call(this, type, listener, options, \"prepend\");\n  }\n  /**\n   * Prepends a one-time listener for the given event type.\n   */\n  earlyOnce(type, listener, options) {\n    return this.earlyOn(type, listener, _objectSpread(_objectSpread({}, options || {}), {}, {\n      once: true\n    }));\n  }\n  /**\n   * Emits the given typed event.\n   *\n   * @returns {boolean} Returns `true` if the event had any listeners, `false` otherwise.\n   */\n  emit(event) {\n    if (this.listenerCount(event.type) === 0) {\n      return false;\n    }\n    const proxiedEvent = _assertClassBrand(_Class5_brand, this, _proxyEvent).call(this, event);\n    for (const listener of _classPrivateFieldGet(_listeners, this)[event.type]) {\n      if (proxiedEvent.event[kPropagationStopped] != null && proxiedEvent.event[kPropagationStopped] !== this) {\n        return false;\n      }\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break;\n      }\n      _assertClassBrand(_Class5_brand, this, _callListener).call(this, proxiedEvent.event, listener);\n    }\n    proxiedEvent.revoke();\n    return true;\n  }\n  /**\n   * Emits the given typed event and returns a promise that resolves\n   * when all the listeners for that event have settled.\n   *\n   * @returns {Promise<Array<Emitter.ListenerReturnType>>} A promise that resolves\n   * with the return values of all listeners.\n   */\n  async emitAsPromise(event) {\n    if (this.listenerCount(event.type) === 0) {\n      return [];\n    }\n    const pendingListeners = [];\n    const proxiedEvent = _assertClassBrand(_Class5_brand, this, _proxyEvent).call(this, event);\n    for (const listener of _classPrivateFieldGet(_listeners, this)[event.type]) {\n      if (proxiedEvent.event[kPropagationStopped] != null && proxiedEvent.event[kPropagationStopped] !== this) {\n        return [];\n      }\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break;\n      }\n      pendingListeners.push(\n      // Awaiting individual listeners guarantees their call order.\n      await Promise.resolve(_assertClassBrand(_Class5_brand, this, _callListener).call(this, proxiedEvent.event, listener)));\n    }\n    proxiedEvent.revoke();\n    return Promise.allSettled(pendingListeners).then(results => {\n      return results.map(result => result.status === \"fulfilled\" ? result.value : result.reason);\n    });\n  }\n  /**\n   * Emits the given event and returns a generator that yields\n   * the result of each listener in the order of their registration.\n   * This way, you stop exhausting the listeners once you get the expected value.\n   */\n  *emitAsGenerator(event) {\n    if (this.listenerCount(event.type) === 0) {\n      return;\n    }\n    const proxiedEvent = _assertClassBrand(_Class5_brand, this, _proxyEvent).call(this, event);\n    for (const listener of _classPrivateFieldGet(_listeners, this)[event.type]) {\n      if (proxiedEvent.event[kPropagationStopped] != null && proxiedEvent.event[kPropagationStopped] !== this) {\n        return;\n      }\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break;\n      }\n      yield _assertClassBrand(_Class5_brand, this, _callListener).call(this, proxiedEvent.event, listener);\n    }\n    proxiedEvent.revoke();\n  }\n  /**\n   * Removes a listener for the given event type.\n   */\n  removeListener(type, listener) {\n    if (this.listenerCount(type) === 0) {\n      return;\n    }\n    const nextListeners = [];\n    for (const existingListener of _classPrivateFieldGet(_listeners, this)[type]) {\n      if (existingListener !== listener) {\n        nextListeners.push(existingListener);\n      }\n    }\n    _classPrivateFieldGet(_listeners, this)[type] = nextListeners;\n  }\n  /**\n   * Removes all listeners for the given event type.\n   * If no event type is provided, removes all existing listeners.\n   */\n  removeAllListeners(type) {\n    if (type == null) {\n      _classPrivateFieldSet(_listeners, this, {});\n      return;\n    }\n    _classPrivateFieldGet(_listeners, this)[type] = [];\n  }\n  /**\n   * Returns the list of listeners for the given event type.\n   * If no even type is provided, returns all listeners.\n   */\n  listeners(type) {\n    if (type == null) {\n      return Object.values(_classPrivateFieldGet(_listeners, this)).flat();\n    }\n    return _classPrivateFieldGet(_listeners, this)[type] || [];\n  }\n  /**\n   * Returns the number of listeners for the given event type.\n   * If no even type is provided, returns the total number of listeners.\n   */\n  listenerCount(type) {\n    return this.listeners(type).length;\n  }\n});\n\n// src/browser/utils/workerChannel.ts\nfunction _addListener(type, listener, options) {\n  var _classPrivateFieldGet2, _classPrivateFieldGet3;\n  let insertMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"append\";\n  (_classPrivateFieldGet3 = (_classPrivateFieldGet2 = _classPrivateFieldGet(_listeners, this))[type]) !== null && _classPrivateFieldGet3 !== void 0 ? _classPrivateFieldGet3 : _classPrivateFieldGet2[type] = [];\n  if (insertMode === \"prepend\") {\n    _classPrivateFieldGet(_listeners, this)[type].unshift(listener);\n  } else {\n    _classPrivateFieldGet(_listeners, this)[type].push(listener);\n  }\n  if (options) {\n    Object.defineProperty(listener, kListenerOptions, {\n      value: options,\n      enumerable: false,\n      writable: false\n    });\n    if (options.signal) {\n      options.signal.addEventListener(\"abort\", () => {\n        this.removeListener(type, listener);\n      }, {\n        once: true\n      });\n    }\n  }\n  return this;\n}\nfunction _proxyEvent(event) {\n  const {\n    stopPropagation\n  } = event;\n  event.stopPropagation = new Proxy(event.stopPropagation, {\n    apply: (target, thisArg, argArray) => {\n      event[kPropagationStopped] = this;\n      return Reflect.apply(target, thisArg, argArray);\n    }\n  });\n  return {\n    event,\n    revoke() {\n      event.stopPropagation = stopPropagation;\n    }\n  };\n}\nfunction _callListener(event, listener) {\n  var _listener$kListenerOp;\n  const returnValue = listener.call(this, event);\n  if ((_listener$kListenerOp = listener[kListenerOptions]) !== null && _listener$kListenerOp !== void 0 && _listener$kListenerOp.once) {\n    this.removeListener(event.type, listener);\n  }\n  return returnValue;\n}\nimport { isObject } from '../core/utils/internal/isObject.mjs';\nvar WorkerEvent = (_workerEvent = /*#__PURE__*/new WeakMap(), class WorkerEvent extends TypedEvent {\n  constructor(workerEvent) {\n    const type = workerEvent.data.type;\n    const data = workerEvent.data.payload;\n    super(\n    // @ts-expect-error Troublesome `TypedEvent` extension.\n    type, {\n      data\n    });\n    _classPrivateFieldInitSpec(this, _workerEvent, void 0);\n    _classPrivateFieldSet(_workerEvent, this, workerEvent);\n  }\n  get ports() {\n    return _classPrivateFieldGet(_workerEvent, this).ports;\n  }\n  /**\n   * Reply directly to this event using its `MessagePort`.\n   */\n  postMessage(type) {\n    _classPrivateFieldGet(_workerEvent, this).ports[0].postMessage({\n      type,\n      data: arguments.length <= 1 ? undefined : arguments[1]\n    }, {\n      transfer: arguments.length <= 2 ? undefined : arguments[2]\n    });\n  }\n});\nvar WorkerChannel = class extends Emitter2 {\n  constructor(options) {\n    super();\n    this.options = options;\n    navigator.serviceWorker.addEventListener(\"message\", async event => {\n      const worker = await this.options.worker;\n      if (event.source != null && event.source !== worker) {\n        return;\n      }\n      if (event.data && isObject(event.data) && \"type\" in event.data) {\n        this.emit(new WorkerEvent(event));\n      }\n    });\n  }\n  /**\n   * Send data to the Service Worker controlling this client.\n   * This triggers the `message` event listener on ServiceWorkerGlobalScope.\n   */\n  postMessage(type) {\n    this.options.worker.then(worker => {\n      worker.postMessage(type);\n    });\n  }\n};\n\n// node_modules/.pnpm/@mswjs+interceptors@0.39.1/node_modules/@mswjs/interceptors/lib/browser/chunk-L37TY7LC.mjs\nvar InterceptorError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"InterceptorError\";\n    Object.setPrototypeOf(this, InterceptorError.prototype);\n  }\n};\nvar kRequestHandled = Symbol(\"kRequestHandled\");\nvar kResponsePromise = Symbol(\"kResponsePromise\");\nvar RequestController = class {\n  constructor(request) {\n    this.request = request;\n    this[kRequestHandled] = false;\n    this[kResponsePromise] = new DeferredPromise();\n  }\n  /**\n   * Respond to this request with the given `Response` instance.\n   * @example\n   * controller.respondWith(new Response())\n   * controller.respondWith(Response.json({ id }))\n   * controller.respondWith(Response.error())\n   */\n  respondWith(response) {\n    invariant.as(InterceptorError, !this[kRequestHandled], 'Failed to respond to the \"%s %s\" request: the \"request\" event has already been handled.', this.request.method, this.request.url);\n    this[kRequestHandled] = true;\n    this[kResponsePromise].resolve(response);\n  }\n  /**\n   * Error this request with the given reason.\n   *\n   * @example\n   * controller.errorWith()\n   * controller.errorWith(new Error('Oops!'))\n   * controller.errorWith({ message: 'Oops!'})\n   */\n  errorWith(reason) {\n    invariant.as(InterceptorError, !this[kRequestHandled], 'Failed to error the \"%s %s\" request: the \"request\" event has already been handled.', this.request.method, this.request.url);\n    this[kRequestHandled] = true;\n    this[kResponsePromise].resolve(reason);\n  }\n};\nasync function emitAsync(emitter, eventName) {\n  const listners = emitter.listeners(eventName);\n  if (listners.length === 0) {\n    return;\n  }\n  for (var _len14 = arguments.length, data = new Array(_len14 > 2 ? _len14 - 2 : 0), _key14 = 2; _key14 < _len14; _key14++) {\n    data[_key14 - 2] = arguments[_key14];\n  }\n  for (const listener of listners) {\n    await listener.apply(emitter, data);\n  }\n}\nfunction isObject2(value) {\n  let loose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return loose ? Object.prototype.toString.call(value).startsWith(\"[object \") : Object.prototype.toString.call(value) === \"[object Object]\";\n}\nfunction isPropertyAccessible(obj, key) {\n  try {\n    obj[key];\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction createServerErrorResponse(body) {\n  return new Response(JSON.stringify(body instanceof Error ? {\n    name: body.name,\n    message: body.message,\n    stack: body.stack\n  } : body), {\n    status: 500,\n    statusText: \"Unhandled Exception\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  });\n}\nfunction isResponseError(response) {\n  return response != null && response instanceof Response && isPropertyAccessible(response, \"type\") && response.type === \"error\";\n}\nfunction isResponseLike(value) {\n  return isObject2(value, true) && isPropertyAccessible(value, \"status\") && isPropertyAccessible(value, \"statusText\") && isPropertyAccessible(value, \"bodyUsed\");\n}\nfunction isNodeLikeError(error2) {\n  if (error2 == null) {\n    return false;\n  }\n  if (!(error2 instanceof Error)) {\n    return false;\n  }\n  return \"code\" in error2 && \"errno\" in error2;\n}\nasync function handleRequest2(options) {\n  const handleResponse = async response => {\n    if (response instanceof Error) {\n      options.onError(response);\n      return true;\n    }\n    if (isResponseError(response)) {\n      options.onRequestError(response);\n      return true;\n    }\n    if (isResponseLike(response)) {\n      await options.onResponse(response);\n      return true;\n    }\n    if (isObject2(response)) {\n      options.onError(response);\n      return true;\n    }\n    return false;\n  };\n  const handleResponseError = async error2 => {\n    if (error2 instanceof InterceptorError) {\n      throw result.error;\n    }\n    if (isNodeLikeError(error2)) {\n      options.onError(error2);\n      return true;\n    }\n    if (error2 instanceof Response) {\n      return await handleResponse(error2);\n    }\n    return false;\n  };\n  options.emitter.once(\"request\", _ref2 => {\n    let {\n      requestId: pendingRequestId\n    } = _ref2;\n    if (pendingRequestId !== options.requestId) {\n      return;\n    }\n    if (options.controller[kResponsePromise].state === \"pending\") {\n      options.controller[kResponsePromise].resolve(void 0);\n    }\n  });\n  const requestAbortPromise = new DeferredPromise();\n  if (options.request.signal) {\n    if (options.request.signal.aborted) {\n      requestAbortPromise.reject(options.request.signal.reason);\n    } else {\n      options.request.signal.addEventListener(\"abort\", () => {\n        requestAbortPromise.reject(options.request.signal.reason);\n      }, {\n        once: true\n      });\n    }\n  }\n  const result = await until(async () => {\n    const requestListenersPromise = emitAsync(options.emitter, \"request\", {\n      requestId: options.requestId,\n      request: options.request,\n      controller: options.controller\n    });\n    await Promise.race([\n    // Short-circuit the request handling promise if the request gets aborted.\n    requestAbortPromise, requestListenersPromise, options.controller[kResponsePromise]]);\n    return await options.controller[kResponsePromise];\n  });\n  if (requestAbortPromise.state === \"rejected\") {\n    options.onError(requestAbortPromise.rejectionReason);\n    return true;\n  }\n  if (result.error) {\n    if (await handleResponseError(result.error)) {\n      return true;\n    }\n    if (options.emitter.listenerCount(\"unhandledException\") > 0) {\n      const unhandledExceptionController = new RequestController(options.request);\n      await emitAsync(options.emitter, \"unhandledException\", {\n        error: result.error,\n        request: options.request,\n        requestId: options.requestId,\n        controller: unhandledExceptionController\n      }).then(() => {\n        if (unhandledExceptionController[kResponsePromise].state === \"pending\") {\n          unhandledExceptionController[kResponsePromise].resolve(void 0);\n        }\n      });\n      const nextResult = await until(() => unhandledExceptionController[kResponsePromise]);\n      if (nextResult.error) {\n        return handleResponseError(nextResult.error);\n      }\n      if (nextResult.data) {\n        return handleResponse(nextResult.data);\n      }\n    }\n    options.onResponse(createServerErrorResponse(result.error));\n    return true;\n  }\n  if (result.data) {\n    return handleResponse(result.data);\n  }\n  return false;\n}\n\n// node_modules/.pnpm/@mswjs+interceptors@0.39.1/node_modules/@mswjs/interceptors/lib/browser/chunk-TX5GBTFY.mjs\nfunction hasConfigurableGlobal(propertyName) {\n  const descriptor = Object.getOwnPropertyDescriptor(globalThis, propertyName);\n  if (typeof descriptor === \"undefined\") {\n    return false;\n  }\n  if (typeof descriptor.get === \"function\" && typeof descriptor.get() === \"undefined\") {\n    return false;\n  }\n  if (typeof descriptor.get === \"undefined\" && descriptor.value == null) {\n    return false;\n  }\n  if (typeof descriptor.set === \"undefined\" && !descriptor.configurable) {\n    console.error(\"[MSW] Failed to apply interceptor: the global `\".concat(propertyName, \"` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.\"));\n    return false;\n  }\n  return true;\n}\n\n// node_modules/.pnpm/@mswjs+interceptors@0.39.1/node_modules/@mswjs/interceptors/lib/browser/chunk-ARPHZXGT.mjs\nfunction createNetworkError(cause) {\n  return Object.assign(new TypeError(\"Failed to fetch\"), {\n    cause\n  });\n}\nvar REQUEST_BODY_HEADERS = [\"content-encoding\", \"content-language\", \"content-location\", \"content-type\", \"content-length\"];\nvar kRedirectCount = Symbol(\"kRedirectCount\");\nasync function followFetchRedirect(request, response) {\n  if (response.status !== 303 && request.body != null) {\n    return Promise.reject(createNetworkError());\n  }\n  const requestUrl = new URL(request.url);\n  let locationUrl;\n  try {\n    locationUrl = new URL(response.headers.get(\"location\"), request.url);\n  } catch (error2) {\n    return Promise.reject(createNetworkError(error2));\n  }\n  if (!(locationUrl.protocol === \"http:\" || locationUrl.protocol === \"https:\")) {\n    return Promise.reject(createNetworkError(\"URL scheme must be a HTTP(S) scheme\"));\n  }\n  if (Reflect.get(request, kRedirectCount) > 20) {\n    return Promise.reject(createNetworkError(\"redirect count exceeded\"));\n  }\n  Object.defineProperty(request, kRedirectCount, {\n    value: (Reflect.get(request, kRedirectCount) || 0) + 1\n  });\n  if (request.mode === \"cors\" && (locationUrl.username || locationUrl.password) && !sameOrigin(requestUrl, locationUrl)) {\n    return Promise.reject(createNetworkError('cross origin not allowed for request mode \"cors\"'));\n  }\n  const requestInit = {};\n  if ([301, 302].includes(response.status) && request.method === \"POST\" || response.status === 303 && ![\"HEAD\", \"GET\"].includes(request.method)) {\n    requestInit.method = \"GET\";\n    requestInit.body = null;\n    REQUEST_BODY_HEADERS.forEach(headerName => {\n      request.headers.delete(headerName);\n    });\n  }\n  if (!sameOrigin(requestUrl, locationUrl)) {\n    request.headers.delete(\"authorization\");\n    request.headers.delete(\"proxy-authorization\");\n    request.headers.delete(\"cookie\");\n    request.headers.delete(\"host\");\n  }\n  requestInit.headers = request.headers;\n  return fetch(new Request(locationUrl, requestInit));\n}\nfunction sameOrigin(left, right) {\n  if (left.origin === right.origin && left.origin === \"null\") {\n    return true;\n  }\n  if (left.protocol === right.protocol && left.hostname === right.hostname && left.port === right.port) {\n    return true;\n  }\n  return false;\n}\nvar BrotliDecompressionStream = class extends TransformStream {\n  constructor() {\n    console.warn(\"[Interceptors]: Brotli decompression of response streams is not supported in the browser\");\n    super({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      }\n    });\n  }\n};\nvar PipelineStream = class extends TransformStream {\n  constructor(transformStreams) {\n    for (var _len15 = arguments.length, strategies = new Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {\n      strategies[_key15 - 1] = arguments[_key15];\n    }\n    super({}, ...strategies);\n    const readable = [super.readable, ...transformStreams].reduce((readable2, transform) => readable2.pipeThrough(transform));\n    Object.defineProperty(this, \"readable\", {\n      get() {\n        return readable;\n      }\n    });\n  }\n};\nfunction parseContentEncoding(contentEncoding) {\n  return contentEncoding.toLowerCase().split(\",\").map(coding => coding.trim());\n}\nfunction createDecompressionStream(contentEncoding) {\n  if (contentEncoding === \"\") {\n    return null;\n  }\n  const codings = parseContentEncoding(contentEncoding);\n  if (codings.length === 0) {\n    return null;\n  }\n  const transformers = codings.reduceRight((transformers2, coding) => {\n    if (coding === \"gzip\" || coding === \"x-gzip\") {\n      return transformers2.concat(new DecompressionStream(\"gzip\"));\n    } else if (coding === \"deflate\") {\n      return transformers2.concat(new DecompressionStream(\"deflate\"));\n    } else if (coding === \"br\") {\n      return transformers2.concat(new BrotliDecompressionStream());\n    } else {\n      transformers2.length = 0;\n    }\n    return transformers2;\n  }, []);\n  return new PipelineStream(transformers);\n}\nfunction decompressResponse(response) {\n  if (response.body === null) {\n    return null;\n  }\n  const decompressionStream = createDecompressionStream(response.headers.get(\"content-encoding\") || \"\");\n  if (!decompressionStream) {\n    return null;\n  }\n  response.body.pipeTo(decompressionStream.writable);\n  return decompressionStream.readable;\n}\nvar _FetchInterceptor = class extends Interceptor {\n  constructor() {\n    super(_FetchInterceptor.symbol);\n  }\n  checkEnvironment() {\n    return hasConfigurableGlobal(\"fetch\");\n  }\n  async setup() {\n    const pureFetch = globalThis.fetch;\n    invariant(!pureFetch[IS_PATCHED_MODULE], 'Failed to patch the \"fetch\" module: already patched.');\n    globalThis.fetch = async (input, init) => {\n      const requestId = createRequestId();\n      const resolvedInput = typeof input === \"string\" && typeof location !== \"undefined\" && !canParseUrl(input) ? new URL(input, location.href) : input;\n      const request = new Request(resolvedInput, init);\n      if (input instanceof Request) {\n        setRawRequest(request, input);\n      }\n      const responsePromise = new DeferredPromise();\n      const controller = new RequestController(request);\n      this.logger.info(\"[%s] %s\", request.method, request.url);\n      this.logger.info(\"awaiting for the mocked response...\");\n      this.logger.info('emitting the \"request\" event for %s listener(s)...', this.emitter.listenerCount(\"request\"));\n      const isRequestHandled = await handleRequest2({\n        request,\n        requestId,\n        emitter: this.emitter,\n        controller,\n        onResponse: async rawResponse => {\n          this.logger.info(\"received mocked response!\", {\n            rawResponse\n          });\n          const decompressedStream = decompressResponse(rawResponse);\n          const response = decompressedStream === null ? rawResponse : new FetchResponse(decompressedStream, rawResponse);\n          FetchResponse.setUrl(request.url, response);\n          if (FetchResponse.isRedirectResponse(response.status)) {\n            if (request.redirect === \"error\") {\n              responsePromise.reject(createNetworkError(\"unexpected redirect\"));\n              return;\n            }\n            if (request.redirect === \"follow\") {\n              followFetchRedirect(request, response).then(response2 => {\n                responsePromise.resolve(response2);\n              }, reason => {\n                responsePromise.reject(reason);\n              });\n              return;\n            }\n          }\n          if (this.emitter.listenerCount(\"response\") > 0) {\n            this.logger.info('emitting the \"response\" event...');\n            await emitAsync(this.emitter, \"response\", {\n              // Clone the mocked response for the \"response\" event listener.\n              // This way, the listener can read the response and not lock its body\n              // for the actual fetch consumer.\n              response: response.clone(),\n              isMockedResponse: true,\n              request,\n              requestId\n            });\n          }\n          responsePromise.resolve(response);\n        },\n        onRequestError: response => {\n          this.logger.info(\"request has errored!\", {\n            response\n          });\n          responsePromise.reject(createNetworkError(response));\n        },\n        onError: error2 => {\n          this.logger.info(\"request has been aborted!\", {\n            error: error2\n          });\n          responsePromise.reject(error2);\n        }\n      });\n      if (isRequestHandled) {\n        this.logger.info(\"request has been handled, returning mock promise...\");\n        return responsePromise;\n      }\n      this.logger.info(\"no mocked response received, performing request as-is...\");\n      const requestCloneForResponseEvent = request.clone();\n      return pureFetch(request).then(async response => {\n        this.logger.info(\"original fetch performed\", response);\n        if (this.emitter.listenerCount(\"response\") > 0) {\n          this.logger.info('emitting the \"response\" event...');\n          const responseClone = response.clone();\n          await emitAsync(this.emitter, \"response\", {\n            response: responseClone,\n            isMockedResponse: false,\n            request: requestCloneForResponseEvent,\n            requestId\n          });\n        }\n        return response;\n      });\n    };\n    Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true\n    });\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n        value: void 0\n      });\n      globalThis.fetch = pureFetch;\n      this.logger.info('restored native \"globalThis.fetch\"!', globalThis.fetch.name);\n    });\n  }\n};\nvar FetchInterceptor = _FetchInterceptor;\nFetchInterceptor.symbol = Symbol(\"fetch\");\n\n// node_modules/.pnpm/@mswjs+interceptors@0.39.1/node_modules/@mswjs/interceptors/lib/browser/chunk-QKSBFQDK.mjs\nfunction concatArrayBuffer(left, right) {\n  const result = new Uint8Array(left.byteLength + right.byteLength);\n  result.set(left, 0);\n  result.set(right, left.byteLength);\n  return result;\n}\nvar EventPolyfill = class {\n  constructor(type, options) {\n    this.NONE = 0;\n    this.CAPTURING_PHASE = 1;\n    this.AT_TARGET = 2;\n    this.BUBBLING_PHASE = 3;\n    this.type = \"\";\n    this.srcElement = null;\n    this.currentTarget = null;\n    this.eventPhase = 0;\n    this.isTrusted = true;\n    this.composed = false;\n    this.cancelable = true;\n    this.defaultPrevented = false;\n    this.bubbles = true;\n    this.lengthComputable = true;\n    this.loaded = 0;\n    this.total = 0;\n    this.cancelBubble = false;\n    this.returnValue = true;\n    this.type = type;\n    this.target = (options == null ? void 0 : options.target) || null;\n    this.currentTarget = (options == null ? void 0 : options.currentTarget) || null;\n    this.timeStamp = Date.now();\n  }\n  composedPath() {\n    return [];\n  }\n  initEvent(type, bubbles, cancelable) {\n    this.type = type;\n    this.bubbles = !!bubbles;\n    this.cancelable = !!cancelable;\n  }\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n  stopPropagation() {}\n  stopImmediatePropagation() {}\n};\nvar ProgressEventPolyfill = class extends EventPolyfill {\n  constructor(type, init) {\n    super(type);\n    this.lengthComputable = (init == null ? void 0 : init.lengthComputable) || false;\n    this.composed = (init == null ? void 0 : init.composed) || false;\n    this.loaded = (init == null ? void 0 : init.loaded) || 0;\n    this.total = (init == null ? void 0 : init.total) || 0;\n  }\n};\nvar SUPPORTS_PROGRESS_EVENT = typeof ProgressEvent !== \"undefined\";\nfunction createEvent(target, type, init) {\n  const progressEvents = [\"error\", \"progress\", \"loadstart\", \"loadend\", \"load\", \"timeout\", \"abort\"];\n  const ProgressEventClass = SUPPORTS_PROGRESS_EVENT ? ProgressEvent : ProgressEventPolyfill;\n  const event = progressEvents.includes(type) ? new ProgressEventClass(type, {\n    lengthComputable: true,\n    loaded: (init == null ? void 0 : init.loaded) || 0,\n    total: (init == null ? void 0 : init.total) || 0\n  }) : new EventPolyfill(type, {\n    target,\n    currentTarget: target\n  });\n  return event;\n}\nfunction findPropertySource(target, propertyName) {\n  if (!(propertyName in target)) {\n    return null;\n  }\n  const hasProperty = Object.prototype.hasOwnProperty.call(target, propertyName);\n  if (hasProperty) {\n    return target;\n  }\n  const prototype = Reflect.getPrototypeOf(target);\n  return prototype ? findPropertySource(prototype, propertyName) : null;\n}\nfunction createProxy(target, options) {\n  const proxy = new Proxy(target, optionsToProxyHandler(options));\n  return proxy;\n}\nfunction optionsToProxyHandler(options) {\n  const {\n    constructorCall,\n    methodCall,\n    getProperty,\n    setProperty\n  } = options;\n  const handler = {};\n  if (typeof constructorCall !== \"undefined\") {\n    handler.construct = function (target, args, newTarget) {\n      const next = Reflect.construct.bind(null, target, args, newTarget);\n      return constructorCall.call(newTarget, args, next);\n    };\n  }\n  handler.set = function (target, propertyName, nextValue) {\n    const next = () => {\n      const propertySource = findPropertySource(target, propertyName) || target;\n      const ownDescriptors = Reflect.getOwnPropertyDescriptor(propertySource, propertyName);\n      if (typeof (ownDescriptors == null ? void 0 : ownDescriptors.set) !== \"undefined\") {\n        ownDescriptors.set.apply(target, [nextValue]);\n        return true;\n      }\n      return Reflect.defineProperty(propertySource, propertyName, {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: nextValue\n      });\n    };\n    if (typeof setProperty !== \"undefined\") {\n      return setProperty.call(target, [propertyName, nextValue], next);\n    }\n    return next();\n  };\n  handler.get = function (target, propertyName, receiver) {\n    const next = () => target[propertyName];\n    const value = typeof getProperty !== \"undefined\" ? getProperty.call(target, [propertyName, receiver], next) : next();\n    if (typeof value === \"function\") {\n      return function () {\n        for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n          args[_key16] = arguments[_key16];\n        }\n        const next2 = value.bind(target, ...args);\n        if (typeof methodCall !== \"undefined\") {\n          return methodCall.call(target, [propertyName, args], next2);\n        }\n        return next2();\n      };\n    }\n    return value;\n  };\n  return handler;\n}\nfunction isDomParserSupportedType(type) {\n  const supportedTypes = [\"application/xhtml+xml\", \"application/xml\", \"image/svg+xml\", \"text/html\", \"text/xml\"];\n  return supportedTypes.some(supportedType => {\n    return type.startsWith(supportedType);\n  });\n}\nfunction parseJson(data) {\n  try {\n    const json = JSON.parse(data);\n    return json;\n  } catch (_) {\n    return null;\n  }\n}\nfunction createResponse(request, body) {\n  const responseBodyOrNull = FetchResponse.isResponseWithBody(request.status) ? body : null;\n  return new FetchResponse(responseBodyOrNull, {\n    url: request.responseURL,\n    status: request.status,\n    statusText: request.statusText,\n    headers: createHeadersFromXMLHttpReqestHeaders(request.getAllResponseHeaders())\n  });\n}\nfunction createHeadersFromXMLHttpReqestHeaders(headersString) {\n  const headers = new Headers();\n  const lines = headersString.split(/[\\r\\n]+/);\n  for (const line of lines) {\n    if (line.trim() === \"\") {\n      continue;\n    }\n    const [name, ...parts] = line.split(\": \");\n    const value = parts.join(\": \");\n    headers.append(name, value);\n  }\n  return headers;\n}\nasync function getBodyByteLength(input) {\n  const explicitContentLength = input.headers.get(\"content-length\");\n  if (explicitContentLength != null && explicitContentLength !== \"\") {\n    return Number(explicitContentLength);\n  }\n  const buffer = await input.arrayBuffer();\n  return buffer.byteLength;\n}\nvar kIsRequestHandled = Symbol(\"kIsRequestHandled\");\nvar IS_NODE2 = isNodeProcess();\nvar kFetchRequest = Symbol(\"kFetchRequest\");\nvar XMLHttpRequestController = class {\n  constructor(initialRequest, logger) {\n    this.initialRequest = initialRequest;\n    this.logger = logger;\n    this.method = \"GET\";\n    this.url = null;\n    this[kIsRequestHandled] = false;\n    this.events = /* @__PURE__ */new Map();\n    this.uploadEvents = /* @__PURE__ */new Map();\n    this.requestId = createRequestId();\n    this.requestHeaders = new Headers();\n    this.responseBuffer = new Uint8Array();\n    this.request = createProxy(initialRequest, {\n      setProperty: (_ref3, invoke) => {\n        let [propertyName, nextValue] = _ref3;\n        switch (propertyName) {\n          case \"ontimeout\":\n            {\n              const eventName = propertyName.slice(2);\n              this.request.addEventListener(eventName, nextValue);\n              return invoke();\n            }\n          default:\n            {\n              return invoke();\n            }\n        }\n      },\n      methodCall: (_ref4, invoke) => {\n        let [methodName, args] = _ref4;\n        var _a;\n        switch (methodName) {\n          case \"open\":\n            {\n              const [method, url] = args;\n              if (typeof url === \"undefined\") {\n                this.method = \"GET\";\n                this.url = toAbsoluteUrl(method);\n              } else {\n                this.method = method;\n                this.url = toAbsoluteUrl(url);\n              }\n              this.logger = this.logger.extend(\"\".concat(this.method, \" \").concat(this.url.href));\n              this.logger.info(\"open\", this.method, this.url.href);\n              return invoke();\n            }\n          case \"addEventListener\":\n            {\n              const [eventName, listener] = args;\n              this.registerEvent(eventName, listener);\n              this.logger.info(\"addEventListener\", eventName, listener);\n              return invoke();\n            }\n          case \"setRequestHeader\":\n            {\n              const [name, value] = args;\n              this.requestHeaders.set(name, value);\n              this.logger.info(\"setRequestHeader\", name, value);\n              return invoke();\n            }\n          case \"send\":\n            {\n              const [body] = args;\n              this.request.addEventListener(\"load\", () => {\n                if (typeof this.onResponse !== \"undefined\") {\n                  const fetchResponse = createResponse(this.request,\n                  /**\n                   * The `response` property is the right way to read\n                   * the ambiguous response body, as the request's \"responseType\" may differ.\n                   * @see https://xhr.spec.whatwg.org/#the-response-attribute\n                   */\n                  this.request.response);\n                  this.onResponse.call(this, {\n                    response: fetchResponse,\n                    isMockedResponse: this[kIsRequestHandled],\n                    request: fetchRequest,\n                    requestId: this.requestId\n                  });\n                }\n              });\n              const requestBody = typeof body === \"string\" ? encodeBuffer(body) : body;\n              const fetchRequest = this.toFetchApiRequest(requestBody);\n              this[kFetchRequest] = fetchRequest.clone();\n              const onceRequestSettled = ((_a = this.onRequest) == null ? void 0 : _a.call(this, {\n                request: fetchRequest,\n                requestId: this.requestId\n              })) || Promise.resolve();\n              onceRequestSettled.finally(() => {\n                if (!this[kIsRequestHandled]) {\n                  this.logger.info(\"request callback settled but request has not been handled (readystate %d), performing as-is...\", this.request.readyState);\n                  if (IS_NODE2) {\n                    this.request.setRequestHeader(INTERNAL_REQUEST_ID_HEADER_NAME, this.requestId);\n                  }\n                  return invoke();\n                }\n              });\n              break;\n            }\n          default:\n            {\n              return invoke();\n            }\n        }\n      }\n    });\n    define(this.request, \"upload\", createProxy(this.request.upload, {\n      setProperty: (_ref5, invoke) => {\n        let [propertyName, nextValue] = _ref5;\n        switch (propertyName) {\n          case \"onloadstart\":\n          case \"onprogress\":\n          case \"onaboart\":\n          case \"onerror\":\n          case \"onload\":\n          case \"ontimeout\":\n          case \"onloadend\":\n            {\n              const eventName = propertyName.slice(2);\n              this.registerUploadEvent(eventName, nextValue);\n            }\n        }\n        return invoke();\n      },\n      methodCall: (_ref6, invoke) => {\n        let [methodName, args] = _ref6;\n        switch (methodName) {\n          case \"addEventListener\":\n            {\n              const [eventName, listener] = args;\n              this.registerUploadEvent(eventName, listener);\n              this.logger.info(\"upload.addEventListener\", eventName, listener);\n              return invoke();\n            }\n        }\n      }\n    }));\n  }\n  registerEvent(eventName, listener) {\n    const prevEvents = this.events.get(eventName) || [];\n    const nextEvents = prevEvents.concat(listener);\n    this.events.set(eventName, nextEvents);\n    this.logger.info('registered event \"%s\"', eventName, listener);\n  }\n  registerUploadEvent(eventName, listener) {\n    const prevEvents = this.uploadEvents.get(eventName) || [];\n    const nextEvents = prevEvents.concat(listener);\n    this.uploadEvents.set(eventName, nextEvents);\n    this.logger.info('registered upload event \"%s\"', eventName, listener);\n  }\n  /**\n   * Responds to the current request with the given\n   * Fetch API `Response` instance.\n   */\n  async respondWith(response) {\n    this[kIsRequestHandled] = true;\n    if (this[kFetchRequest]) {\n      const totalRequestBodyLength = await getBodyByteLength(this[kFetchRequest]);\n      this.trigger(\"loadstart\", this.request.upload, {\n        loaded: 0,\n        total: totalRequestBodyLength\n      });\n      this.trigger(\"progress\", this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength\n      });\n      this.trigger(\"load\", this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength\n      });\n      this.trigger(\"loadend\", this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength\n      });\n    }\n    this.logger.info(\"responding with a mocked response: %d %s\", response.status, response.statusText);\n    define(this.request, \"status\", response.status);\n    define(this.request, \"statusText\", response.statusText);\n    define(this.request, \"responseURL\", this.url.href);\n    this.request.getResponseHeader = new Proxy(this.request.getResponseHeader, {\n      apply: (_, __, args) => {\n        this.logger.info(\"getResponseHeader\", args[0]);\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info(\"headers not received yet, returning null\");\n          return null;\n        }\n        const headerValue = response.headers.get(args[0]);\n        this.logger.info('resolved response header \"%s\" to', args[0], headerValue);\n        return headerValue;\n      }\n    });\n    this.request.getAllResponseHeaders = new Proxy(this.request.getAllResponseHeaders, {\n      apply: () => {\n        this.logger.info(\"getAllResponseHeaders\");\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info(\"headers not received yet, returning empty string\");\n          return \"\";\n        }\n        const headersList = Array.from(response.headers.entries());\n        const allHeaders = headersList.map(_ref7 => {\n          let [headerName, headerValue] = _ref7;\n          return \"\".concat(headerName, \": \").concat(headerValue);\n        }).join(\"\\r\\n\");\n        this.logger.info(\"resolved all response headers to\", allHeaders);\n        return allHeaders;\n      }\n    });\n    Object.defineProperties(this.request, {\n      response: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.response\n      },\n      responseText: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseText\n      },\n      responseXML: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseXML\n      }\n    });\n    const totalResponseBodyLength = await getBodyByteLength(response.clone());\n    this.logger.info(\"calculated response body length\", totalResponseBodyLength);\n    this.trigger(\"loadstart\", this.request, {\n      loaded: 0,\n      total: totalResponseBodyLength\n    });\n    this.setReadyState(this.request.HEADERS_RECEIVED);\n    this.setReadyState(this.request.LOADING);\n    const finalizeResponse = () => {\n      this.logger.info(\"finalizing the mocked response...\");\n      this.setReadyState(this.request.DONE);\n      this.trigger(\"load\", this.request, {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength\n      });\n      this.trigger(\"loadend\", this.request, {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength\n      });\n    };\n    if (response.body) {\n      this.logger.info(\"mocked response has body, streaming...\");\n      const reader = response.body.getReader();\n      const readNextResponseBodyChunk = async () => {\n        const {\n          value,\n          done\n        } = await reader.read();\n        if (done) {\n          this.logger.info(\"response body stream done!\");\n          finalizeResponse();\n          return;\n        }\n        if (value) {\n          this.logger.info(\"read response body chunk:\", value);\n          this.responseBuffer = concatArrayBuffer(this.responseBuffer, value);\n          this.trigger(\"progress\", this.request, {\n            loaded: this.responseBuffer.byteLength,\n            total: totalResponseBodyLength\n          });\n        }\n        readNextResponseBodyChunk();\n      };\n      readNextResponseBodyChunk();\n    } else {\n      finalizeResponse();\n    }\n  }\n  responseBufferToText() {\n    return decodeBuffer(this.responseBuffer);\n  }\n  get response() {\n    this.logger.info(\"getResponse (responseType: %s)\", this.request.responseType);\n    if (this.request.readyState !== this.request.DONE) {\n      return null;\n    }\n    switch (this.request.responseType) {\n      case \"json\":\n        {\n          const responseJson = parseJson(this.responseBufferToText());\n          this.logger.info(\"resolved response JSON\", responseJson);\n          return responseJson;\n        }\n      case \"arraybuffer\":\n        {\n          const arrayBuffer = toArrayBuffer(this.responseBuffer);\n          this.logger.info(\"resolved response ArrayBuffer\", arrayBuffer);\n          return arrayBuffer;\n        }\n      case \"blob\":\n        {\n          const mimeType = this.request.getResponseHeader(\"Content-Type\") || \"text/plain\";\n          const responseBlob = new Blob([this.responseBufferToText()], {\n            type: mimeType\n          });\n          this.logger.info(\"resolved response Blob (mime type: %s)\", responseBlob, mimeType);\n          return responseBlob;\n        }\n      default:\n        {\n          const responseText = this.responseBufferToText();\n          this.logger.info('resolving \"%s\" response type as text', this.request.responseType, responseText);\n          return responseText;\n        }\n    }\n  }\n  get responseText() {\n    invariant(this.request.responseType === \"\" || this.request.responseType === \"text\", \"InvalidStateError: The object is in invalid state.\");\n    if (this.request.readyState !== this.request.LOADING && this.request.readyState !== this.request.DONE) {\n      return \"\";\n    }\n    const responseText = this.responseBufferToText();\n    this.logger.info('getResponseText: \"%s\"', responseText);\n    return responseText;\n  }\n  get responseXML() {\n    invariant(this.request.responseType === \"\" || this.request.responseType === \"document\", \"InvalidStateError: The object is in invalid state.\");\n    if (this.request.readyState !== this.request.DONE) {\n      return null;\n    }\n    const contentType = this.request.getResponseHeader(\"Content-Type\") || \"\";\n    if (typeof DOMParser === \"undefined\") {\n      console.warn(\"Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly.\");\n      return null;\n    }\n    if (isDomParserSupportedType(contentType)) {\n      return new DOMParser().parseFromString(this.responseBufferToText(), contentType);\n    }\n    return null;\n  }\n  errorWith(error2) {\n    this[kIsRequestHandled] = true;\n    this.logger.info(\"responding with an error\");\n    this.setReadyState(this.request.DONE);\n    this.trigger(\"error\", this.request);\n    this.trigger(\"loadend\", this.request);\n  }\n  /**\n   * Transitions this request's `readyState` to the given one.\n   */\n  setReadyState(nextReadyState) {\n    this.logger.info(\"setReadyState: %d -> %d\", this.request.readyState, nextReadyState);\n    if (this.request.readyState === nextReadyState) {\n      this.logger.info(\"ready state identical, skipping transition...\");\n      return;\n    }\n    define(this.request, \"readyState\", nextReadyState);\n    this.logger.info(\"set readyState to: %d\", nextReadyState);\n    if (nextReadyState !== this.request.UNSENT) {\n      this.logger.info('triggerring \"readystatechange\" event...');\n      this.trigger(\"readystatechange\", this.request);\n    }\n  }\n  /**\n   * Triggers given event on the `XMLHttpRequest` instance.\n   */\n  trigger(eventName, target, options) {\n    const callback = target[\"on\".concat(eventName)];\n    const event = createEvent(target, eventName, options);\n    this.logger.info('trigger \"%s\"', eventName, options || \"\");\n    if (typeof callback === \"function\") {\n      this.logger.info('found a direct \"%s\" callback, calling...', eventName);\n      callback.call(target, event);\n    }\n    const events = target instanceof XMLHttpRequestUpload ? this.uploadEvents : this.events;\n    for (const [registeredEventName, listeners] of events) {\n      if (registeredEventName === eventName) {\n        this.logger.info('found %d listener(s) for \"%s\" event, calling...', listeners.length, eventName);\n        listeners.forEach(listener => listener.call(target, event));\n      }\n    }\n  }\n  /**\n   * Converts this `XMLHttpRequest` instance into a Fetch API `Request` instance.\n   */\n  toFetchApiRequest(body) {\n    this.logger.info(\"converting request to a Fetch API Request...\");\n    const resolvedBody = body instanceof Document ? body.documentElement.innerText : body;\n    const fetchRequest = new Request(this.url.href, {\n      method: this.method,\n      headers: this.requestHeaders,\n      /**\n       * @see https://xhr.spec.whatwg.org/#cross-origin-credentials\n       */\n      credentials: this.request.withCredentials ? \"include\" : \"same-origin\",\n      body: [\"GET\", \"HEAD\"].includes(this.method.toUpperCase()) ? null : resolvedBody\n    });\n    const proxyHeaders = createProxy(fetchRequest.headers, {\n      methodCall: (_ref8, invoke) => {\n        let [methodName, args] = _ref8;\n        switch (methodName) {\n          case \"append\":\n          case \"set\":\n            {\n              const [headerName, headerValue] = args;\n              this.request.setRequestHeader(headerName, headerValue);\n              break;\n            }\n          case \"delete\":\n            {\n              const [headerName] = args;\n              console.warn(\"XMLHttpRequest: Cannot remove a \\\"\".concat(headerName, \"\\\" header from the Fetch API representation of the \\\"\").concat(fetchRequest.method, \" \").concat(fetchRequest.url, \"\\\" request. XMLHttpRequest headers cannot be removed.\"));\n              break;\n            }\n        }\n        return invoke();\n      }\n    });\n    define(fetchRequest, \"headers\", proxyHeaders);\n    setRawRequest(fetchRequest, this.request);\n    this.logger.info(\"converted request to a Fetch API Request!\", fetchRequest);\n    return fetchRequest;\n  }\n};\nfunction toAbsoluteUrl(url) {\n  if (typeof location === \"undefined\") {\n    return new URL(url);\n  }\n  return new URL(url.toString(), location.href);\n}\nfunction define(target, property, value) {\n  Reflect.defineProperty(target, property, {\n    // Ensure writable properties to allow redefining readonly properties.\n    writable: true,\n    enumerable: true,\n    value\n  });\n}\nfunction createXMLHttpRequestProxy(_ref9) {\n  let {\n    emitter,\n    logger\n  } = _ref9;\n  const XMLHttpRequestProxy = new Proxy(globalThis.XMLHttpRequest, {\n    construct(target, args, newTarget) {\n      logger.info(\"constructed new XMLHttpRequest\");\n      const originalRequest = Reflect.construct(target, args, newTarget);\n      const prototypeDescriptors = Object.getOwnPropertyDescriptors(target.prototype);\n      for (const propertyName in prototypeDescriptors) {\n        Reflect.defineProperty(originalRequest, propertyName, prototypeDescriptors[propertyName]);\n      }\n      const xhrRequestController = new XMLHttpRequestController(originalRequest, logger);\n      xhrRequestController.onRequest = async function (_ref0) {\n        let {\n          request,\n          requestId\n        } = _ref0;\n        const controller = new RequestController(request);\n        this.logger.info(\"awaiting mocked response...\");\n        this.logger.info('emitting the \"request\" event for %s listener(s)...', emitter.listenerCount(\"request\"));\n        const isRequestHandled = await handleRequest2({\n          request,\n          requestId,\n          controller,\n          emitter,\n          onResponse: async response => {\n            await this.respondWith(response);\n          },\n          onRequestError: () => {\n            this.errorWith(new TypeError(\"Network error\"));\n          },\n          onError: error2 => {\n            this.logger.info(\"request errored!\", {\n              error: error2\n            });\n            if (error2 instanceof Error) {\n              this.errorWith(error2);\n            }\n          }\n        });\n        if (!isRequestHandled) {\n          this.logger.info(\"no mocked response received, performing request as-is...\");\n        }\n      };\n      xhrRequestController.onResponse = async function (_ref1) {\n        let {\n          response,\n          isMockedResponse,\n          request,\n          requestId\n        } = _ref1;\n        this.logger.info('emitting the \"response\" event for %s listener(s)...', emitter.listenerCount(\"response\"));\n        emitter.emit(\"response\", {\n          response,\n          isMockedResponse,\n          request,\n          requestId\n        });\n      };\n      return xhrRequestController.request;\n    }\n  });\n  return XMLHttpRequestProxy;\n}\nvar _XMLHttpRequestInterceptor = class extends Interceptor {\n  constructor() {\n    super(_XMLHttpRequestInterceptor.interceptorSymbol);\n  }\n  checkEnvironment() {\n    return hasConfigurableGlobal(\"XMLHttpRequest\");\n  }\n  setup() {\n    const logger = this.logger.extend(\"setup\");\n    logger.info('patching \"XMLHttpRequest\" module...');\n    const PureXMLHttpRequest = globalThis.XMLHttpRequest;\n    invariant(!PureXMLHttpRequest[IS_PATCHED_MODULE], 'Failed to patch the \"XMLHttpRequest\" module: already patched.');\n    globalThis.XMLHttpRequest = createXMLHttpRequestProxy({\n      emitter: this.emitter,\n      logger: this.logger\n    });\n    logger.info('native \"XMLHttpRequest\" module patched!', globalThis.XMLHttpRequest.name);\n    Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true\n    });\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n        value: void 0\n      });\n      globalThis.XMLHttpRequest = PureXMLHttpRequest;\n      logger.info('native \"XMLHttpRequest\" module restored!', globalThis.XMLHttpRequest.name);\n    });\n  }\n};\nvar XMLHttpRequestInterceptor = _XMLHttpRequestInterceptor;\nXMLHttpRequestInterceptor.interceptorSymbol = Symbol(\"xhr\");\n\n// src/browser/setupWorker/start/createFallbackRequestListener.ts\nimport { handleRequest as handleRequest3 } from '../core/utils/handleRequest.mjs';\nimport { isHandlerKind as isHandlerKind2 } from '../core/utils/internal/isHandlerKind.mjs';\nfunction createFallbackRequestListener(context, options) {\n  const interceptor = new BatchInterceptor({\n    name: \"fallback\",\n    interceptors: [new FetchInterceptor(), new XMLHttpRequestInterceptor()]\n  });\n  interceptor.on(\"request\", async _ref10 => {\n    let {\n      request,\n      requestId,\n      controller\n    } = _ref10;\n    const requestCloneForLogs = request.clone();\n    const response = await handleRequest3(request, requestId, context.getRequestHandlers().filter(isHandlerKind2(\"RequestHandler\")), options, context.emitter, {\n      onMockedResponse(_, _ref11) {\n        let {\n          handler,\n          parsedResult\n        } = _ref11;\n        if (!options.quiet) {\n          context.emitter.once(\"response:mocked\", _ref12 => {\n            let {\n              response: response2\n            } = _ref12;\n            handler.log({\n              request: requestCloneForLogs,\n              response: response2,\n              parsedResult\n            });\n          });\n        }\n      }\n    });\n    if (response) {\n      controller.respondWith(response);\n    }\n  });\n  interceptor.on(\"response\", _ref13 => {\n    let {\n      response,\n      isMockedResponse,\n      request,\n      requestId\n    } = _ref13;\n    context.emitter.emit(isMockedResponse ? \"response:mocked\" : \"response:bypass\", {\n      response,\n      request,\n      requestId\n    });\n  });\n  interceptor.apply();\n  return interceptor;\n}\n\n// src/browser/setupWorker/stop/utils/printStopMessage.ts\nimport { devUtils as devUtils7 } from '../core/utils/internal/devUtils.mjs';\nfunction printStopMessage() {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (args.quiet) {\n    return;\n  }\n  console.log(\"%c\".concat(devUtils7.formatMessage(\"Mocking disabled.\")), \"color:orangered;font-weight:bold;\");\n}\n\n// src/browser/setupWorker/setupWorker.ts\nvar SetupWorkerApi = class SetupWorkerApi extends SetupApi {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"context\", void 0);\n    invariant(!isNodeProcess(), devUtils8.formatMessage(\"Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.\"));\n    this.context = this.createWorkerContext();\n  }\n  createWorkerContext() {\n    const workerPromise = new DeferredPromise();\n    return {\n      // Mocking is not considered enabled until the worker\n      // signals back the successful activation event.\n      isMockingEnabled: false,\n      startOptions: null,\n      workerPromise,\n      registration: void 0,\n      getRequestHandlers: () => {\n        return this.handlersController.currentHandlers();\n      },\n      emitter: this.emitter,\n      workerChannel: new WorkerChannel({\n        worker: workerPromise\n      }),\n      supports: {\n        serviceWorkerApi: \"serviceWorker\" in navigator && location.protocol !== \"file:\",\n        readableStreamTransfer: supportsReadableStreamTransfer()\n      }\n    };\n  }\n  async start() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (\"waitUntilReady\" in options) {\n      devUtils8.warn('The \"waitUntilReady\" option has been deprecated. Please remove it from this \"worker.start()\" call. Follow the recommended Browser integration (https://mswjs.io/docs/integrations/browser) to eliminate any race conditions between the Service Worker registration and any requests made by your application on initial render.');\n    }\n    if (this.context.isMockingEnabled) {\n      devUtils8.warn(\"Found a redundant \\\"worker.start()\\\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \\\"worker.start()\\\" call.\");\n      return this.context.registration;\n    }\n    this.context.workerStoppedAt = void 0;\n    this.context.startOptions = mergeRight2(DEFAULT_START_OPTIONS, options);\n    handleWebSocketEvent({\n      getUnhandledRequestStrategy: () => {\n        return this.context.startOptions.onUnhandledRequest;\n      },\n      getHandlers: () => {\n        return this.handlersController.currentHandlers();\n      },\n      onMockedConnection: connection => {\n        if (!this.context.startOptions.quiet) {\n          attachWebSocketLogger(connection);\n        }\n      },\n      onPassthroughConnection() {}\n    });\n    webSocketInterceptor.apply();\n    this.subscriptions.push(() => {\n      webSocketInterceptor.dispose();\n    });\n    if (!this.context.supports.serviceWorkerApi) {\n      const fallbackInterceptor = createFallbackRequestListener(this.context, this.context.startOptions);\n      this.subscriptions.push(() => {\n        fallbackInterceptor.dispose();\n      });\n      this.context.isMockingEnabled = true;\n      printStartMessage({\n        message: \"Mocking enabled (fallback mode).\",\n        quiet: this.context.startOptions.quiet\n      });\n      return void 0;\n    }\n    const startHandler = createStartHandler(this.context);\n    const registration = await startHandler(this.context.startOptions, options);\n    this.context.isMockingEnabled = true;\n    return registration;\n  }\n  stop() {\n    var _this$context$startOp;\n    super.dispose();\n    if (!this.context.isMockingEnabled) {\n      devUtils8.warn('Found a redundant \"worker.stop()\" call. Notice that stopping the worker after it has already been stopped has no effect. Consider removing this \"worker.stop()\" call.');\n      return;\n    }\n    this.context.isMockingEnabled = false;\n    this.context.workerStoppedAt = Date.now();\n    this.context.emitter.removeAllListeners();\n    if (this.context.supports.serviceWorkerApi) {\n      this.context.workerChannel.removeAllListeners(\"RESPONSE\");\n      window.clearInterval(this.context.keepAliveInterval);\n    }\n    window.postMessage({\n      type: \"msw/worker:stop\"\n    });\n    printStopMessage({\n      quiet: (_this$context$startOp = this.context.startOptions) === null || _this$context$startOp === void 0 ? void 0 : _this$context$startOp.quiet\n    });\n  }\n};\nfunction setupWorker() {\n  for (var _len17 = arguments.length, handlers = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n    handlers[_key17] = arguments[_key17];\n  }\n  return new SetupWorkerApi(...handlers);\n}\nexport { SetupWorkerApi, setupWorker };","map":{"version":3,"names":["POSITIONALS_EXP","serializePositional","positional","flag","Number","JSON","stringify","json","test","format","message","_len","arguments","length","positionals","Array","_key","positionalIndex","formattedMessage","replace","match","isEscaped","_","value","concat","slice","join","STACK_FRAMES_TO_IGNORE","cleanErrorStack","error2","stack","nextStack","split","splice","InvariantError","Error","constructor","name","_len2","_key2","invariant","predicate","_len3","_key3","as","ErrorConstructor","_len4","_key4","formatMessage","Reflect","construct","err","isNodeProcess","navigator","product","process","type","versions","node","mergeRight","DEFAULT_START_OPTIONS","serviceWorker","url","options","quiet","waitUntilReady","onUnhandledRequest","findWorker","scriptURL","mockServiceWorkerUrl","devUtils","devUtils6","until","promise","data","catch","error","getAbsoluteWorkerUrl","workerUrl","URL","location","href","getWorkerByRegistration","registration","absoluteWorkerUrl","allStates","active","installing","waiting","relevantStates","filter","state","worker","find","worker2","getWorkerInstance","undefined","mockRegistrations","getRegistrations","then","registrations","controller","reload","existingRegistration","update","registrationResult","register","isWorkerMissing","includes","scopeUrl","scope","createDeferredExecutor","executor","resolve","reject","result","onFulfilled","Promise","reason","queueMicrotask","rejectionReason","DeferredPromise","_executor","WeakMap","_Class_brand","WeakSet","deferredExecutor","originalResolve","originalReject","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_defineProperty","_classPrivateFieldSet","_classPrivateFieldGet","onRejected","_assertClassBrand","_decorate","call","finally","onfinally","Object","defineProperties","configurable","devUtils2","printStartMessage","args","console","groupCollapsed","log","workerScope","client","id","frameType","groupEnd","enableMocking","context","mockingEnabledPromise","workerChannel","postMessage","once","event","_context$registration","isMockingEnabled","workerPromise","pruneGetRequestBody","request","method","body","deserializeRequest","serializedRequest","Request","_objectSpread","RequestHandler","handleRequest","devUtils3","toResponseInit","isHandlerKind","createRequestListener","workerStoppedAt","interceptedAt","requestId","requestCloneForLogs","clone","requestClone","cache","set","getRequestHandlers","emitter","onPassthroughResponse","onMockedResponse","response","_ref","handler","parsedResult","responseClone","responseCloneForLogs","responseInit","supports","readableStreamTransfer","responseStreamOrNull","responseBufferOrNull","arrayBuffer","_error2$stack","status","statusText","headers","devUtils4","checkWorkerIntegrity","integrityCheckPromise","checksum","packageVersion","warn","encoder","TextEncoder","encodeBuffer","text","encode","decodeBuffer","buffer","encoding","decoder","TextDecoder","decode","toArrayBuffer","array","byteOffset","byteLength","IS_PATCHED_MODULE","Symbol","canParseUrl","_error","getValueBySymbol","symbolName","source","ownSymbols","getOwnPropertySymbols","symbol","symbol2","description","get","_FetchResponse","Response","isConfigurableStatusCode","isRedirectResponse","STATUS_CODES_WITH_REDIRECT","isResponseWithBody","STATUS_CODES_WITHOUT_BODY","setUrl","urlList","push","defineProperty","enumerable","writable","parseRawHeaders","rawHeaders","Headers","line","append","init","_a","safeStatus","finalBody","FetchResponse","kRawRequest","setRawRequest","rawRequest","__defProp","__export","target","all","colors_exports","blue","gray","green","red","yellow","IS_NODE","Logger","prefix","LOGGER_NAME","getVariable","LOGGER_LEVEL","isLoggingEnabled","startsWith","debug","isDefinedAndNotEquals","noop","info","success","warning","only","extend","domain","_len5","_key5","logEntry","level","colors","_this","_len6","_key6","performance2","PerformanceEntry","message2","measure","_len7","positionals2","_key7","deltaTime","_len8","_key8","timestamp","_len9","_key9","_len0","_key0","callback","createEntry","Date","customColors","entry","timestampColor","prefixColor","colorize","write","getWriter","formatTimestamp","serializeInput","map","toLocaleTimeString","getMilliseconds","startTime","performance","now","endTime","toFixed","_len1","_key1","stdout","_len10","_key10","stderr","_len11","_key11","variableName","_globalThis$variableN","env","globalThis","toString","expected","MemoryLeakError","count","_Emitter","listenerCount","eventName","events","Map","maxListeners","defaultMaxListeners","hasWarnedAboutPotentialMemoryLeak","_emitInternalEvent","internalEventName","listener","emit","_getListeners","prototype","apply","_removeListener","listeners","index","indexOf","_wrapOnceListener","_this2","onceListener","removeListener","_len12","_key12","setMaxListeners","getMaxListeners","eventNames","from","keys","_len13","_key13","forEach","addListener","nextListeners","memoryLeakWarning","on","prependListener","prependOnceListener","off","removeAllListeners","delete","clear","rawListeners","Emitter","INTERNAL_REQUEST_ID_HEADER_NAME","getGlobalSymbol","setGlobalSymbol","deleteGlobalSymbol","Interceptor","readyState","subscriptions","logger","checkEnvironment","shouldApply","runningInstance","getInstance","setup","setInstance","dispose","clearInstance","instance","createRequestId","Math","random","BatchInterceptor","interceptors","interceptor","createResponseListener","_responseMessage$resp","responseMessage","isMockedResponse","devUtils5","validateWorkerScope","createStartHandler","start","customOptions","startWorkerInstance","missingWorkerMessage","host","window","addEventListener","clearInterval","keepAliveInterval","setInterval","startOptions","workerRegistration","pendingInstance","activationPromise","devUtils8","SetupApi","mergeRight2","supportsReadableStreamTransfer","stream","ReadableStream","close","MessageChannel","port1","_unused","webSocketInterceptor","handleWebSocketEvent","attachWebSocketLogger","kDefaultPrevented","kPropagationStopped","kImmediatePropagationStopped","TypedEvent","_returnType","MessageEvent","defaultPrevented","preventDefault","stopImmediatePropagation","kListenerOptions","Emitter2","_listeners","_Class5_brand","_addListener","earlyOn","earlyOnce","proxiedEvent","_proxyEvent","_callListener","revoke","emitAsPromise","pendingListeners","allSettled","results","emitAsGenerator","existingListener","values","flat","_classPrivateFieldGet2","_classPrivateFieldGet3","insertMode","unshift","signal","stopPropagation","Proxy","thisArg","argArray","_listener$kListenerOp","returnValue","isObject","WorkerEvent","_workerEvent","workerEvent","payload","ports","transfer","WorkerChannel","InterceptorError","setPrototypeOf","kRequestHandled","kResponsePromise","RequestController","respondWith","errorWith","emitAsync","listners","_len14","_key14","isObject2","loose","isPropertyAccessible","obj","key","e","createServerErrorResponse","isResponseError","isResponseLike","isNodeLikeError","handleRequest2","handleResponse","onError","onRequestError","onResponse","handleResponseError","_ref2","pendingRequestId","requestAbortPromise","aborted","requestListenersPromise","race","unhandledExceptionController","nextResult","hasConfigurableGlobal","propertyName","descriptor","getOwnPropertyDescriptor","createNetworkError","cause","assign","TypeError","REQUEST_BODY_HEADERS","kRedirectCount","followFetchRedirect","requestUrl","locationUrl","protocol","mode","username","password","sameOrigin","requestInit","headerName","fetch","left","right","origin","hostname","port","BrotliDecompressionStream","TransformStream","transform","chunk","enqueue","PipelineStream","transformStreams","_len15","strategies","_key15","readable","reduce","readable2","pipeThrough","parseContentEncoding","contentEncoding","toLowerCase","coding","trim","createDecompressionStream","codings","transformers","reduceRight","transformers2","DecompressionStream","decompressResponse","decompressionStream","pipeTo","_FetchInterceptor","pureFetch","input","resolvedInput","responsePromise","isRequestHandled","rawResponse","decompressedStream","redirect","response2","requestCloneForResponseEvent","FetchInterceptor","concatArrayBuffer","Uint8Array","EventPolyfill","NONE","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","srcElement","currentTarget","eventPhase","isTrusted","composed","cancelable","bubbles","lengthComputable","loaded","total","cancelBubble","timeStamp","composedPath","initEvent","ProgressEventPolyfill","SUPPORTS_PROGRESS_EVENT","ProgressEvent","createEvent","progressEvents","ProgressEventClass","findPropertySource","hasProperty","hasOwnProperty","getPrototypeOf","createProxy","proxy","optionsToProxyHandler","constructorCall","methodCall","getProperty","setProperty","newTarget","next","bind","nextValue","propertySource","ownDescriptors","receiver","_len16","_key16","next2","isDomParserSupportedType","supportedTypes","some","supportedType","parseJson","parse","createResponse","responseBodyOrNull","responseURL","createHeadersFromXMLHttpReqestHeaders","getAllResponseHeaders","headersString","lines","parts","getBodyByteLength","explicitContentLength","kIsRequestHandled","IS_NODE2","kFetchRequest","XMLHttpRequestController","initialRequest","uploadEvents","requestHeaders","responseBuffer","_ref3","invoke","_ref4","methodName","toAbsoluteUrl","registerEvent","fetchResponse","fetchRequest","requestBody","toFetchApiRequest","onceRequestSettled","onRequest","setRequestHeader","define","upload","_ref5","registerUploadEvent","_ref6","prevEvents","nextEvents","totalRequestBodyLength","trigger","getResponseHeader","__","HEADERS_RECEIVED","headerValue","headersList","entries","allHeaders","_ref7","responseText","responseXML","totalResponseBodyLength","setReadyState","LOADING","finalizeResponse","DONE","reader","getReader","readNextResponseBodyChunk","done","read","responseBufferToText","responseType","responseJson","mimeType","responseBlob","Blob","contentType","DOMParser","parseFromString","nextReadyState","UNSENT","XMLHttpRequestUpload","registeredEventName","resolvedBody","Document","documentElement","innerText","credentials","withCredentials","toUpperCase","proxyHeaders","_ref8","property","createXMLHttpRequestProxy","_ref9","XMLHttpRequestProxy","XMLHttpRequest","originalRequest","prototypeDescriptors","getOwnPropertyDescriptors","xhrRequestController","_ref0","_ref1","_XMLHttpRequestInterceptor","interceptorSymbol","PureXMLHttpRequest","XMLHttpRequestInterceptor","handleRequest3","isHandlerKind2","createFallbackRequestListener","_ref10","_ref11","_ref12","_ref13","devUtils7","printStopMessage","SetupWorkerApi","createWorkerContext","handlersController","currentHandlers","serviceWorkerApi","getUnhandledRequestStrategy","getHandlers","onMockedConnection","connection","onPassthroughConnection","fallbackInterceptor","startHandler","stop","_this$context$startOp","setupWorker","_len17","handlers","_key17"],"sources":["C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\outvariant@1.4.3\\node_modules\\outvariant\\src\\format.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\outvariant@1.4.3\\node_modules\\outvariant\\src\\invariant.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\is-node-process@1.2.0\\node_modules\\is-node-process\\src\\index.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\utils\\prepareStartHandler.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\createStartHandler.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@open-draft+until@2.1.0\\node_modules\\@open-draft\\until\\src\\until.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\utils\\getWorkerInstance.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\utils\\getAbsoluteWorkerUrl.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\utils\\getWorkerByRegistration.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@open-draft+deferred-promise@2.2.0\\node_modules\\@open-draft\\deferred-promise\\src\\createDeferredExecutor.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@open-draft+deferred-promise@2.2.0\\node_modules\\@open-draft\\deferred-promise\\src\\DeferredPromise.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\utils\\printStartMessage.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\utils\\enableMocking.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\utils\\pruneGetRequestBody.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\utils\\deserializeRequest.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\createRequestListener.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\utils\\checkWorkerIntegrity.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\bufferUtils.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\glossary.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\canParseUrl.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\getValueBySymbol.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\fetchUtils.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\getRawRequest.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@open-draft+logger@0.3.0\\node_modules\\@open-draft\\logger\\lib\\index.mjs","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\strict-event-emitter@0.5.1\\node_modules\\strict-event-emitter\\src\\MemoryLeakError.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\strict-event-emitter@0.5.1\\node_modules\\strict-event-emitter\\src\\Emitter.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\Interceptor.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\createRequestId.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\BatchInterceptor.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\getCleanUrl.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\createResponseListener.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\utils\\validateWorkerScope.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\setupWorker.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\utils\\supportsReadableStreamTransfer.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\rettime@0.7.0\\node_modules\\rettime\\src\\index.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\utils\\workerChannel.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\RequestController.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\InterceptorError.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\emitAsync.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\handleRequest.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\isObject.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\isPropertyAccessible.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\responseUtils.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\isNodeLikeError.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\hasConfigurableGlobal.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\fetch\\index.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\fetch\\utils\\createNetworkError.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\fetch\\utils\\followRedirect.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\fetch\\utils\\brotli-decompress.browser.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\fetch\\utils\\decompression.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\index.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\XMLHttpRequestController.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\utils\\concatArrayBuffer.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\polyfills\\EventPolyfill.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\polyfills\\ProgressEventPolyfill.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\utils\\createEvent.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\findPropertySource.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\createProxy.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\utils\\isDomParserSupportedType.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\parseJson.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\utils\\createResponse.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\utils\\getBodyByteLength.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\XMLHttpRequestProxy.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\createFallbackRequestListener.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\stop\\utils\\printStopMessage.ts"],"sourcesContent":["const POSITIONALS_EXP = /(%?)(%([sdijo]))/g\n\nfunction serializePositional(positional: any, flag: string): any {\n  switch (flag) {\n    // Strings.\n    case 's':\n      return positional\n\n    // Digits.\n    case 'd':\n    case 'i':\n      return Number(positional)\n\n    // JSON.\n    case 'j':\n      return JSON.stringify(positional)\n\n    // Objects.\n    case 'o': {\n      // Preserve stings to prevent extra quotes around them.\n      if (typeof positional === 'string') {\n        return positional\n      }\n\n      const json = JSON.stringify(positional)\n\n      // If the positional isn't serializable, return it as-is.\n      if (json === '{}' || json === '[]' || /^\\[object .+?\\]$/.test(json)) {\n        return positional\n      }\n\n      return json\n    }\n  }\n}\n\nexport function format(message: string, ...positionals: any[]): string {\n  if (positionals.length === 0) {\n    return message\n  }\n\n  let positionalIndex = 0\n  let formattedMessage = message.replace(\n    POSITIONALS_EXP,\n    (match, isEscaped, _, flag) => {\n      const positional = positionals[positionalIndex]\n      const value = serializePositional(positional, flag)\n\n      if (!isEscaped) {\n        positionalIndex++\n        return value\n      }\n\n      return match\n    }\n  )\n\n  // Append unresolved positionals to string as-is.\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(' ')}`\n  }\n\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, '%')\n\n  return formattedMessage\n}\n","import { format } from './format'\n\nconst STACK_FRAMES_TO_IGNORE = 2\n\n/**\n * Remove the \"outvariant\" package trace from the given error.\n * This scopes down the error stack to the relevant parts\n * when used in other applications.\n */\nfunction cleanErrorStack(error: Error): void {\n  if (!error.stack) {\n    return\n  }\n\n  const nextStack = error.stack.split('\\n')\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE)\n  error.stack = nextStack.join('\\n')\n}\n\nexport class InvariantError extends Error {\n  name = 'Invariant Violation'\n\n  constructor(public readonly message: string, ...positionals: any[]) {\n    super(message)\n    this.message = format(message, ...positionals)\n    cleanErrorStack(this)\n  }\n}\n\nexport interface CustomErrorConstructor {\n  new (message: string): Error\n}\n\nexport interface CustomErrorFactory {\n  (message: string): Error\n}\n\nexport type CustomError = CustomErrorConstructor | CustomErrorFactory\n\ntype Invariant = {\n  (\n    predicate: unknown,\n    message: string,\n    ...positionals: any[]\n  ): asserts predicate\n\n  as(\n    ErrorConstructor: CustomError,\n    predicate: unknown,\n    message: string,\n    ...positionals: unknown[]\n  ): asserts predicate\n}\n\nexport const invariant: Invariant = (\n  predicate,\n  message,\n  ...positionals\n): asserts predicate => {\n  if (!predicate) {\n    throw new InvariantError(message, ...positionals)\n  }\n}\n\ninvariant.as = (ErrorConstructor, predicate, message, ...positionals) => {\n  if (!predicate) {\n    const formatMessage =\n      positionals.length === 0 ? message : format(message, ...positionals)\n    let error: Error\n\n    try {\n      error = Reflect.construct(ErrorConstructor as CustomErrorConstructor, [\n        formatMessage,\n      ])\n    } catch (err) {\n      error = (ErrorConstructor as CustomErrorFactory)(formatMessage)\n    }\n\n    throw error\n  }\n}\n","/**\n * Determines if the current process is a Node.js process.\n */\nexport function isNodeProcess(): boolean {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return true\n  }\n\n  if (typeof process !== 'undefined') {\n    // Electron (https://www.electronjs.org/docs/latest/api/process#processtype-readonly)\n    const type = (process as any).type\n    if (type === 'renderer' || type === 'worker') {\n      return false\n    }\n\n\n    return !!(\n      process.versions &&\n      process.versions.node\n    )\n  }\n\n  return false\n}\n","import { RequiredDeep } from '~/core/typeUtils'\nimport { mergeRight } from '~/core/utils/internal/mergeRight'\nimport {\n  SetupWorker,\n  SetupWorkerInternalContext,\n  StartHandler,\n  StartOptions,\n} from '../../glossary'\n\nexport const DEFAULT_START_OPTIONS: RequiredDeep<StartOptions> = {\n  serviceWorker: {\n    url: '/mockServiceWorker.js',\n    options: null as any,\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: 'warn',\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl\n  },\n}\n\n/**\n * Returns resolved worker start options, merging the default options\n * with the given custom options.\n */\nexport function resolveStartOptions(\n  initialOptions?: StartOptions,\n): RequiredDeep<StartOptions> {\n  return mergeRight(\n    DEFAULT_START_OPTIONS,\n    initialOptions || {},\n  ) as RequiredDeep<StartOptions>\n}\n\nexport function prepareStartHandler(\n  handler: StartHandler,\n  context: SetupWorkerInternalContext,\n): SetupWorker['start'] {\n  return (initialOptions) => {\n    context.startOptions = resolveStartOptions(initialOptions)\n    return handler(context.startOptions, initialOptions || {})\n  }\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport { getWorkerInstance } from './utils/getWorkerInstance'\nimport { enableMocking } from './utils/enableMocking'\nimport type { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { createRequestListener } from './createRequestListener'\nimport { checkWorkerIntegrity } from '../../utils/checkWorkerIntegrity'\nimport { createResponseListener } from './createResponseListener'\nimport { validateWorkerScope } from './utils/validateWorkerScope'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\n\nexport const createStartHandler = (\n  context: SetupWorkerInternalContext,\n): StartHandler => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      // Remove all previously existing event listeners.\n      // This way none of the listeners persists between Fast refresh\n      // of the application's code.\n      context.workerChannel.removeAllListeners()\n\n      // Handle requests signaled by the worker.\n      context.workerChannel.on(\n        'REQUEST',\n        createRequestListener(context, options),\n      )\n\n      // Handle responses signaled by the worker.\n      context.workerChannel.on('RESPONSE', createResponseListener(context))\n\n      const instance = await getWorkerInstance(\n        options.serviceWorker.url,\n        options.serviceWorker.options,\n        options.findWorker,\n      )\n\n      const [worker, registration] = instance\n\n      if (!worker) {\n        const missingWorkerMessage = customOptions?.findWorker\n          ? devUtils.formatMessage(\n              `Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`,\n              options.serviceWorker.url,\n            )\n          : devUtils.formatMessage(\n              `Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,\n              options.serviceWorker.url,\n              location.host,\n            )\n\n        throw new Error(missingWorkerMessage)\n      }\n\n      context.workerPromise.resolve(worker)\n      context.registration = registration\n\n      window.addEventListener('beforeunload', () => {\n        if (worker.state !== 'redundant') {\n          // Notify the Service Worker that this client has closed.\n          // Internally, it's similar to disabling the mocking, only\n          // client close event has a handler that self-terminates\n          // the Service Worker when there are no open clients.\n          context.workerChannel.postMessage('CLIENT_CLOSED')\n        }\n\n        // Make sure we're always clearing the interval - there are reports that not doing this can\n        // cause memory leaks in headless browser environments.\n        window.clearInterval(context.keepAliveInterval)\n\n        // Notify others about this client disconnecting.\n        // E.g. this will purge the in-memory WebSocket clients since\n        // starting the worker again will assign them new IDs.\n        window.postMessage({ type: 'msw/worker:stop' })\n      })\n\n      // Check if the active Service Worker has been generated\n      // by the currently installed version of MSW.\n      await checkWorkerIntegrity(context).catch((error) => {\n        devUtils.error(\n          'Error while checking the worker script integrity. Please report this on GitHub (https://github.com/mswjs/msw/issues) and include the original error below.',\n        )\n        console.error(error)\n      })\n\n      context.keepAliveInterval = window.setInterval(\n        () => context.workerChannel.postMessage('KEEPALIVE_REQUEST'),\n        5000,\n      )\n\n      // Warn the user when loading the page that lies outside\n      // of the worker's scope.\n      validateWorkerScope(registration, context.startOptions)\n\n      return registration\n    }\n\n    const workerRegistration = startWorkerInstance().then(\n      async (registration) => {\n        const pendingInstance = registration.installing || registration.waiting\n\n        if (pendingInstance) {\n          const activationPromise = new DeferredPromise<void>()\n\n          pendingInstance.addEventListener('statechange', () => {\n            if (pendingInstance.state === 'activated') {\n              activationPromise.resolve()\n            }\n          })\n\n          // Wait until the worker is activated.\n          // Assume the worker is already activated if there's no pending registration\n          // (i.e. when reloading the page after a successful activation).\n          await activationPromise\n        }\n\n        // Print the activation message only after the worker has been activated.\n        await enableMocking(context, options).catch((error) => {\n          devUtils.error(\n            'Failed to enable mocking. Please report this on GitHub (https://github.com/mswjs/msw/issues) and include the original error below.',\n          )\n          throw error\n        })\n\n        return registration\n      },\n    )\n\n    return workerRegistration\n  }\n}\n","export type AsyncTuple<\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n> =\n  | {\n      error: ErrorType\n      data: null\n    }\n  | { error: null; data: DataType }\n\n/**\n * Gracefully handles a given Promise factory.\n * @example\n * const { error, data } = await until(() => asyncAction())\n */\nexport const until = async <\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n>(\n  promise: () => Promise<DataType>,\n): Promise<AsyncTuple<ErrorType, DataType>> => {\n  try {\n    const data = await promise().catch((error) => {\n      throw error\n    })\n    return { error: null, data }\n  } catch (error) {\n    return { error, data: null }\n  }\n}\n","import { until } from '@open-draft/until'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { getAbsoluteWorkerUrl } from '../../../utils/getAbsoluteWorkerUrl'\nimport { getWorkerByRegistration } from './getWorkerByRegistration'\nimport { ServiceWorkerInstanceTuple, FindWorker } from '../../glossary'\n\n/**\n * Returns an active Service Worker instance.\n * When not found, registers a new Service Worker.\n */\nexport const getWorkerInstance = async (\n  url: string,\n  options: RegistrationOptions = {},\n  findWorker: FindWorker,\n): Promise<ServiceWorkerInstanceTuple> => {\n  // Resolve the absolute Service Worker URL.\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url)\n\n  const mockRegistrations = await navigator.serviceWorker\n    .getRegistrations()\n    .then((registrations) =>\n      registrations.filter((registration) =>\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n      ),\n    )\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    // Reload the page when it has associated workers, but no active controller.\n    // The absence of a controller can mean either:\n    // - page has no Service Worker associated with it\n    // - page has been hard-reloaded and its workers won't be used until the next reload.\n    // Since we've checked that there are registrations associated with this page,\n    // at this point we are sure it's hard reload that falls into this clause.\n    location.reload()\n  }\n\n  const [existingRegistration] = mockRegistrations\n\n  if (existingRegistration) {\n    // Schedule the worker update in the background.\n    // Update ensures the existing worker is up-to-date.\n    existingRegistration.update()\n\n    // Return the worker reference immediately.\n    return [\n      getWorkerByRegistration(\n        existingRegistration,\n        absoluteWorkerUrl,\n        findWorker,\n      ),\n      existingRegistration,\n    ]\n  }\n\n  // When the Service Worker wasn't found, register it anew and return the reference.\n  const registrationResult = await until<Error, ServiceWorkerInstanceTuple>(\n    async () => {\n      const registration = await navigator.serviceWorker.register(url, options)\n      return [\n        // Compare existing worker registration by its worker URL,\n        // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n        registration,\n      ]\n    },\n  )\n\n  // Handle Service Worker registration errors.\n  if (registrationResult.error) {\n    const isWorkerMissing = registrationResult.error.message.includes('(404)')\n\n    // Produce a custom error message when given a non-existing Service Worker url.\n    // Suggest developers to check their setup.\n    if (isWorkerMissing) {\n      const scopeUrl = new URL(options?.scope || '/', location.href)\n\n      throw new Error(\n        devUtils.formatMessage(`\\\nFailed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`),\n      )\n    }\n\n    // Fallback error message for any other registration errors.\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to register the Service Worker:\\n\\n%s',\n        registrationResult.error.message,\n      ),\n    )\n  }\n\n  return registrationResult.data\n}\n","/**\n * Returns an absolute Service Worker URL based on the given\n * relative URL (known during the registration).\n */\nexport function getAbsoluteWorkerUrl(workerUrl: string): string {\n  return new URL(workerUrl, location.href).href\n}\n","import { FindWorker } from '../../glossary'\n\n/**\n * Attempts to resolve a Service Worker instance from a given registration,\n * regardless of its state (active, installing, waiting).\n */\nexport function getWorkerByRegistration(\n  registration: ServiceWorkerRegistration,\n  absoluteWorkerUrl: string,\n  findWorker: FindWorker,\n): ServiceWorker | null {\n  const allStates = [\n    registration.active,\n    registration.installing,\n    registration.waiting,\n  ]\n  const relevantStates = allStates.filter((state): state is ServiceWorker => {\n    return state != null\n  })\n  const worker = relevantStates.find((worker) => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl)\n  })\n\n  return worker || null\n}\n","export type PromiseState = 'pending' | 'fulfilled' | 'rejected'\n\nexport type Executor<Value> = ConstructorParameters<typeof Promise<Value>>[0]\nexport type ResolveFunction<Value> = Parameters<Executor<Value>>[0]\nexport type RejectFunction<Reason> = Parameters<Executor<Reason>>[1]\n\nexport type DeferredPromiseExecutor<Input = never, Output = Input> = {\n  (resolve?: ResolveFunction<Input>, reject?: RejectFunction<any>): void\n\n  resolve: ResolveFunction<Input>\n  reject: RejectFunction<any>\n  result?: Output\n  state: PromiseState\n  rejectionReason?: unknown\n}\nexport function createDeferredExecutor<\n  Input = never,\n  Output = Input\n>(): DeferredPromiseExecutor<Input, Output> {\n  const executor = <DeferredPromiseExecutor<Input, Output>>((\n    resolve,\n    reject\n  ) => {\n    executor.state = 'pending'\n\n    executor.resolve = (data) => {\n      if (executor.state !== 'pending') {\n        return\n      }\n\n      executor.result = data as Output\n\n      const onFulfilled = <Value>(value: Value) => {\n        executor.state = 'fulfilled'\n        return value\n      }\n\n      return resolve(\n        data instanceof Promise ? data : Promise.resolve(data).then(onFulfilled)\n      )\n    }\n\n    executor.reject = (reason) => {\n      if (executor.state !== 'pending') {\n        return\n      }\n\n      queueMicrotask(() => {\n        executor.state = 'rejected'\n      })\n\n      return reject((executor.rejectionReason = reason))\n    }\n  })\n\n  return executor\n}\n","import {\n  type Executor,\n  type RejectFunction,\n  type ResolveFunction,\n  type DeferredPromiseExecutor,\n  createDeferredExecutor,\n} from './createDeferredExecutor'\n\nexport class DeferredPromise<Input, Output = Input> extends Promise<Input> {\n  #executor: DeferredPromiseExecutor\n\n  public resolve: ResolveFunction<Output>\n  public reject: RejectFunction<Output>\n\n  constructor(executor: Executor<Input> | null = null) {\n    const deferredExecutor = createDeferredExecutor()\n    super((originalResolve, originalReject) => {\n      deferredExecutor(originalResolve, originalReject)\n      executor?.(deferredExecutor.resolve, deferredExecutor.reject)\n    })\n\n    this.#executor = deferredExecutor\n    this.resolve = this.#executor.resolve\n    this.reject = this.#executor.reject\n  }\n\n  public get state() {\n    return this.#executor.state\n  }\n\n  public get rejectionReason() {\n    return this.#executor.rejectionReason\n  }\n\n  public then<ThenResult = Input, CatchResult = never>(\n    onFulfilled?: (value: Input) => ThenResult | PromiseLike<ThenResult>,\n    onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>\n  ) {\n    return this.#decorate(super.then(onFulfilled, onRejected))\n  }\n\n  public catch<CatchResult = never>(\n    onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>\n  ) {\n    return this.#decorate(super.catch(onRejected))\n  }\n\n  public finally(onfinally?: () => void | Promise<any>) {\n    return this.#decorate(super.finally(onfinally))\n  }\n\n  #decorate<ChildInput>(\n    promise: Promise<ChildInput>\n  ): DeferredPromise<ChildInput, Output> {\n    return Object.defineProperties(promise, {\n      resolve: { configurable: true, value: this.resolve },\n      reject: { configurable: true, value: this.reject },\n    }) as DeferredPromise<ChildInput, Output>\n  }\n}\n","import type { ServiceWorkerIncomingEventsMap } from '../../glossary'\nimport { devUtils } from '~/core/utils/internal/devUtils'\n\ninterface PrintStartMessageArgs {\n  quiet?: boolean\n  message?: string\n  workerUrl?: string\n  workerScope?: string\n  client?: ServiceWorkerIncomingEventsMap['MOCKING_ENABLED']['client']\n}\n\n/**\n * Prints a worker activation message in the browser's console.\n */\nexport function printStartMessage(args: PrintStartMessageArgs = {}) {\n  if (args.quiet) {\n    return\n  }\n\n  const message = args.message || 'Mocking enabled.'\n\n  console.groupCollapsed(\n    `%c${devUtils.formatMessage(message)}`,\n    'color:orangered;font-weight:bold;',\n  )\n  // eslint-disable-next-line no-console\n  console.log(\n    '%cDocumentation: %chttps://mswjs.io/docs',\n    'font-weight:bold',\n    'font-weight:normal',\n  )\n  // eslint-disable-next-line no-console\n  console.log('Found an issue? https://github.com/mswjs/msw/issues')\n\n  if (args.workerUrl) {\n    // eslint-disable-next-line no-console\n    console.log('Worker script URL:', args.workerUrl)\n  }\n\n  if (args.workerScope) {\n    // eslint-disable-next-line no-console\n    console.log('Worker scope:', args.workerScope)\n  }\n\n  if (args.client) {\n    // eslint-disable-next-line no-console\n    console.log('Client ID: %s (%s)', args.client.id, args.client.frameType)\n  }\n\n  console.groupEnd()\n}\n","import { DeferredPromise } from '@open-draft/deferred-promise'\nimport type { StartOptions, SetupWorkerInternalContext } from '../../glossary'\nimport { printStartMessage } from './printStartMessage'\n\n/**\n * Signals the worker to enable the interception of requests.\n */\nexport function enableMocking(\n  context: SetupWorkerInternalContext,\n  options: StartOptions,\n): Promise<boolean> {\n  const mockingEnabledPromise = new DeferredPromise<boolean>()\n\n  context.workerChannel.postMessage('MOCK_ACTIVATE')\n  context.workerChannel.once('MOCKING_ENABLED', async (event) => {\n    context.isMockingEnabled = true\n    const worker = await context.workerPromise\n\n    printStartMessage({\n      quiet: options.quiet,\n      workerScope: context.registration?.scope,\n      workerUrl: worker.scriptURL,\n      client: event.data.client,\n    })\n\n    mockingEnabledPromise.resolve(true)\n  })\n\n  return mockingEnabledPromise\n}\n","import type { ServiceWorkerIncomingRequest } from '../setupWorker/glossary'\n\ntype Input = Pick<ServiceWorkerIncomingRequest, 'method' | 'body'>\n\n/**\n * Ensures that an empty GET request body is always represented as `undefined`.\n */\nexport function pruneGetRequestBody(\n  request: Input,\n): ServiceWorkerIncomingRequest['body'] {\n  // Force HEAD/GET request body to always be empty.\n  // The worker reads any request's body as ArrayBuffer,\n  // and you cannot re-construct a GET/HEAD Request\n  // with an ArrayBuffer, even if empty. Also note that\n  // \"request.body\" is always undefined in the worker.\n  if (['HEAD', 'GET'].includes(request.method)) {\n    return undefined\n  }\n\n  return request.body\n}\n","import { pruneGetRequestBody } from './pruneGetRequestBody'\nimport type { ServiceWorkerIncomingRequest } from '../setupWorker/glossary'\n\n/**\n * Converts a given request received from the Service Worker\n * into a Fetch `Request` instance.\n */\nexport function deserializeRequest(\n  serializedRequest: ServiceWorkerIncomingRequest,\n): Request {\n  return new Request(serializedRequest.url, {\n    ...serializedRequest,\n    body: pruneGetRequestBody(serializedRequest),\n  })\n}\n","import { Emitter } from 'rettime'\nimport { StartOptions, SetupWorkerInternalContext } from '../glossary'\nimport { deserializeRequest } from '../../utils/deserializeRequest'\nimport { RequestHandler } from '~/core/handlers/RequestHandler'\nimport { handleRequest } from '~/core/utils/handleRequest'\nimport { RequiredDeep } from '~/core/typeUtils'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { toResponseInit } from '~/core/utils/toResponseInit'\nimport { isHandlerKind } from '~/core/utils/internal/isHandlerKind'\n\nexport const createRequestListener = (\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n): Emitter.ListenerType<typeof context.workerChannel, 'REQUEST'> => {\n  return async (event) => {\n    // Treat any incoming requests from the worker as passthrough\n    // if `worker.stop()` has been called for this client.\n    if (\n      !context.isMockingEnabled &&\n      context.workerStoppedAt &&\n      event.data.interceptedAt > context.workerStoppedAt\n    ) {\n      event.postMessage('PASSTHROUGH')\n      return\n    }\n\n    const requestId = event.data.id\n    const request = deserializeRequest(event.data)\n    const requestCloneForLogs = request.clone()\n\n    // Make this the first request clone before the\n    // request resolution pipeline even starts.\n    // Store the clone in cache so the first matching\n    // request handler would skip the cloning phase.\n    const requestClone = request.clone()\n    RequestHandler.cache.set(request, requestClone)\n\n    try {\n      await handleRequest(\n        request,\n        requestId,\n        context.getRequestHandlers().filter(isHandlerKind('RequestHandler')),\n        options,\n        context.emitter,\n        {\n          onPassthroughResponse() {\n            event.postMessage('PASSTHROUGH')\n          },\n          async onMockedResponse(response, { handler, parsedResult }) {\n            // Clone the mocked response so its body could be read\n            // to buffer to be sent to the worker and also in the\n            // \".log()\" method of the request handler.\n            const responseClone = response.clone()\n            const responseCloneForLogs = response.clone()\n            const responseInit = toResponseInit(response)\n\n            /**\n             * @note Safari doesn't support transferring a \"ReadableStream\".\n             * Check that the browser supports that before sending it to the worker.\n             */\n            if (context.supports.readableStreamTransfer) {\n              const responseStreamOrNull = response.body\n\n              event.postMessage(\n                'MOCK_RESPONSE',\n                {\n                  ...responseInit,\n                  body: responseStreamOrNull,\n                },\n                responseStreamOrNull ? [responseStreamOrNull] : undefined,\n              )\n            } else {\n              /**\n               * @note If we are here, this means the current environment doesn't\n               * support \"ReadableStream\" as transferable. In that case,\n               * attempt to read the non-empty response body as ArrayBuffer, if it's not empty.\n               * @see https://github.com/mswjs/msw/issues/1827\n               */\n              const responseBufferOrNull =\n                response.body === null\n                  ? null\n                  : await responseClone.arrayBuffer()\n\n              event.postMessage('MOCK_RESPONSE', {\n                ...responseInit,\n                body: responseBufferOrNull,\n              })\n            }\n\n            if (!options.quiet) {\n              context.emitter.once('response:mocked', () => {\n                handler.log({\n                  request: requestCloneForLogs,\n                  response: responseCloneForLogs,\n                  parsedResult,\n                })\n              })\n            }\n          },\n        },\n      )\n    } catch (error) {\n      if (error instanceof Error) {\n        devUtils.error(\n          `Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/http/mocking-responses/error-responses`,\n          request.method,\n          request.url,\n          error.stack ?? error,\n        )\n\n        // Treat all other exceptions in a request handler as unintended,\n        // alerting that there is a problem that needs fixing.\n        event.postMessage('MOCK_RESPONSE', {\n          status: 500,\n          statusText: 'Request Handler Error',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n          }),\n        })\n      }\n    }\n  }\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport type { SetupWorkerInternalContext } from '../setupWorker/glossary'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\n\n/**\n * Check whether the registered Service Worker has been\n * generated by the installed version of the library.\n * Prints a warning message if the worker scripts mismatch.\n */\nexport function checkWorkerIntegrity(\n  context: SetupWorkerInternalContext,\n): Promise<void> {\n  const integrityCheckPromise = new DeferredPromise<void>()\n\n  // Request the integrity checksum from the registered worker.\n  context.workerChannel.postMessage('INTEGRITY_CHECK_REQUEST')\n  context.workerChannel.once('INTEGRITY_CHECK_RESPONSE', (event) => {\n    const { checksum, packageVersion } = event.data\n\n    // Compare the response from the Service Worker and the\n    // global variable set during the build.\n\n    // The integrity is validated based on the worker script's checksum\n    // that's derived from its minified content during the build.\n    // The \"SERVICE_WORKER_CHECKSUM\" global variable is injected by the build.\n    if (checksum !== SERVICE_WORKER_CHECKSUM) {\n      devUtils.warn(\n        `The currently registered Service Worker has been generated by a different version of MSW (${packageVersion}) and may not be fully compatible with the installed version.\n\nIt's recommended you update your worker script by running this command:\n\n  \\u2022 npx msw init <PUBLIC_DIR>\n\nYou can also automate this process and make the worker script update automatically upon the library installations. Read more: https://mswjs.io/docs/cli/init.`,\n      )\n    }\n\n    integrityCheckPromise.resolve()\n  })\n\n  return integrityCheckPromise\n}\n","const encoder = new TextEncoder()\n\nexport function encodeBuffer(text: string): Uint8Array {\n  return encoder.encode(text)\n}\n\nexport function decodeBuffer(buffer: ArrayBuffer, encoding?: string): string {\n  const decoder = new TextDecoder(encoding)\n  return decoder.decode(buffer)\n}\n\n/**\n * Create an `ArrayBuffer` from the given `Uint8Array`.\n * Takes the byte offset into account to produce the right buffer\n * in the case when the buffer is bigger than the data view.\n */\nexport function toArrayBuffer(array: Uint8Array): ArrayBuffer {\n  return array.buffer.slice(\n    array.byteOffset,\n    array.byteOffset + array.byteLength\n  )\n}\n","import type { RequestController } from './RequestController'\n\nexport const IS_PATCHED_MODULE: unique symbol = Symbol('isPatchedModule')\n\n/**\n * @note Export `RequestController` as a type only.\n * It's never meant to be created in the userland.\n */\nexport type { RequestController }\n\nexport type RequestCredentials = 'omit' | 'include' | 'same-origin'\n\nexport type HttpRequestEventMap = {\n  request: [\n    args: {\n      request: Request\n      requestId: string\n      controller: RequestController\n    }\n  ]\n  response: [\n    args: {\n      response: Response\n      isMockedResponse: boolean\n      request: Request\n      requestId: string\n    }\n  ]\n  unhandledException: [\n    args: {\n      error: unknown\n      request: Request\n      requestId: string\n      controller: RequestController\n    }\n  ]\n}\n","/**\n * Returns a boolean indicating whether the given URL string\n * can be parsed into a `URL` instance.\n * A substitute for `URL.canParse()` for Node.js 18.\n */\nexport function canParseUrl(url: string): boolean {\n  try {\n    new URL(url)\n    return true\n  } catch (_error) {\n    return false\n  }\n}\n","/**\n * Returns the value behind the symbol with the given name.\n */\nexport function getValueBySymbol<T>(\n  symbolName: string,\n  source: object\n): T | undefined {\n  const ownSymbols = Object.getOwnPropertySymbols(source)\n\n  const symbol = ownSymbols.find((symbol) => {\n    return symbol.description === symbolName\n  })\n\n  if (symbol) {\n    return Reflect.get(source, symbol)\n  }\n\n  return\n}\n","import { canParseUrl } from './canParseUrl'\nimport { getValueBySymbol } from './getValueBySymbol'\n\nexport interface FetchResponseInit extends ResponseInit {\n  url?: string\n}\n\ninterface UndiciFetchInternalState {\n  aborted: boolean\n  rangeRequested: boolean\n  timingAllowPassed: boolean\n  requestIncludesCredentials: boolean\n  type: ResponseType\n  status: number\n  statusText: string\n  timingInfo: unknown\n  cacheState: unknown\n  headersList: Record<symbol, Map<string, unknown>>\n  urlList: Array<URL>\n  body?: {\n    stream: ReadableStream\n    source: unknown\n    length: number\n  }\n}\n\nexport class FetchResponse extends Response {\n  /**\n   * Response status codes for responses that cannot have body.\n   * @see https://fetch.spec.whatwg.org/#statuses\n   */\n  static readonly STATUS_CODES_WITHOUT_BODY = [101, 103, 204, 205, 304]\n\n  static readonly STATUS_CODES_WITH_REDIRECT = [301, 302, 303, 307, 308]\n\n  static isConfigurableStatusCode(status: number): boolean {\n    return status >= 200 && status <= 599\n  }\n\n  static isRedirectResponse(status: number): boolean {\n    return FetchResponse.STATUS_CODES_WITH_REDIRECT.includes(status)\n  }\n\n  /**\n   * Returns a boolean indicating whether the given response status\n   * code represents a response that can have a body.\n   */\n  static isResponseWithBody(status: number): boolean {\n    return !FetchResponse.STATUS_CODES_WITHOUT_BODY.includes(status)\n  }\n\n  static setUrl(url: string | undefined, response: Response): void {\n    if (!url || url === 'about:' || !canParseUrl(url)) {\n      return\n    }\n\n    const state = getValueBySymbol<UndiciFetchInternalState>('state', response)\n\n    if (state) {\n      // In Undici, push the URL to the internal list of URLs.\n      // This will respect the `response.url` getter logic correctly.\n      state.urlList.push(new URL(url))\n    } else {\n      // In other libraries, redefine the `url` property directly.\n      Object.defineProperty(response, 'url', {\n        value: url,\n        enumerable: true,\n        configurable: true,\n        writable: false,\n      })\n    }\n  }\n\n  /**\n   * Parses the given raw HTTP headers into a Fetch API `Headers` instance.\n   */\n  static parseRawHeaders(rawHeaders: Array<string>): Headers {\n    const headers = new Headers()\n    for (let line = 0; line < rawHeaders.length; line += 2) {\n      headers.append(rawHeaders[line], rawHeaders[line + 1])\n    }\n    return headers\n  }\n\n  constructor(body?: BodyInit | null, init: FetchResponseInit = {}) {\n    const status = init.status ?? 200\n    const safeStatus = FetchResponse.isConfigurableStatusCode(status)\n      ? status\n      : 200\n    const finalBody = FetchResponse.isResponseWithBody(status) ? body : null\n\n    super(finalBody, {\n      status: safeStatus,\n      statusText: init.statusText,\n      headers: init.headers,\n    })\n\n    if (status !== safeStatus) {\n      /**\n       * @note Undici keeps an internal \"Symbol(state)\" that holds\n       * the actual value of response status. Update that in Node.js.\n       */\n      const state = getValueBySymbol<UndiciFetchInternalState>('state', this)\n\n      if (state) {\n        state.status = status\n      } else {\n        Object.defineProperty(this, 'status', {\n          value: status,\n          enumerable: true,\n          configurable: true,\n          writable: false,\n        })\n      }\n    }\n\n    FetchResponse.setUrl(init.url, this)\n  }\n}\n","const kRawRequest = Symbol('kRawRequest')\n\n/**\n * Returns a raw request instance associated with this request.\n *\n * @example\n * interceptor.on('request', ({ request }) => {\n *   const rawRequest = getRawRequest(request)\n *\n *   if (rawRequest instanceof http.ClientRequest) {\n *     console.log(rawRequest.rawHeaders)\n *   }\n * })\n */\nexport function getRawRequest(request: Request): unknown | undefined {\n  return Reflect.get(request, kRawRequest)\n}\n\nexport function setRawRequest(request: Request, rawRequest: unknown): void {\n  Reflect.set(request, kRawRequest, rawRequest)\n}\n","var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/index.ts\nimport { isNodeProcess } from \"is-node-process\";\nimport { format } from \"outvariant\";\n\n// src/colors.ts\nvar colors_exports = {};\n__export(colors_exports, {\n  blue: () => blue,\n  gray: () => gray,\n  green: () => green,\n  red: () => red,\n  yellow: () => yellow\n});\nfunction yellow(text) {\n  return `\\x1B[33m${text}\\x1B[0m`;\n}\nfunction blue(text) {\n  return `\\x1B[34m${text}\\x1B[0m`;\n}\nfunction gray(text) {\n  return `\\x1B[90m${text}\\x1B[0m`;\n}\nfunction red(text) {\n  return `\\x1B[31m${text}\\x1B[0m`;\n}\nfunction green(text) {\n  return `\\x1B[32m${text}\\x1B[0m`;\n}\n\n// src/index.ts\nvar IS_NODE = isNodeProcess();\nvar Logger = class {\n  constructor(name) {\n    this.name = name;\n    this.prefix = `[${this.name}]`;\n    const LOGGER_NAME = getVariable(\"DEBUG\");\n    const LOGGER_LEVEL = getVariable(\"LOG_LEVEL\");\n    const isLoggingEnabled = LOGGER_NAME === \"1\" || LOGGER_NAME === \"true\" || typeof LOGGER_NAME !== \"undefined\" && this.name.startsWith(LOGGER_NAME);\n    if (isLoggingEnabled) {\n      this.debug = isDefinedAndNotEquals(LOGGER_LEVEL, \"debug\") ? noop : this.debug;\n      this.info = isDefinedAndNotEquals(LOGGER_LEVEL, \"info\") ? noop : this.info;\n      this.success = isDefinedAndNotEquals(LOGGER_LEVEL, \"success\") ? noop : this.success;\n      this.warning = isDefinedAndNotEquals(LOGGER_LEVEL, \"warning\") ? noop : this.warning;\n      this.error = isDefinedAndNotEquals(LOGGER_LEVEL, \"error\") ? noop : this.error;\n    } else {\n      this.info = noop;\n      this.success = noop;\n      this.warning = noop;\n      this.error = noop;\n      this.only = noop;\n    }\n  }\n  prefix;\n  extend(domain) {\n    return new Logger(`${this.name}:${domain}`);\n  }\n  /**\n   * Print a debug message.\n   * @example\n   * logger.debug('no duplicates found, creating a document...')\n   */\n  debug(message, ...positionals) {\n    this.logEntry({\n      level: \"debug\",\n      message: gray(message),\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"gray\"\n      }\n    });\n  }\n  /**\n   * Print an info message.\n   * @example\n   * logger.info('start parsing...')\n   */\n  info(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"blue\"\n      }\n    });\n    const performance2 = new PerformanceEntry();\n    return (message2, ...positionals2) => {\n      performance2.measure();\n      this.logEntry({\n        level: \"info\",\n        message: `${message2} ${gray(`${performance2.deltaTime}ms`)}`,\n        positionals: positionals2,\n        prefix: this.prefix,\n        colors: {\n          prefix: \"blue\"\n        }\n      });\n    };\n  }\n  /**\n   * Print a success message.\n   * @example\n   * logger.success('successfully created document')\n   */\n  success(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: `\\u2714 ${this.prefix}`,\n      colors: {\n        timestamp: \"green\",\n        prefix: \"green\"\n      }\n    });\n  }\n  /**\n   * Print a warning.\n   * @example\n   * logger.warning('found legacy document format')\n   */\n  warning(message, ...positionals) {\n    this.logEntry({\n      level: \"warning\",\n      message,\n      positionals,\n      prefix: `\\u26A0 ${this.prefix}`,\n      colors: {\n        timestamp: \"yellow\",\n        prefix: \"yellow\"\n      }\n    });\n  }\n  /**\n   * Print an error message.\n   * @example\n   * logger.error('something went wrong')\n   */\n  error(message, ...positionals) {\n    this.logEntry({\n      level: \"error\",\n      message,\n      positionals,\n      prefix: `\\u2716 ${this.prefix}`,\n      colors: {\n        timestamp: \"red\",\n        prefix: \"red\"\n      }\n    });\n  }\n  /**\n   * Execute the given callback only when the logging is enabled.\n   * This is skipped in its entirety and has no runtime cost otherwise.\n   * This executes regardless of the log level.\n   * @example\n   * logger.only(() => {\n   *   logger.info('additional info')\n   * })\n   */\n  only(callback) {\n    callback();\n  }\n  createEntry(level, message) {\n    return {\n      timestamp: /* @__PURE__ */ new Date(),\n      level,\n      message\n    };\n  }\n  logEntry(args) {\n    const {\n      level,\n      message,\n      prefix,\n      colors: customColors,\n      positionals = []\n    } = args;\n    const entry = this.createEntry(level, message);\n    const timestampColor = customColors?.timestamp || \"gray\";\n    const prefixColor = customColors?.prefix || \"gray\";\n    const colorize = {\n      timestamp: colors_exports[timestampColor],\n      prefix: colors_exports[prefixColor]\n    };\n    const write = this.getWriter(level);\n    write(\n      [colorize.timestamp(this.formatTimestamp(entry.timestamp))].concat(prefix != null ? colorize.prefix(prefix) : []).concat(serializeInput(message)).join(\" \"),\n      ...positionals.map(serializeInput)\n    );\n  }\n  formatTimestamp(timestamp) {\n    return `${timestamp.toLocaleTimeString(\n      \"en-GB\"\n    )}:${timestamp.getMilliseconds()}`;\n  }\n  getWriter(level) {\n    switch (level) {\n      case \"debug\":\n      case \"success\":\n      case \"info\": {\n        return log;\n      }\n      case \"warning\": {\n        return warn;\n      }\n      case \"error\": {\n        return error;\n      }\n    }\n  }\n};\nvar PerformanceEntry = class {\n  startTime;\n  endTime;\n  deltaTime;\n  constructor() {\n    this.startTime = performance.now();\n  }\n  measure() {\n    this.endTime = performance.now();\n    const deltaTime = this.endTime - this.startTime;\n    this.deltaTime = deltaTime.toFixed(2);\n  }\n};\nvar noop = () => void 0;\nfunction log(message, ...positionals) {\n  if (IS_NODE) {\n    process.stdout.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.log(message, ...positionals);\n}\nfunction warn(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.warn(message, ...positionals);\n}\nfunction error(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.error(message, ...positionals);\n}\nfunction getVariable(variableName) {\n  if (IS_NODE) {\n    return process.env[variableName];\n  }\n  return globalThis[variableName]?.toString();\n}\nfunction isDefinedAndNotEquals(value, expected) {\n  return value !== void 0 && value !== expected;\n}\nfunction serializeInput(message) {\n  if (typeof message === \"undefined\") {\n    return \"undefined\";\n  }\n  if (message === null) {\n    return \"null\";\n  }\n  if (typeof message === \"string\") {\n    return message;\n  }\n  if (typeof message === \"object\") {\n    return JSON.stringify(message);\n  }\n  return message.toString();\n}\nexport {\n  Logger\n};\n","import type { Emitter } from './Emitter'\n\nexport class MemoryLeakError extends Error {\n  constructor(\n    public readonly emitter: Emitter<any>,\n    public readonly type: string | number | symbol,\n    public readonly count: number\n  ) {\n    super(\n      `Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`\n    )\n    this.name = 'MaxListenersExceededWarning'\n  }\n}\n","import { MemoryLeakError } from './MemoryLeakError'\n\nexport type EventMap = {\n  [eventName: string]: Array<unknown>\n}\n\nexport type InternalEventNames = 'newListener' | 'removeListener'\n\nexport type InternalListener<Events extends EventMap> = Listener<\n  [eventName: keyof Events, listener: Listener<Array<unknown>>]\n>\n\nexport type Listener<Data extends Array<unknown>> = (...data: Data) => void\n\n/**\n * Node.js-compatible implementation of `EventEmitter`.\n *\n * @example\n * const emitter = new Emitter<{ hello: [string] }>()\n * emitter.on('hello', (name) => console.log(name))\n * emitter.emit('hello', 'John')\n */\nexport class Emitter<Events extends EventMap> {\n  private events: Map<keyof Events, Array<Listener<any>>>\n  private maxListeners: number\n  private hasWarnedAboutPotentialMemoryLeak: boolean\n\n  static defaultMaxListeners = 10\n\n  static listenerCount<Events extends EventMap>(\n    emitter: Emitter<EventMap>,\n    eventName: keyof Events\n  ): number {\n    return emitter.listenerCount<any>(eventName)\n  }\n\n  constructor() {\n    this.events = new Map()\n    this.maxListeners = Emitter.defaultMaxListeners\n    this.hasWarnedAboutPotentialMemoryLeak = false\n  }\n\n  private _emitInternalEvent(\n    internalEventName: InternalEventNames,\n    eventName: keyof Events,\n    listener: Listener<Array<unknown>>\n  ): void {\n    this.emit(\n      internalEventName,\n      // Anything to make TypeScript happy.\n      ...([eventName, listener] as Events['newListener'] &\n        Events['removeListener'])\n    )\n  }\n\n  private _getListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Array<unknown>>> {\n    // Always return a copy of the listeners array\n    // so they are fixed at the time of the \"_getListeners\" call.\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || []\n  }\n\n  private _removeListener<EventName extends keyof Events>(\n    listeners: Array<Listener<Events[EventName]>>,\n    listener: Listener<Events[EventName]>\n  ): Array<Listener<Events[EventName]>> {\n    const index = listeners.indexOf(listener)\n\n    if (index > -1) {\n      listeners.splice(index, 1)\n    }\n\n    return []\n  }\n\n  private _wrapOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): Listener<Events[EventName]> {\n    const onceListener = (...data: Events[keyof Events]) => {\n      this.removeListener(eventName, onceListener)\n\n      /**\n       * @note Return the result of the original listener.\n       * This way this wrapped preserves listeners that are async.\n       */\n      return listener.apply(this, data)\n    }\n\n    // Inherit the name of the original listener.\n    Object.defineProperty(onceListener, 'name', { value: listener.name })\n\n    return onceListener\n  }\n\n  public setMaxListeners(maxListeners: number): this {\n    this.maxListeners = maxListeners\n    return this\n  }\n\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n  public getMaxListeners(): number {\n    return this.maxListeners\n  }\n\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n  public eventNames(): Array<keyof Events> {\n    return Array.from(this.events.keys())\n  }\n\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n  public emit<EventName extends keyof Events>(\n    eventName: EventName,\n    ...data: Events[EventName]\n  ): boolean {\n    const listeners = this._getListeners(eventName)\n    listeners.forEach((listener) => {\n      listener.apply(this, data)\n    })\n\n    return listeners.length > 0\n  }\n\n  public addListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public addListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public addListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: InternalListener<Events> | Listener<Events[any]>\n  ): this {\n    // Emit the `newListener` event before adding the listener.\n    this._emitInternalEvent('newListener', eventName, listener)\n\n    const nextListeners = this._getListeners(eventName).concat(listener)\n    this.events.set(eventName, nextListeners)\n\n    if (\n      this.maxListeners > 0 &&\n      this.listenerCount(eventName) > this.maxListeners &&\n      !this.hasWarnedAboutPotentialMemoryLeak\n    ) {\n      this.hasWarnedAboutPotentialMemoryLeak = true\n\n      const memoryLeakWarning = new MemoryLeakError(\n        this,\n        eventName,\n        this.listenerCount(eventName)\n      )\n      console.warn(memoryLeakWarning)\n    }\n\n    return this\n  }\n\n  public on(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: 'removeListener' | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(eventName, listener)\n  }\n\n  public once(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: InternalEventNames | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public prependListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners)\n      this.events.set(eventName, nextListeners)\n    } else {\n      this.events.set(eventName, listeners.concat(listener))\n    }\n\n    return this\n  }\n\n  public prependOnceListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependOnceListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.prependListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public removeListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public removeListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public removeListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener)\n      this.events.set(eventName, listeners)\n\n      // Emit the `removeListener` event after removing the listener.\n      this._emitInternalEvent('removeListener', eventName, listener)\n    }\n\n    return this\n  }\n\n  public off(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public off<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n  public off(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.removeListener(eventName, listener)\n  }\n\n  public removeAllListeners(eventName?: InternalEventNames): this\n  public removeAllListeners<EventName extends keyof Events>(\n    eventName?: EventName\n  ): this\n  public removeAllListeners(\n    eventName?: InternalEventNames | keyof Events\n  ): this {\n    if (eventName) {\n      this.events.delete(eventName)\n    } else {\n      this.events.clear()\n    }\n\n    return this\n  }\n\n  public listeners(eventName: InternalEventNames): Array<Listener<any>>\n  public listeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>>\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n  public listeners(eventName: InternalEventNames | keyof Events) {\n    return Array.from(this._getListeners(eventName))\n  }\n\n  public listenerCount(eventName: InternalEventNames): number\n  public listenerCount<EventName extends keyof Events>(\n    eventName: EventName\n  ): number\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n  public listenerCount(eventName: InternalEventNames | keyof Events): number {\n    return this._getListeners(eventName).length\n  }\n\n  public rawListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>> {\n    return this.listeners(eventName)\n  }\n}\n","import { Logger } from '@open-draft/logger'\nimport { Emitter, Listener } from 'strict-event-emitter'\n\nexport type InterceptorEventMap = Record<string, any>\nexport type InterceptorSubscription = () => void\n\n/**\n * Request header name to detect when a single request\n * is being handled by nested interceptors (XHR -> ClientRequest).\n * Obscure by design to prevent collisions with user-defined headers.\n * Ideally, come up with the Interceptor-level mechanism for this.\n * @see https://github.com/mswjs/interceptors/issues/378\n */\nexport const INTERNAL_REQUEST_ID_HEADER_NAME =\n  'x-interceptors-internal-request-id'\n\nexport function getGlobalSymbol<V>(symbol: Symbol): V | undefined {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || undefined\n  )\n}\n\nfunction setGlobalSymbol(symbol: Symbol, value: any): void {\n  // @ts-ignore\n  globalThis[symbol] = value\n}\n\nexport function deleteGlobalSymbol(symbol: Symbol): void {\n  // @ts-ignore\n  delete globalThis[symbol]\n}\n\nexport enum InterceptorReadyState {\n  INACTIVE = 'INACTIVE',\n  APPLYING = 'APPLYING',\n  APPLIED = 'APPLIED',\n  DISPOSING = 'DISPOSING',\n  DISPOSED = 'DISPOSED',\n}\n\nexport type ExtractEventNames<Events extends Record<string, any>> =\n  Events extends Record<infer EventName, any> ? EventName : never\n\nexport class Interceptor<Events extends InterceptorEventMap> {\n  protected emitter: Emitter<Events>\n  protected subscriptions: Array<InterceptorSubscription>\n  protected logger: Logger\n\n  public readyState: InterceptorReadyState\n\n  constructor(private readonly symbol: symbol) {\n    this.readyState = InterceptorReadyState.INACTIVE\n\n    this.emitter = new Emitter()\n    this.subscriptions = []\n    this.logger = new Logger(symbol.description!)\n\n    // Do not limit the maximum number of listeners\n    // so not to limit the maximum amount of parallel events emitted.\n    this.emitter.setMaxListeners(0)\n\n    this.logger.info('constructing the interceptor...')\n  }\n\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  protected checkEnvironment(): boolean {\n    return true\n  }\n\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  public apply(): void {\n    const logger = this.logger.extend('apply')\n    logger.info('applying the interceptor...')\n\n    if (this.readyState === InterceptorReadyState.APPLIED) {\n      logger.info('intercepted already applied!')\n      return\n    }\n\n    const shouldApply = this.checkEnvironment()\n\n    if (!shouldApply) {\n      logger.info('the interceptor cannot be applied in this environment!')\n      return\n    }\n\n    this.readyState = InterceptorReadyState.APPLYING\n\n    // Whenever applying a new interceptor, check if it hasn't been applied already.\n    // This enables to apply the same interceptor multiple times, for example from a different\n    // interceptor, only proxying events but keeping the stubs in a single place.\n    const runningInstance = this.getInstance()\n\n    if (runningInstance) {\n      logger.info('found a running instance, reusing...')\n\n      // Proxy any listeners you set on this instance to the running instance.\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event)\n\n        // Add listeners to the running instance so they appear\n        // at the top of the event listeners list and are executed first.\n        runningInstance.emitter.addListener(event, listener)\n\n        // Ensure that once this interceptor instance is disposed,\n        // it removes all listeners it has appended to the running interceptor instance.\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener)\n          logger.info('removed proxied \"%s\" listener!', event)\n        })\n\n        return this\n      }\n\n      this.readyState = InterceptorReadyState.APPLIED\n\n      return\n    }\n\n    logger.info('no running instance found, setting up a new instance...')\n\n    // Setup the interceptor.\n    this.setup()\n\n    // Store the newly applied interceptor instance globally.\n    this.setInstance()\n\n    this.readyState = InterceptorReadyState.APPLIED\n  }\n\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  protected setup(): void {}\n\n  /**\n   * Listen to the interceptor's public events.\n   */\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    const logger = this.logger.extend('on')\n\n    if (\n      this.readyState === InterceptorReadyState.DISPOSING ||\n      this.readyState === InterceptorReadyState.DISPOSED\n    ) {\n      logger.info('cannot listen to events, already disposed!')\n      return this\n    }\n\n    logger.info('adding \"%s\" event listener:', event, listener)\n\n    this.emitter.on(event, listener)\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.once(event, listener)\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.off(event, listener)\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName\n  ): this {\n    this.emitter.removeAllListeners(event)\n    return this\n  }\n\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  public dispose(): void {\n    const logger = this.logger.extend('dispose')\n\n    if (this.readyState === InterceptorReadyState.DISPOSED) {\n      logger.info('cannot dispose, already disposed!')\n      return\n    }\n\n    logger.info('disposing the interceptor...')\n    this.readyState = InterceptorReadyState.DISPOSING\n\n    if (!this.getInstance()) {\n      logger.info('no interceptors running, skipping dispose...')\n      return\n    }\n\n    // Delete the global symbol as soon as possible,\n    // indicating that the interceptor is no longer running.\n    this.clearInstance()\n\n    logger.info('global symbol deleted:', getGlobalSymbol(this.symbol))\n\n    if (this.subscriptions.length > 0) {\n      logger.info('disposing of %d subscriptions...', this.subscriptions.length)\n\n      for (const dispose of this.subscriptions) {\n        dispose()\n      }\n\n      this.subscriptions = []\n\n      logger.info('disposed of all subscriptions!', this.subscriptions.length)\n    }\n\n    this.emitter.removeAllListeners()\n    logger.info('destroyed the listener!')\n\n    this.readyState = InterceptorReadyState.DISPOSED\n  }\n\n  private getInstance(): this | undefined {\n    const instance = getGlobalSymbol<this>(this.symbol)\n    this.logger.info('retrieved global instance:', instance?.constructor?.name)\n    return instance\n  }\n\n  private setInstance(): void {\n    setGlobalSymbol(this.symbol, this)\n    this.logger.info('set global instance!', this.symbol.description)\n  }\n\n  private clearInstance(): void {\n    deleteGlobalSymbol(this.symbol)\n    this.logger.info('cleared global instance!', this.symbol.description)\n  }\n}\n","/**\n * Generate a random ID string to represent a request.\n * @example\n * createRequestId()\n * // \"f774b6c9c600f\"\n */\nexport function createRequestId(): string {\n  return Math.random().toString(16).slice(2)\n}\n","import { EventMap, Listener } from 'strict-event-emitter'\nimport { Interceptor, ExtractEventNames } from './Interceptor'\n\nexport interface BatchInterceptorOptions<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> {\n  name: string\n  interceptors: InterceptorList\n}\n\nexport type ExtractEventMapType<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> = InterceptorList extends ReadonlyArray<infer InterceptorType>\n  ? InterceptorType extends Interceptor<infer EventMap>\n    ? EventMap\n    : never\n  : never\n\n/**\n * A batch interceptor that exposes a single interface\n * to apply and operate with multiple interceptors at once.\n */\nexport class BatchInterceptor<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>,\n  Events extends EventMap = ExtractEventMapType<InterceptorList>\n> extends Interceptor<Events> {\n  static symbol: symbol\n\n  private interceptors: InterceptorList\n\n  constructor(options: BatchInterceptorOptions<InterceptorList>) {\n    BatchInterceptor.symbol = Symbol(options.name)\n    super(BatchInterceptor.symbol)\n    this.interceptors = options.interceptors\n  }\n\n  protected setup() {\n    const logger = this.logger.extend('setup')\n\n    logger.info('applying all %d interceptors...', this.interceptors.length)\n\n    for (const interceptor of this.interceptors) {\n      logger.info('applying \"%s\" interceptor...', interceptor.constructor.name)\n      interceptor.apply()\n\n      logger.info('adding interceptor dispose subscription')\n      this.subscriptions.push(() => interceptor.dispose())\n    }\n  }\n\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    // Instead of adding a listener to the batch interceptor,\n    // propagate the listener to each of the individual interceptors.\n    for (const interceptor of this.interceptors) {\n      interceptor.on(event, listener)\n    }\n\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.once(event, listener)\n    }\n\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.off(event, listener)\n    }\n\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName | undefined\n  ): this {\n    for (const interceptors of this.interceptors) {\n      interceptors.removeAllListeners(event)\n    }\n\n    return this\n  }\n}\n","/**\n * Removes query parameters and hashes from a given URL.\n */\nexport function getCleanUrl(url: URL, isAbsolute: boolean = true): string {\n  return [isAbsolute && url.origin, url.pathname].filter(Boolean).join('')\n}\n","import { FetchResponse } from '@mswjs/interceptors'\nimport type { Emitter } from 'rettime'\nimport type { SetupWorkerInternalContext } from '../glossary'\nimport { deserializeRequest } from '../../utils/deserializeRequest'\n\nexport function createResponseListener(\n  context: SetupWorkerInternalContext,\n): Emitter.ListenerType<typeof context.workerChannel, 'RESPONSE'> {\n  return (event) => {\n    const responseMessage = event.data\n    const request = deserializeRequest(responseMessage.request)\n\n    /**\n     * CORS requests with `mode: \"no-cors\"` result in \"opaque\" responses.\n     * That kind of responses cannot be manipulated in JavaScript due\n     * to the security considerations.\n     * @see https://fetch.spec.whatwg.org/#concept-filtered-response-opaque\n     * @see https://github.com/mswjs/msw/issues/529\n     */\n    if (responseMessage.response.type?.includes('opaque')) {\n      return\n    }\n\n    const response =\n      responseMessage.response.status === 0\n        ? Response.error()\n        : new FetchResponse(\n            /**\n             * Responses may be streams here, but when we create a response object\n             * with null-body status codes, like 204, 205, 304 Response will\n             * throw when passed a non-null body, so ensure it's null here\n             * for those codes\n             */\n            FetchResponse.isResponseWithBody(responseMessage.response.status)\n              ? responseMessage.response.body\n              : null,\n            {\n              ...responseMessage,\n              /**\n               * Set response URL if it's not set already.\n               * @see https://github.com/mswjs/msw/issues/2030\n               * @see https://developer.mozilla.org/en-US/docs/Web/API/Response/url\n               */\n              url: request.url,\n            },\n          )\n\n    context.emitter.emit(\n      responseMessage.isMockedResponse ? 'response:mocked' : 'response:bypass',\n      {\n        requestId: responseMessage.request.id,\n        request,\n        response,\n      },\n    )\n  }\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport { StartOptions } from '../../glossary'\n\nexport function validateWorkerScope(\n  registration: ServiceWorkerRegistration,\n  options?: StartOptions,\n): void {\n  if (!options?.quiet && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(\n      `\\\nCannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.\\\n`,\n    )\n  }\n}\n","import { invariant } from 'outvariant'\nimport { isNodeProcess } from 'is-node-process'\nimport type {\n  SetupWorkerInternalContext,\n  StartReturnType,\n  StartOptions,\n  SetupWorker,\n} from './glossary'\nimport { RequestHandler } from '~/core/handlers/RequestHandler'\nimport { DEFAULT_START_OPTIONS } from './start/utils/prepareStartHandler'\nimport { createStartHandler } from './start/createStartHandler'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { SetupApi } from '~/core/SetupApi'\nimport { mergeRight } from '~/core/utils/internal/mergeRight'\nimport type { LifeCycleEventsMap } from '~/core/sharedOptions'\nimport type { WebSocketHandler } from '~/core/handlers/WebSocketHandler'\nimport { supportsReadableStreamTransfer } from '../utils/supportsReadableStreamTransfer'\nimport { webSocketInterceptor } from '~/core/ws/webSocketInterceptor'\nimport { handleWebSocketEvent } from '~/core/ws/handleWebSocketEvent'\nimport { attachWebSocketLogger } from '~/core/ws/utils/attachWebSocketLogger'\nimport { WorkerChannel } from '../utils/workerChannel'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { createFallbackRequestListener } from './start/createFallbackRequestListener'\nimport { printStartMessage } from './start/utils/printStartMessage'\nimport { printStopMessage } from './stop/utils/printStopMessage'\n\nexport class SetupWorkerApi\n  extends SetupApi<LifeCycleEventsMap>\n  implements SetupWorker\n{\n  private context: SetupWorkerInternalContext\n\n  constructor(...handlers: Array<RequestHandler | WebSocketHandler>) {\n    super(...handlers)\n\n    invariant(\n      !isNodeProcess(),\n      devUtils.formatMessage(\n        'Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.',\n      ),\n    )\n\n    this.context = this.createWorkerContext()\n  }\n\n  private createWorkerContext(): SetupWorkerInternalContext {\n    const workerPromise = new DeferredPromise<ServiceWorker>()\n\n    return {\n      // Mocking is not considered enabled until the worker\n      // signals back the successful activation event.\n      isMockingEnabled: false,\n      startOptions: null as any,\n      workerPromise,\n      registration: undefined,\n      getRequestHandlers: () => {\n        return this.handlersController.currentHandlers()\n      },\n      emitter: this.emitter,\n      workerChannel: new WorkerChannel({\n        worker: workerPromise,\n      }),\n      supports: {\n        serviceWorkerApi:\n          'serviceWorker' in navigator && location.protocol !== 'file:',\n        readableStreamTransfer: supportsReadableStreamTransfer(),\n      },\n    }\n  }\n\n  public async start(options: StartOptions = {}): StartReturnType {\n    if ('waitUntilReady' in options) {\n      devUtils.warn(\n        'The \"waitUntilReady\" option has been deprecated. Please remove it from this \"worker.start()\" call. Follow the recommended Browser integration (https://mswjs.io/docs/integrations/browser) to eliminate any race conditions between the Service Worker registration and any requests made by your application on initial render.',\n      )\n    }\n\n    // Warn the developer on multiple \"worker.start()\" calls.\n    // While this will not affect the worker in any way,\n    // it likely indicates an issue with the developer's code.\n    if (this.context.isMockingEnabled) {\n      devUtils.warn(\n        `Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`,\n      )\n      return this.context.registration\n    }\n\n    this.context.workerStoppedAt = undefined\n\n    this.context.startOptions = mergeRight(\n      DEFAULT_START_OPTIONS,\n      options,\n    ) as SetupWorkerInternalContext['startOptions']\n\n    // Enable the WebSocket interception.\n    handleWebSocketEvent({\n      getUnhandledRequestStrategy: () => {\n        return this.context.startOptions.onUnhandledRequest\n      },\n      getHandlers: () => {\n        return this.handlersController.currentHandlers()\n      },\n      onMockedConnection: (connection) => {\n        if (!this.context.startOptions.quiet) {\n          // Attach the logger for mocked connections since\n          // those won't be visible in the browser's devtools.\n          attachWebSocketLogger(connection)\n        }\n      },\n      onPassthroughConnection() {},\n    })\n    webSocketInterceptor.apply()\n\n    this.subscriptions.push(() => {\n      webSocketInterceptor.dispose()\n    })\n\n    // Use a fallback interception algorithm in the environments\n    // where the Service Worker API isn't supported.\n    if (!this.context.supports.serviceWorkerApi) {\n      const fallbackInterceptor = createFallbackRequestListener(\n        this.context,\n        this.context.startOptions,\n      )\n\n      this.subscriptions.push(() => {\n        fallbackInterceptor.dispose()\n      })\n\n      this.context.isMockingEnabled = true\n\n      printStartMessage({\n        message: 'Mocking enabled (fallback mode).',\n        quiet: this.context.startOptions.quiet,\n      })\n\n      return undefined\n    }\n\n    const startHandler = createStartHandler(this.context)\n    const registration = await startHandler(this.context.startOptions, options)\n\n    this.context.isMockingEnabled = true\n\n    return registration\n  }\n\n  public stop(): void {\n    super.dispose()\n\n    if (!this.context.isMockingEnabled) {\n      devUtils.warn(\n        'Found a redundant \"worker.stop()\" call. Notice that stopping the worker after it has already been stopped has no effect. Consider removing this \"worker.stop()\" call.',\n      )\n      return\n    }\n\n    this.context.isMockingEnabled = false\n    this.context.workerStoppedAt = Date.now()\n    this.context.emitter.removeAllListeners()\n\n    if (this.context.supports.serviceWorkerApi) {\n      this.context.workerChannel.removeAllListeners('RESPONSE')\n      window.clearInterval(this.context.keepAliveInterval)\n    }\n\n    // Post the internal stop message on the window\n    // to let any logic know when the worker has stopped.\n    // E.g. the WebSocket client manager needs this to know\n    // when to clear its in-memory clients list.\n    window.postMessage({ type: 'msw/worker:stop' })\n\n    printStopMessage({\n      quiet: this.context.startOptions?.quiet,\n    })\n  }\n}\n\n/**\n * Sets up a requests interception in the browser with the given request handlers.\n * @param {RequestHandler[]} handlers List of request handlers.\n *\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker()` API reference}\n */\nexport function setupWorker(\n  ...handlers: Array<RequestHandler | WebSocketHandler>\n): SetupWorker {\n  return new SetupWorkerApi(...handlers)\n}\n","/**\n * Returns a boolean indicating whether the current browser\n * supports `ReadableStream` as a `Transferable` when posting\n * messages.\n */\nexport function supportsReadableStreamTransfer() {\n  try {\n    const stream = new ReadableStream({\n      start: (controller) => controller.close(),\n    })\n    const message = new MessageChannel()\n    message.port1.postMessage(stream, [stream])\n    return true\n  } catch {\n    return false\n  }\n}\n","export type DefaultEventMap = {\n  [eventType: string]: TypedEvent<any, any>\n}\n\nexport interface TypedEvent<\n  DataType = void,\n  ReturnType = any,\n  EventType extends string = string,\n> extends Omit<MessageEvent<DataType>, 'type'> {\n  type: EventType\n}\n\nconst kDefaultPrevented = Symbol('kDefaultPrevented')\nconst kPropagationStopped = Symbol('kPropagationStopped')\nconst kImmediatePropagationStopped = Symbol('kImmediatePropagationStopped')\n\nexport class TypedEvent<\n    DataType = void,\n    ReturnType = any,\n    EventType extends string = string,\n  >\n  extends MessageEvent<DataType>\n  implements TypedEvent<DataType, ReturnType, EventType>\n{\n  /**\n   * @note Keep a placeholder property with the return type\n   * because the type must be set somewhere in order to be\n   * correctly associated and inferred from the event.\n   */\n  #returnType: ReturnType;\n\n  [kDefaultPrevented]: boolean;\n  [kPropagationStopped]?: Emitter<any>;\n  [kImmediatePropagationStopped]?: boolean\n\n  constructor(\n    ...args: [DataType] extends [void]\n      ? [type: EventType]\n      : [type: EventType, init: { data: DataType }]\n  ) {\n    super(args[0], args[1])\n    this[kDefaultPrevented] = false\n  }\n\n  get defaultPrevented(): boolean {\n    return this[kDefaultPrevented]\n  }\n\n  public preventDefault(): void {\n    super.preventDefault()\n    this[kDefaultPrevented] = true\n  }\n\n  public stopImmediatePropagation(): void {\n    /**\n     * @note Despite `.stopPropagation()` and `.stopImmediatePropagation()` being defined\n     * in Node.js, they do nothing. It is safe to re-define them.\n     */\n    super.stopImmediatePropagation()\n    this[kImmediatePropagationStopped] = true\n  }\n}\n\n/**\n * Brands a TypedEvent or its subclass while preserving its (narrower) type.\n */\ntype Brand<Event extends TypedEvent, EventType extends string> = Event & {\n  type: EventType\n}\n\ntype InferEventMap<Target extends Emitter<any>> = Target extends Emitter<\n  infer EventMap\n>\n  ? EventMap\n  : never\n\ntype InternalListenersMap<\n  Target extends Emitter<any>,\n  EventMap extends DefaultEventMap = InferEventMap<Target>,\n  EventType extends string = keyof EventMap & string,\n> = Record<\n  keyof EventMap,\n  Array<Emitter.ListenerType<Target, EventType, EventMap>>\n>\n\nexport type TypedListenerOptions = {\n  once?: boolean\n  signal?: AbortSignal\n}\n\nconst kListenerOptions = Symbol('kListenerOptions')\n\nexport namespace Emitter {\n  /**\n   * Returns an appropriate `Event` type for the given event type.\n   *\n   * @example\n   * const emitter = new Emitter<{ greeting: TypedEvent<string> }>()\n   * type GreetingEvent = Emitter.InferEventType<typeof emitter, 'greeting'>\n   * // TypedEvent<string>\n   */\n  export type EventType<\n    Target extends Emitter<any>,\n    EventType extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > = Brand<EventMap[EventType], EventType>\n\n  export type EventDataType<\n    Target extends Emitter<any>,\n    EventType extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > = EventMap[EventType] extends TypedEvent<infer DataType> ? DataType : never\n\n  /**\n   * Returns the listener type for the given event type.\n   *\n   * @example\n   * const emitter = new Emitter<{ getTotalPrice: TypedEvent<Cart, number> }>()\n   * type Listener = Emitter.ListenerType<typeof emitter, 'getTotalPrice'>\n   * // (event: TypedEvent<Cart>) => number\n   */\n  export type ListenerType<\n    Target extends Emitter<any>,\n    Type extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > = (\n    event: Emitter.EventType<Target, Type, EventMap>,\n  ) => Emitter.ListenerReturnType<Target, Type, EventMap> extends [void]\n    ? void\n    : Emitter.ListenerReturnType<Target, Type, EventMap>\n\n  /**\n   * Returns the return type of the listener for the given event type.\n   *\n   * @example\n   * const emitter = new Emitter<{ getTotalPrice: TypedEvent<Cart, number> }>()\n   * type ListenerReturnType = Emitter.InferListenerReturnType<typeof emitter, 'getTotalPrice'>\n   * // number\n   */\n  export type ListenerReturnType<\n    Target extends Emitter<any>,\n    EventType extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > = EventMap[EventType] extends TypedEvent<unknown, infer ReturnType>\n    ? ReturnType\n    : never\n}\n\nexport class Emitter<EventMap extends DefaultEventMap> {\n  #listeners: InternalListenersMap<typeof this, EventMap>\n\n  constructor() {\n    this.#listeners = {} as InternalListenersMap<typeof this, EventMap>\n  }\n\n  /**\n   * Adds a listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  public on<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options?: TypedListenerOptions,\n  ): typeof this {\n    return this.#addListener(type, listener, options)\n  }\n\n  /**\n   * Adds a one-time listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  public once<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options?: Omit<TypedListenerOptions, 'once'>,\n  ): typeof this {\n    return this.on(type, listener, { ...(options || {}), once: true })\n  }\n\n  /**\n   * Prepends a listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  public earlyOn<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options?: TypedListenerOptions,\n  ): typeof this {\n    return this.#addListener(type, listener, options, 'prepend')\n  }\n\n  /**\n   * Prepends a one-time listener for the given event type.\n   */\n  public earlyOnce<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options?: Omit<TypedListenerOptions, 'once'>,\n  ): typeof this {\n    return this.earlyOn(type, listener, { ...(options || {}), once: true })\n  }\n\n  /**\n   * Emits the given typed event.\n   *\n   * @returns {boolean} Returns `true` if the event had any listeners, `false` otherwise.\n   */\n  public emit<EventType extends keyof EventMap & string>(\n    event: Brand<EventMap[EventType], EventType>,\n  ): boolean {\n    if (this.listenerCount(event.type) === 0) {\n      return false\n    }\n\n    const proxiedEvent = this.#proxyEvent(event)\n\n    for (const listener of this.#listeners[event.type]) {\n      if (\n        proxiedEvent.event[kPropagationStopped] != null &&\n        proxiedEvent.event[kPropagationStopped] !== this\n      ) {\n        return false\n      }\n\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break\n      }\n\n      this.#callListener(proxiedEvent.event, listener)\n    }\n\n    proxiedEvent.revoke()\n\n    return true\n  }\n\n  /**\n   * Emits the given typed event and returns a promise that resolves\n   * when all the listeners for that event have settled.\n   *\n   * @returns {Promise<Array<Emitter.ListenerReturnType>>} A promise that resolves\n   * with the return values of all listeners.\n   */\n  public async emitAsPromise<EventType extends keyof EventMap & string>(\n    event: Brand<EventMap[EventType], EventType>,\n  ): Promise<\n    Array<Emitter.ListenerReturnType<typeof this, EventType, EventMap>>\n  > {\n    if (this.listenerCount(event.type) === 0) {\n      return []\n    }\n\n    const pendingListeners: Array<\n      Promise<Emitter.ListenerReturnType<typeof this, EventType, EventMap>>\n    > = []\n\n    const proxiedEvent = this.#proxyEvent(event)\n\n    for (const listener of this.#listeners[event.type]) {\n      if (\n        proxiedEvent.event[kPropagationStopped] != null &&\n        proxiedEvent.event[kPropagationStopped] !== this\n      ) {\n        return []\n      }\n\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break\n      }\n\n      pendingListeners.push(\n        // Awaiting individual listeners guarantees their call order.\n        await Promise.resolve(this.#callListener(proxiedEvent.event, listener)),\n      )\n    }\n\n    proxiedEvent.revoke()\n\n    return Promise.allSettled(pendingListeners).then((results) => {\n      return results.map((result) =>\n        result.status === 'fulfilled' ? result.value : result.reason,\n      )\n    })\n  }\n\n  /**\n   * Emits the given event and returns a generator that yields\n   * the result of each listener in the order of their registration.\n   * This way, you stop exhausting the listeners once you get the expected value.\n   */\n  public *emitAsGenerator<EventType extends keyof EventMap & string>(\n    event: Brand<EventMap[EventType], EventType>,\n  ): Generator<Emitter.ListenerReturnType<typeof this, EventType, EventMap>> {\n    if (this.listenerCount(event.type) === 0) {\n      return\n    }\n\n    const proxiedEvent = this.#proxyEvent(event)\n\n    for (const listener of this.#listeners[event.type]) {\n      if (\n        proxiedEvent.event[kPropagationStopped] != null &&\n        proxiedEvent.event[kPropagationStopped] !== this\n      ) {\n        return\n      }\n\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break\n      }\n\n      yield this.#callListener(proxiedEvent.event, listener)\n    }\n\n    proxiedEvent.revoke()\n  }\n\n  /**\n   * Removes a listener for the given event type.\n   */\n  public removeListener<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n  ): void {\n    if (this.listenerCount(type) === 0) {\n      return\n    }\n\n    const nextListeners: Array<\n      Emitter.ListenerType<typeof this, EventType, EventMap>\n    > = []\n\n    for (const existingListener of this.#listeners[type]) {\n      if (existingListener !== listener) {\n        nextListeners.push(existingListener)\n      }\n    }\n\n    this.#listeners[type] = nextListeners\n  }\n\n  /**\n   * Removes all listeners for the given event type.\n   * If no event type is provided, removes all existing listeners.\n   */\n  public removeAllListeners<EventType extends keyof EventMap & string>(\n    type?: EventType,\n  ): void {\n    if (type == null) {\n      this.#listeners = {} as InternalListenersMap<typeof this>\n      return\n    }\n\n    this.#listeners[type] = []\n  }\n\n  /**\n   * Returns the list of listeners for the given event type.\n   * If no even type is provided, returns all listeners.\n   */\n  public listeners<EventType extends keyof EventMap & string>(\n    type?: EventType,\n  ): Array<Emitter.ListenerType<typeof this, EventType, EventMap>> {\n    if (type == null) {\n      return Object.values(this.#listeners).flat()\n    }\n\n    return this.#listeners[type] || []\n  }\n\n  /**\n   * Returns the number of listeners for the given event type.\n   * If no even type is provided, returns the total number of listeners.\n   */\n  public listenerCount<EventType extends keyof EventMap & string>(\n    type?: EventType,\n  ): number {\n    return this.listeners(type).length\n  }\n\n  #addListener<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options: TypedListenerOptions | undefined,\n    insertMode: 'append' | 'prepend' = 'append',\n  ): typeof this {\n    this.#listeners[type] ??= []\n\n    if (insertMode === 'prepend') {\n      this.#listeners[type].unshift(listener)\n    } else {\n      this.#listeners[type].push(listener)\n    }\n\n    if (options) {\n      Object.defineProperty(listener, kListenerOptions, {\n        value: options,\n        enumerable: false,\n        writable: false,\n      })\n\n      if (options.signal) {\n        options.signal.addEventListener(\n          'abort',\n          () => {\n            this.removeListener(type, listener)\n          },\n          { once: true },\n        )\n      }\n    }\n\n    return this\n  }\n\n  #proxyEvent<Event extends TypedEvent>(\n    event: Event,\n  ): { event: Event; revoke: () => void } {\n    const { stopPropagation } = event\n\n    event.stopPropagation = new Proxy(event.stopPropagation, {\n      apply: (target, thisArg, argArray) => {\n        event[kPropagationStopped] = this\n        return Reflect.apply(target, thisArg, argArray)\n      },\n    })\n\n    return {\n      event,\n      revoke() {\n        event.stopPropagation = stopPropagation\n      },\n    }\n  }\n\n  #callListener<EventType extends keyof EventMap & string>(\n    event: Event,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap> & {\n      [kListenerOptions]?: TypedListenerOptions\n    },\n  ) {\n    const returnValue = listener.call(this, event)\n\n    if (listener[kListenerOptions]?.once) {\n      this.removeListener(event.type, listener)\n    }\n\n    return returnValue\n  }\n}\n","import { Emitter, TypedEvent } from 'rettime'\nimport { isObject } from '~/core/utils/internal/isObject'\nimport type { StringifiedResponse } from '../setupWorker/glossary'\n\nexport interface WorkerChannelOptions {\n  worker: Promise<ServiceWorker>\n}\n\nexport type WorkerChannelEventMap = {\n  REQUEST: WorkerEvent<IncomingWorkerRequest>\n  RESPONSE: WorkerEvent<IncomingWorkerResponse>\n  MOCKING_ENABLED: WorkerEvent<{\n    client: {\n      id: string\n      frameType: string\n    }\n  }>\n  INTEGRITY_CHECK_RESPONSE: WorkerEvent<{\n    packageVersion: string\n    checksum: string\n  }>\n  KEEPALIVE_RESPONSE: TypedEvent<never>\n}\n\n/**\n * Request representation received from the worker message event.\n */\nexport interface IncomingWorkerRequest\n  extends Omit<\n    Request,\n    | 'text'\n    | 'body'\n    | 'json'\n    | 'blob'\n    | 'arrayBuffer'\n    | 'formData'\n    | 'clone'\n    | 'signal'\n    | 'isHistoryNavigation'\n    | 'isReloadNavigation'\n  > {\n  /**\n   * Unique ID of the request generated once the request is\n   * intercepted by the \"fetch\" event in the Service Worker.\n   */\n  id: string\n  interceptedAt: number\n  body?: ArrayBuffer | null\n}\n\ntype IncomingWorkerResponse = {\n  isMockedResponse: boolean\n  request: IncomingWorkerRequest\n  response: Pick<\n    Response,\n    'type' | 'ok' | 'status' | 'statusText' | 'body' | 'headers' | 'redirected'\n  >\n}\n\nexport type WorkerEventResponse = {\n  MOCK_RESPONSE: [\n    data: StringifiedResponse,\n    transfer?: [ReadableStream<Uint8Array>],\n  ]\n  PASSTHROUGH: []\n}\n\nexport class WorkerEvent<\n  DataType,\n  ReturnType = any,\n  EventType extends string = string,\n> extends TypedEvent<DataType, ReturnType, EventType> {\n  #workerEvent: MessageEvent\n\n  constructor(workerEvent: MessageEvent) {\n    const type = workerEvent.data.type as EventType\n    const data = workerEvent.data.payload as DataType\n\n    /**\n     * @note This is the only place we're mapping { type, payload }\n     * message structure of the worker. The client references the\n     * payload via `event.data`.\n     */\n    super(\n      // @ts-expect-error Troublesome `TypedEvent` extension.\n      type,\n      { data },\n    )\n    this.#workerEvent = workerEvent\n  }\n\n  get ports() {\n    return this.#workerEvent.ports\n  }\n\n  /**\n   * Reply directly to this event using its `MessagePort`.\n   */\n  public postMessage<Type extends keyof WorkerEventResponse>(\n    type: Type,\n    ...rest: WorkerEventResponse[Type]\n  ): void {\n    this.#workerEvent.ports[0].postMessage(\n      { type, data: rest[0] },\n      { transfer: rest[1] },\n    )\n  }\n}\n\n/**\n * Map of the events that can be sent to the Service Worker\n * from any execution context.\n */\ntype OutgoingWorkerEvents =\n  | 'MOCK_ACTIVATE'\n  | 'INTEGRITY_CHECK_REQUEST'\n  | 'KEEPALIVE_REQUEST'\n  | 'CLIENT_CLOSED'\n\nexport class WorkerChannel extends Emitter<WorkerChannelEventMap> {\n  constructor(protected readonly options: WorkerChannelOptions) {\n    super()\n\n    navigator.serviceWorker.addEventListener('message', async (event) => {\n      const worker = await this.options.worker\n\n      if (event.source != null && event.source !== worker) {\n        return\n      }\n\n      if (event.data && isObject(event.data) && 'type' in event.data) {\n        this.emit(new WorkerEvent<any, any, any>(event))\n      }\n    })\n  }\n\n  /**\n   * Send data to the Service Worker controlling this client.\n   * This triggers the `message` event listener on ServiceWorkerGlobalScope.\n   */\n  public postMessage(type: OutgoingWorkerEvents): void {\n    this.options.worker.then((worker) => {\n      worker.postMessage(type)\n    })\n  }\n}\n","import { invariant } from 'outvariant'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { InterceptorError } from './InterceptorError'\n\nconst kRequestHandled = Symbol('kRequestHandled')\nexport const kResponsePromise = Symbol('kResponsePromise')\n\nexport class RequestController {\n  /**\n   * Internal response promise.\n   * Available only for the library internals to grab the\n   * response instance provided by the developer.\n   * @note This promise cannot be rejected. It's either infinitely\n   * pending or resolved with whichever Response was passed to `respondWith()`.\n   */\n  [kResponsePromise]: DeferredPromise<\n    Response | Record<string, any> | undefined\n  >;\n\n  /**\n   * Internal flag indicating if this request has been handled.\n   * @note The response promise becomes \"fulfilled\" on the next tick.\n   */\n  [kRequestHandled]: boolean\n\n  constructor(private request: Request) {\n    this[kRequestHandled] = false\n    this[kResponsePromise] = new DeferredPromise()\n  }\n\n  /**\n   * Respond to this request with the given `Response` instance.\n   * @example\n   * controller.respondWith(new Response())\n   * controller.respondWith(Response.json({ id }))\n   * controller.respondWith(Response.error())\n   */\n  public respondWith(response: Response): void {\n    invariant.as(\n      InterceptorError,\n      !this[kRequestHandled],\n      'Failed to respond to the \"%s %s\" request: the \"request\" event has already been handled.',\n      this.request.method,\n      this.request.url\n    )\n\n    this[kRequestHandled] = true\n    this[kResponsePromise].resolve(response)\n\n    /**\n     * @note The request controller doesn't do anything\n     * apart from letting the interceptor await the response\n     * provided by the developer through the response promise.\n     * Each interceptor implements the actual respondWith/errorWith\n     * logic based on that interceptor's needs.\n     */\n  }\n\n  /**\n   * Error this request with the given reason.\n   *\n   * @example\n   * controller.errorWith()\n   * controller.errorWith(new Error('Oops!'))\n   * controller.errorWith({ message: 'Oops!'})\n   */\n  public errorWith(reason?: Error | Record<string, any>): void {\n    invariant.as(\n      InterceptorError,\n      !this[kRequestHandled],\n      'Failed to error the \"%s %s\" request: the \"request\" event has already been handled.',\n      this.request.method,\n      this.request.url\n    )\n\n    this[kRequestHandled] = true\n\n    /**\n     * @note Resolve the response promise, not reject.\n     * This helps us differentiate between unhandled exceptions\n     * and intended errors (\"errorWith\") while waiting for the response.\n     */\n    this[kResponsePromise].resolve(reason)\n  }\n}\n","export class InterceptorError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = 'InterceptorError'\n    Object.setPrototypeOf(this, InterceptorError.prototype)\n  }\n}\n","import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Emits an event on the given emitter but executes\n * the listeners sequentially. This accounts for asynchronous\n * listeners (e.g. those having \"sleep\" and handling the request).\n */\nexport async function emitAsync<\n  Events extends EventMap,\n  EventName extends keyof Events\n>(\n  emitter: Emitter<Events>,\n  eventName: EventName,\n  ...data: Events[EventName]\n): Promise<void> {\n  const listners = emitter.listeners(eventName)\n\n  if (listners.length === 0) {\n    return\n  }\n\n  for (const listener of listners) {\n    await listener.apply(emitter, data)\n  }\n}\n","import type { Emitter } from 'strict-event-emitter'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { until } from '@open-draft/until'\nimport type { HttpRequestEventMap } from '../glossary'\nimport { emitAsync } from './emitAsync'\nimport { kResponsePromise, RequestController } from '../RequestController'\nimport {\n  createServerErrorResponse,\n  isResponseError,\n  isResponseLike,\n  ResponseError,\n} from './responseUtils'\nimport { InterceptorError } from '../InterceptorError'\nimport { isNodeLikeError } from './isNodeLikeError'\nimport { isObject } from './isObject'\n\ninterface HandleRequestOptions {\n  requestId: string\n  request: Request\n  emitter: Emitter<HttpRequestEventMap>\n  controller: RequestController\n\n  /**\n   * Called when the request has been handled\n   * with the given `Response` instance.\n   */\n  onResponse: (response: Response) => void | Promise<void>\n\n  /**\n   * Called when the request has been handled\n   * with the given `Response.error()` instance.\n   */\n  onRequestError: (response: ResponseError) => void\n\n  /**\n   * Called when an unhandled error happens during the\n   * request handling. This is never a thrown error/response.\n   */\n  onError: (error: unknown) => void\n}\n\n/**\n * @returns {Promise<boolean>} Indicates whether the request has been handled.\n */\nexport async function handleRequest(\n  options: HandleRequestOptions\n): Promise<boolean> {\n  const handleResponse = async (\n    response: Response | Error | Record<string, any>\n  ) => {\n    if (response instanceof Error) {\n      options.onError(response)\n      return true\n    }\n\n    // Handle \"Response.error()\" instances.\n    if (isResponseError(response)) {\n      options.onRequestError(response)\n      return true\n    }\n\n    /**\n     * Handle normal responses or response-like objects.\n     * @note This must come before the arbitrary object check\n     * since Response instances are, in fact, objects.\n     */\n    if (isResponseLike(response)) {\n      await options.onResponse(response)\n      return true\n    }\n\n    // Handle arbitrary objects provided to `.errorWith(reason)`.\n    if (isObject(response)) {\n      options.onError(response)\n      return true\n    }\n\n    return false\n  }\n\n  const handleResponseError = async (error: unknown): Promise<boolean> => {\n    // Forward the special interceptor error instances\n    // to the developer. These must not be handled in any way.\n    if (error instanceof InterceptorError) {\n      throw result.error\n    }\n\n    // Support mocking Node.js-like errors.\n    if (isNodeLikeError(error)) {\n      options.onError(error)\n      return true\n    }\n\n    // Handle thrown responses.\n    if (error instanceof Response) {\n      return await handleResponse(error)\n    }\n\n    return false\n  }\n\n  // Add the last \"request\" listener to check if the request\n  // has been handled in any way. If it hasn't, resolve the\n  // response promise with undefined.\n  options.emitter.once('request', ({ requestId: pendingRequestId }) => {\n    if (pendingRequestId !== options.requestId) {\n      return\n    }\n\n    if (options.controller[kResponsePromise].state === 'pending') {\n      options.controller[kResponsePromise].resolve(undefined)\n    }\n  })\n\n  const requestAbortPromise = new DeferredPromise<void, unknown>()\n\n  /**\n   * @note `signal` is not always defined in React Native.\n   */\n  if (options.request.signal) {\n    if (options.request.signal.aborted) {\n      requestAbortPromise.reject(options.request.signal.reason)\n    } else {\n      options.request.signal.addEventListener(\n        'abort',\n        () => {\n          requestAbortPromise.reject(options.request.signal.reason)\n        },\n        { once: true }\n      )\n    }\n  }\n\n  const result = await until(async () => {\n    // Emit the \"request\" event and wait until all the listeners\n    // for that event are finished (e.g. async listeners awaited).\n    // By the end of this promise, the developer cannot affect the\n    // request anymore.\n    const requestListenersPromise = emitAsync(options.emitter, 'request', {\n      requestId: options.requestId,\n      request: options.request,\n      controller: options.controller,\n    })\n\n    await Promise.race([\n      // Short-circuit the request handling promise if the request gets aborted.\n      requestAbortPromise,\n      requestListenersPromise,\n      options.controller[kResponsePromise],\n    ])\n\n    // The response promise will settle immediately once\n    // the developer calls either \"respondWith\" or \"errorWith\".\n    return await options.controller[kResponsePromise]\n  })\n\n  // Handle the request being aborted while waiting for the request listeners.\n  if (requestAbortPromise.state === 'rejected') {\n    options.onError(requestAbortPromise.rejectionReason)\n    return true\n  }\n\n  if (result.error) {\n    // Handle the error during the request listener execution.\n    // These can be thrown responses or request errors.\n    if (await handleResponseError(result.error)) {\n      return true\n    }\n\n    // If the developer has added \"unhandledException\" listeners,\n    // allow them to handle the error. They can translate it to a\n    // mocked response, network error, or forward it as-is.\n    if (options.emitter.listenerCount('unhandledException') > 0) {\n      // Create a new request controller just for the unhandled exception case.\n      // This is needed because the original controller might have been already\n      // interacted with (e.g. \"respondWith\" or \"errorWith\" called on it).\n      const unhandledExceptionController = new RequestController(\n        options.request\n      )\n\n      await emitAsync(options.emitter, 'unhandledException', {\n        error: result.error,\n        request: options.request,\n        requestId: options.requestId,\n        controller: unhandledExceptionController,\n      }).then(() => {\n        // If all the \"unhandledException\" listeners have finished\n        // but have not handled the response in any way, preemptively\n        // resolve the pending response promise from the new controller.\n        // This prevents it from hanging forever.\n        if (\n          unhandledExceptionController[kResponsePromise].state === 'pending'\n        ) {\n          unhandledExceptionController[kResponsePromise].resolve(undefined)\n        }\n      })\n\n      const nextResult = await until(\n        () => unhandledExceptionController[kResponsePromise]\n      )\n\n      /**\n       * @note Handle the result of the unhandled controller\n       * in the same way as the original request controller.\n       * The exception here is that thrown errors within the\n       * \"unhandledException\" event do NOT result in another\n       * emit of the same event. They are forwarded as-is.\n       */\n      if (nextResult.error) {\n        return handleResponseError(nextResult.error)\n      }\n\n      if (nextResult.data) {\n        return handleResponse(nextResult.data)\n      }\n    }\n\n    // Otherwise, coerce unhandled exceptions to a 500 Internal Server Error response.\n    options.onResponse(createServerErrorResponse(result.error))\n    return true\n  }\n\n  /**\n   * Handle a mocked Response instance.\n   * @note That this can also be an Error in case\n   * the developer called \"errorWith\". This differentiates\n   * unhandled exceptions from intended errors.\n   */\n  if (result.data) {\n    return handleResponse(result.data)\n  }\n\n  // In all other cases, consider the request unhandled.\n  return false\n}\n","/**\n * Determines if a given value is an instance of object.\n */\nexport function isObject<T>(value: any, loose = false): value is T {\n  return loose\n    ? Object.prototype.toString.call(value).startsWith('[object ')\n    : Object.prototype.toString.call(value) === '[object Object]'\n}\n","/**\n * A function that validates if property access is possible on an object\n * without throwing. It returns `true` if the property access is possible\n * and `false` otherwise.\n *\n * Environments like miniflare will throw on property access on certain objects\n * like Request and Response, for unimplemented properties.\n */\nexport function isPropertyAccessible<Obj extends Record<string, any>>(\n  obj: Obj,\n  key: keyof Obj\n) {\n  try {\n    obj[key]\n    return true\n  } catch {\n    return false\n  }\n}\n","import { isObject } from './isObject'\nimport { isPropertyAccessible } from './isPropertyAccessible'\n\n/**\n * Creates a generic 500 Unhandled Exception response.\n */\nexport function createServerErrorResponse(body: unknown): Response {\n  return new Response(\n    JSON.stringify(\n      body instanceof Error\n        ? {\n            name: body.name,\n            message: body.message,\n            stack: body.stack,\n          }\n        : body\n    ),\n    {\n      status: 500,\n      statusText: 'Unhandled Exception',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    }\n  )\n}\n\nexport type ResponseError = Response & { type: 'error' }\n\n/**\n * Check if the given response is a `Response.error()`.\n *\n * @note Some environments, like Miniflare (Cloudflare) do not\n * implement the \"Response.type\" property and throw on its access.\n * Safely check if we can access \"type\" on \"Response\" before continuing.\n * @see https://github.com/mswjs/msw/issues/1834\n */\nexport function isResponseError(response: unknown): response is ResponseError {\n  return (\n    response != null &&\n    response instanceof Response &&\n    isPropertyAccessible(response, 'type') &&\n    response.type === 'error'\n  )\n}\n\n/**\n * Check if the given value is a `Response` or a Response-like object.\n * This is different from `value instanceof Response` because it supports\n * custom `Response` constructors, like the one when using Undici directly.\n */\nexport function isResponseLike(value: unknown): value is Response {\n  return (\n    isObject<Record<string, any>>(value, true) &&\n    isPropertyAccessible(value, 'status') &&\n    isPropertyAccessible(value, 'statusText') &&\n    isPropertyAccessible(value, 'bodyUsed')\n  )\n}\n","export function isNodeLikeError(\n  error: unknown\n): error is NodeJS.ErrnoException {\n  if (error == null) {\n    return false\n  }\n\n  if (!(error instanceof Error)) {\n    return false\n  }\n\n  return 'code' in error && 'errno' in error\n}\n","/**\n * Returns a boolean indicating whether the given global property\n * is defined and is configurable.\n */\nexport function hasConfigurableGlobal(propertyName: string): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(globalThis, propertyName)\n\n  // The property is not set at all.\n  if (typeof descriptor === 'undefined') {\n    return false\n  }\n\n  // The property is set to a getter that returns undefined.\n  if (\n    typeof descriptor.get === 'function' &&\n    typeof descriptor.get() === 'undefined'\n  ) {\n    return false\n  }\n\n  // The property is set to a value equal to undefined.\n  if (typeof descriptor.get === 'undefined' && descriptor.value == null) {\n    return false\n  }\n\n  if (typeof descriptor.set === 'undefined' && !descriptor.configurable) {\n    console.error(\n      `[MSW] Failed to apply interceptor: the global \\`${propertyName}\\` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.`\n    )\n    return false\n  }\n\n  return true\n}\n","import { invariant } from 'outvariant'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { HttpRequestEventMap, IS_PATCHED_MODULE } from '../../glossary'\nimport { Interceptor } from '../../Interceptor'\nimport { RequestController } from '../../RequestController'\nimport { emitAsync } from '../../utils/emitAsync'\nimport { handleRequest } from '../../utils/handleRequest'\nimport { canParseUrl } from '../../utils/canParseUrl'\nimport { createRequestId } from '../../createRequestId'\nimport { createNetworkError } from './utils/createNetworkError'\nimport { followFetchRedirect } from './utils/followRedirect'\nimport { decompressResponse } from './utils/decompression'\nimport { hasConfigurableGlobal } from '../../utils/hasConfigurableGlobal'\nimport { FetchResponse } from '../../utils/fetchUtils'\nimport { setRawRequest } from '../../getRawRequest'\n\nexport class FetchInterceptor extends Interceptor<HttpRequestEventMap> {\n  static symbol = Symbol('fetch')\n\n  constructor() {\n    super(FetchInterceptor.symbol)\n  }\n\n  protected checkEnvironment() {\n    return hasConfigurableGlobal('fetch')\n  }\n\n  protected async setup() {\n    const pureFetch = globalThis.fetch\n\n    invariant(\n      !(pureFetch as any)[IS_PATCHED_MODULE],\n      'Failed to patch the \"fetch\" module: already patched.'\n    )\n\n    globalThis.fetch = async (input, init) => {\n      const requestId = createRequestId()\n\n      /**\n       * @note Resolve potentially relative request URL\n       * against the present `location`. This is mainly\n       * for native `fetch` in JSDOM.\n       * @see https://github.com/mswjs/msw/issues/1625\n       */\n      const resolvedInput =\n        typeof input === 'string' &&\n        typeof location !== 'undefined' &&\n        !canParseUrl(input)\n          ? new URL(input, location.href)\n          : input\n\n      const request = new Request(resolvedInput, init)\n\n      /**\n       * @note Set the raw request only if a Request instance was provided to fetch.\n       */\n      if (input instanceof Request) {\n        setRawRequest(request, input)\n      }\n\n      const responsePromise = new DeferredPromise<Response>()\n      const controller = new RequestController(request)\n\n      this.logger.info('[%s] %s', request.method, request.url)\n      this.logger.info('awaiting for the mocked response...')\n\n      this.logger.info(\n        'emitting the \"request\" event for %s listener(s)...',\n        this.emitter.listenerCount('request')\n      )\n\n      const isRequestHandled = await handleRequest({\n        request,\n        requestId,\n        emitter: this.emitter,\n        controller,\n        onResponse: async (rawResponse) => {\n          this.logger.info('received mocked response!', {\n            rawResponse,\n          })\n\n          // Decompress the mocked response body, if applicable.\n          const decompressedStream = decompressResponse(rawResponse)\n          const response =\n            decompressedStream === null\n              ? rawResponse\n              : new FetchResponse(decompressedStream, rawResponse)\n\n          FetchResponse.setUrl(request.url, response)\n\n          /**\n           * Undici's handling of following redirect responses.\n           * Treat the \"manual\" redirect mode as a regular mocked response.\n           * This way, the client can manually follow the redirect it receives.\n           * @see https://github.com/nodejs/undici/blob/a6dac3149c505b58d2e6d068b97f4dc993da55f0/lib/web/fetch/index.js#L1173\n           */\n          if (FetchResponse.isRedirectResponse(response.status)) {\n            // Reject the request promise if its `redirect` is set to `error`\n            // and it receives a mocked redirect response.\n            if (request.redirect === 'error') {\n              responsePromise.reject(createNetworkError('unexpected redirect'))\n              return\n            }\n\n            if (request.redirect === 'follow') {\n              followFetchRedirect(request, response).then(\n                (response) => {\n                  responsePromise.resolve(response)\n                },\n                (reason) => {\n                  responsePromise.reject(reason)\n                }\n              )\n              return\n            }\n          }\n\n          if (this.emitter.listenerCount('response') > 0) {\n            this.logger.info('emitting the \"response\" event...')\n\n            // Await the response listeners to finish before resolving\n            // the response promise. This ensures all your logic finishes\n            // before the interceptor resolves the pending response.\n            await emitAsync(this.emitter, 'response', {\n              // Clone the mocked response for the \"response\" event listener.\n              // This way, the listener can read the response and not lock its body\n              // for the actual fetch consumer.\n              response: response.clone(),\n              isMockedResponse: true,\n              request,\n              requestId,\n            })\n          }\n\n          responsePromise.resolve(response)\n        },\n        onRequestError: (response) => {\n          this.logger.info('request has errored!', { response })\n          responsePromise.reject(createNetworkError(response))\n        },\n        onError: (error) => {\n          this.logger.info('request has been aborted!', { error })\n          responsePromise.reject(error)\n        },\n      })\n\n      if (isRequestHandled) {\n        this.logger.info('request has been handled, returning mock promise...')\n        return responsePromise\n      }\n\n      this.logger.info(\n        'no mocked response received, performing request as-is...'\n      )\n\n      /**\n       * @note Clone the request instance right before performing it.\n       * This preserves any modifications made to the intercepted request\n       * in the \"request\" listener. This also allows the user to read the\n       * request body in the \"response\" listener (otherwise \"unusable\").\n       */\n      const requestCloneForResponseEvent = request.clone()\n\n      return pureFetch(request).then(async (response) => {\n        this.logger.info('original fetch performed', response)\n\n        if (this.emitter.listenerCount('response') > 0) {\n          this.logger.info('emitting the \"response\" event...')\n\n          const responseClone = response.clone()\n\n          await emitAsync(this.emitter, 'response', {\n            response: responseClone,\n            isMockedResponse: false,\n            request: requestCloneForResponseEvent,\n            requestId,\n          })\n        }\n\n        return response\n      })\n    }\n\n    Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n        value: undefined,\n      })\n\n      globalThis.fetch = pureFetch\n\n      this.logger.info(\n        'restored native \"globalThis.fetch\"!',\n        globalThis.fetch.name\n      )\n    })\n  }\n}\n","export function createNetworkError(cause?: unknown) {\n  return Object.assign(new TypeError('Failed to fetch'), {\n    cause,\n  })\n}\n","import { createNetworkError } from './createNetworkError'\n\nconst REQUEST_BODY_HEADERS = [\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-type',\n  'content-length',\n]\n\nconst kRedirectCount = Symbol('kRedirectCount')\n\n/**\n * @see https://github.com/nodejs/undici/blob/a6dac3149c505b58d2e6d068b97f4dc993da55f0/lib/web/fetch/index.js#L1210\n */\nexport async function followFetchRedirect(\n  request: Request,\n  response: Response\n): Promise<Response> {\n  if (response.status !== 303 && request.body != null) {\n    return Promise.reject(createNetworkError())\n  }\n\n  const requestUrl = new URL(request.url)\n\n  let locationUrl: URL\n  try {\n    // If the location is a relative URL, use the request URL as the base URL.\n    locationUrl = new URL(response.headers.get('location')!, request.url) \n  } catch (error) {\n    return Promise.reject(createNetworkError(error))\n  }\n\n  if (\n    !(locationUrl.protocol === 'http:' || locationUrl.protocol === 'https:')\n  ) {\n    return Promise.reject(\n      createNetworkError('URL scheme must be a HTTP(S) scheme')\n    )\n  }\n\n  if (Reflect.get(request, kRedirectCount) > 20) {\n    return Promise.reject(createNetworkError('redirect count exceeded'))\n  }\n\n  Object.defineProperty(request, kRedirectCount, {\n    value: (Reflect.get(request, kRedirectCount) || 0) + 1,\n  })\n\n  if (\n    request.mode === 'cors' &&\n    (locationUrl.username || locationUrl.password) &&\n    !sameOrigin(requestUrl, locationUrl)\n  ) {\n    return Promise.reject(\n      createNetworkError('cross origin not allowed for request mode \"cors\"')\n    )\n  }\n\n  const requestInit: RequestInit = {}\n\n  if (\n    ([301, 302].includes(response.status) && request.method === 'POST') ||\n    (response.status === 303 && !['HEAD', 'GET'].includes(request.method))\n  ) {\n    requestInit.method = 'GET'\n    requestInit.body = null\n\n    REQUEST_BODY_HEADERS.forEach((headerName) => {\n      request.headers.delete(headerName)\n    })\n  }\n\n  if (!sameOrigin(requestUrl, locationUrl)) {\n    request.headers.delete('authorization')\n    request.headers.delete('proxy-authorization')\n    request.headers.delete('cookie')\n    request.headers.delete('host')\n  }\n\n  /**\n   * @note Undici \"safely\" extracts the request body.\n   * I suspect we cannot dispatch this request again\n   * since its body has been read and the stream is locked.\n   */\n\n  requestInit.headers = request.headers\n  return fetch(new Request(locationUrl, requestInit))\n}\n\n/**\n * @see https://github.com/nodejs/undici/blob/a6dac3149c505b58d2e6d068b97f4dc993da55f0/lib/web/fetch/util.js#L761\n */\nfunction sameOrigin(left: URL, right: URL): boolean {\n  if (left.origin === right.origin && left.origin === 'null') {\n    return true\n  }\n\n  if (\n    left.protocol === right.protocol &&\n    left.hostname === right.hostname &&\n    left.port === right.port\n  ) {\n    return true\n  }\n\n  return false\n}\n","export class BrotliDecompressionStream extends TransformStream {\n  constructor() {\n    console.warn(\n      '[Interceptors]: Brotli decompression of response streams is not supported in the browser'\n    )\n\n    super({\n      transform(chunk, controller) {\n        // Keep the stream as passthrough, it does nothing.\n        controller.enqueue(chunk)\n      },\n    })\n  }\n}\n","// Import from an internal alias that resolves to different modules\n// depending on the environment. This way, we can keep the fetch interceptor\n// intact while using different strategies for Brotli decompression.\nimport { BrotliDecompressionStream } from 'internal:brotli-decompress'\n\nclass PipelineStream extends TransformStream {\n  constructor(\n    transformStreams: Array<TransformStream>,\n    ...strategies: Array<QueuingStrategy>\n  ) {\n    super({}, ...strategies)\n\n    const readable = [super.readable as any, ...transformStreams].reduce(\n      (readable, transform) => readable.pipeThrough(transform)\n    )\n\n    Object.defineProperty(this, 'readable', {\n      get() {\n        return readable\n      },\n    })\n  }\n}\n\nexport function parseContentEncoding(contentEncoding: string): Array<string> {\n  return contentEncoding\n    .toLowerCase()\n    .split(',')\n    .map((coding) => coding.trim())\n}\n\nfunction createDecompressionStream(\n  contentEncoding: string\n): TransformStream | null {\n  if (contentEncoding === '') {\n    return null\n  }\n\n  const codings = parseContentEncoding(contentEncoding)\n\n  if (codings.length === 0) {\n    return null\n  }\n\n  const transformers = codings.reduceRight<Array<TransformStream>>(\n    (transformers, coding) => {\n      if (coding === 'gzip' || coding === 'x-gzip') {\n        return transformers.concat(new DecompressionStream('gzip'))\n      } else if (coding === 'deflate') {\n        return transformers.concat(new DecompressionStream('deflate'))\n      } else if (coding === 'br') {\n        return transformers.concat(new BrotliDecompressionStream())\n      } else {\n        transformers.length = 0\n      }\n\n      return transformers\n    },\n    []\n  )\n\n  return new PipelineStream(transformers)\n}\n\nexport function decompressResponse(\n  response: Response\n): ReadableStream<any> | null {\n  if (response.body === null) {\n    return null\n  }\n\n  const decompressionStream = createDecompressionStream(\n    response.headers.get('content-encoding') || ''\n  )\n\n  if (!decompressionStream) {\n    return null\n  }\n\n  // Use `pipeTo` and return the decompression stream's readable\n  // instead of `pipeThrough` because that will lock the original\n  // response stream, making it unusable as the input to Response.\n  response.body.pipeTo(decompressionStream.writable)\n  return decompressionStream.readable\n}\n","import { invariant } from 'outvariant'\nimport { Emitter } from 'strict-event-emitter'\nimport { HttpRequestEventMap, IS_PATCHED_MODULE } from '../../glossary'\nimport { Interceptor } from '../../Interceptor'\nimport { createXMLHttpRequestProxy } from './XMLHttpRequestProxy'\nimport { hasConfigurableGlobal } from '../../utils/hasConfigurableGlobal'\n\nexport type XMLHttpRequestEmitter = Emitter<HttpRequestEventMap>\n\nexport class XMLHttpRequestInterceptor extends Interceptor<HttpRequestEventMap> {\n  static interceptorSymbol = Symbol('xhr')\n\n  constructor() {\n    super(XMLHttpRequestInterceptor.interceptorSymbol)\n  }\n\n  protected checkEnvironment() {\n    return hasConfigurableGlobal('XMLHttpRequest')\n  }\n\n  protected setup() {\n    const logger = this.logger.extend('setup')\n\n    logger.info('patching \"XMLHttpRequest\" module...')\n\n    const PureXMLHttpRequest = globalThis.XMLHttpRequest\n\n    invariant(\n      !(PureXMLHttpRequest as any)[IS_PATCHED_MODULE],\n      'Failed to patch the \"XMLHttpRequest\" module: already patched.'\n    )\n\n    globalThis.XMLHttpRequest = createXMLHttpRequestProxy({\n      emitter: this.emitter,\n      logger: this.logger,\n    })\n\n    logger.info(\n      'native \"XMLHttpRequest\" module patched!',\n      globalThis.XMLHttpRequest.name\n    )\n\n    Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n        value: undefined,\n      })\n\n      globalThis.XMLHttpRequest = PureXMLHttpRequest\n      logger.info(\n        'native \"XMLHttpRequest\" module restored!',\n        globalThis.XMLHttpRequest.name\n      )\n    })\n  }\n}\n","import { invariant } from 'outvariant'\nimport { isNodeProcess } from 'is-node-process'\nimport type { Logger } from '@open-draft/logger'\nimport { concatArrayBuffer } from './utils/concatArrayBuffer'\nimport { createEvent } from './utils/createEvent'\nimport {\n  decodeBuffer,\n  encodeBuffer,\n  toArrayBuffer,\n} from '../../utils/bufferUtils'\nimport { createProxy } from '../../utils/createProxy'\nimport { isDomParserSupportedType } from './utils/isDomParserSupportedType'\nimport { parseJson } from '../../utils/parseJson'\nimport { createResponse } from './utils/createResponse'\nimport { INTERNAL_REQUEST_ID_HEADER_NAME } from '../../Interceptor'\nimport { createRequestId } from '../../createRequestId'\nimport { getBodyByteLength } from './utils/getBodyByteLength'\nimport { setRawRequest } from '../../getRawRequest'\n\nconst kIsRequestHandled = Symbol('kIsRequestHandled')\nconst IS_NODE = isNodeProcess()\nconst kFetchRequest = Symbol('kFetchRequest')\n\n/**\n * An `XMLHttpRequest` instance controller that allows us\n * to handle any given request instance (e.g. responding to it).\n */\nexport class XMLHttpRequestController {\n  public request: XMLHttpRequest\n  public requestId: string\n  public onRequest?: (\n    this: XMLHttpRequestController,\n    args: {\n      request: Request\n      requestId: string\n    }\n  ) => Promise<void>\n  public onResponse?: (\n    this: XMLHttpRequestController,\n    args: {\n      response: Response\n      isMockedResponse: boolean\n      request: Request\n      requestId: string\n    }\n  ) => void;\n\n  [kIsRequestHandled]: boolean;\n  [kFetchRequest]?: Request\n  private method: string = 'GET'\n  private url: URL = null as any\n  private requestHeaders: Headers\n  private responseBuffer: Uint8Array\n  private events: Map<keyof XMLHttpRequestEventTargetEventMap, Array<Function>>\n  private uploadEvents: Map<\n    keyof XMLHttpRequestEventTargetEventMap,\n    Array<Function>\n  >\n\n  constructor(readonly initialRequest: XMLHttpRequest, public logger: Logger) {\n    this[kIsRequestHandled] = false\n\n    this.events = new Map()\n    this.uploadEvents = new Map()\n    this.requestId = createRequestId()\n    this.requestHeaders = new Headers()\n    this.responseBuffer = new Uint8Array()\n\n    this.request = createProxy(initialRequest, {\n      setProperty: ([propertyName, nextValue], invoke) => {\n        switch (propertyName) {\n          case 'ontimeout': {\n            const eventName = propertyName.slice(\n              2\n            ) as keyof XMLHttpRequestEventTargetEventMap\n\n            /**\n             * @note Proxy callbacks to event listeners because JSDOM has trouble\n             * translating these properties to callbacks. It seemed to be operating\n             * on events exclusively.\n             */\n            this.request.addEventListener(eventName, nextValue as any)\n\n            return invoke()\n          }\n\n          default: {\n            return invoke()\n          }\n        }\n      },\n      methodCall: ([methodName, args], invoke) => {\n        switch (methodName) {\n          case 'open': {\n            const [method, url] = args as [string, string | undefined]\n\n            if (typeof url === 'undefined') {\n              this.method = 'GET'\n              this.url = toAbsoluteUrl(method)\n            } else {\n              this.method = method\n              this.url = toAbsoluteUrl(url)\n            }\n\n            this.logger = this.logger.extend(`${this.method} ${this.url.href}`)\n            this.logger.info('open', this.method, this.url.href)\n\n            return invoke()\n          }\n\n          case 'addEventListener': {\n            const [eventName, listener] = args as [\n              keyof XMLHttpRequestEventTargetEventMap,\n              Function\n            ]\n\n            this.registerEvent(eventName, listener)\n            this.logger.info('addEventListener', eventName, listener)\n\n            return invoke()\n          }\n\n          case 'setRequestHeader': {\n            const [name, value] = args as [string, string]\n            this.requestHeaders.set(name, value)\n\n            this.logger.info('setRequestHeader', name, value)\n\n            return invoke()\n          }\n\n          case 'send': {\n            const [body] = args as [\n              body?: XMLHttpRequestBodyInit | Document | null\n            ]\n\n            this.request.addEventListener('load', () => {\n              if (typeof this.onResponse !== 'undefined') {\n                // Create a Fetch API Response representation of whichever\n                // response this XMLHttpRequest received. Note those may\n                // be either a mocked and the original response.\n                const fetchResponse = createResponse(\n                  this.request,\n                  /**\n                   * The `response` property is the right way to read\n                   * the ambiguous response body, as the request's \"responseType\" may differ.\n                   * @see https://xhr.spec.whatwg.org/#the-response-attribute\n                   */\n                  this.request.response\n                )\n\n                // Notify the consumer about the response.\n                this.onResponse.call(this, {\n                  response: fetchResponse,\n                  isMockedResponse: this[kIsRequestHandled],\n                  request: fetchRequest,\n                  requestId: this.requestId!,\n                })\n              }\n            })\n\n            const requestBody =\n              typeof body === 'string' ? encodeBuffer(body) : body\n\n            // Delegate request handling to the consumer.\n            const fetchRequest = this.toFetchApiRequest(requestBody)\n            this[kFetchRequest] = fetchRequest.clone()\n\n            const onceRequestSettled =\n              this.onRequest?.call(this, {\n                request: fetchRequest,\n                requestId: this.requestId!,\n              }) || Promise.resolve()\n\n            onceRequestSettled.finally(() => {\n              // If the consumer didn't handle the request (called `.respondWith()`) perform it as-is.\n              if (!this[kIsRequestHandled]) {\n                this.logger.info(\n                  'request callback settled but request has not been handled (readystate %d), performing as-is...',\n                  this.request.readyState\n                )\n\n                /**\n                 * @note Set the intercepted request ID on the original request in Node.js\n                 * so that if it triggers any other interceptors, they don't attempt\n                 * to process it once again.\n                 *\n                 * For instance, XMLHttpRequest is often implemented via \"http.ClientRequest\"\n                 * and we don't want for both XHR and ClientRequest interceptors to\n                 * handle the same request at the same time (e.g. emit the \"response\" event twice).\n                 */\n                if (IS_NODE) {\n                  this.request.setRequestHeader(\n                    INTERNAL_REQUEST_ID_HEADER_NAME,\n                    this.requestId!\n                  )\n                }\n\n                return invoke()\n              }\n            })\n\n            break\n          }\n\n          default: {\n            return invoke()\n          }\n        }\n      },\n    })\n\n    /**\n     * Proxy the `.upload` property to gather the event listeners/callbacks.\n     */\n    define(\n      this.request,\n      'upload',\n      createProxy(this.request.upload, {\n        setProperty: ([propertyName, nextValue], invoke) => {\n          switch (propertyName) {\n            case 'onloadstart':\n            case 'onprogress':\n            case 'onaboart':\n            case 'onerror':\n            case 'onload':\n            case 'ontimeout':\n            case 'onloadend': {\n              const eventName = propertyName.slice(\n                2\n              ) as keyof XMLHttpRequestEventTargetEventMap\n\n              this.registerUploadEvent(eventName, nextValue as Function)\n            }\n          }\n\n          return invoke()\n        },\n        methodCall: ([methodName, args], invoke) => {\n          switch (methodName) {\n            case 'addEventListener': {\n              const [eventName, listener] = args as [\n                keyof XMLHttpRequestEventTargetEventMap,\n                Function\n              ]\n              this.registerUploadEvent(eventName, listener)\n              this.logger.info('upload.addEventListener', eventName, listener)\n\n              return invoke()\n            }\n          }\n        },\n      })\n    )\n  }\n\n  private registerEvent(\n    eventName: keyof XMLHttpRequestEventTargetEventMap,\n    listener: Function\n  ): void {\n    const prevEvents = this.events.get(eventName) || []\n    const nextEvents = prevEvents.concat(listener)\n    this.events.set(eventName, nextEvents)\n\n    this.logger.info('registered event \"%s\"', eventName, listener)\n  }\n\n  private registerUploadEvent(\n    eventName: keyof XMLHttpRequestEventTargetEventMap,\n    listener: Function\n  ): void {\n    const prevEvents = this.uploadEvents.get(eventName) || []\n    const nextEvents = prevEvents.concat(listener)\n    this.uploadEvents.set(eventName, nextEvents)\n\n    this.logger.info('registered upload event \"%s\"', eventName, listener)\n  }\n\n  /**\n   * Responds to the current request with the given\n   * Fetch API `Response` instance.\n   */\n  public async respondWith(response: Response): Promise<void> {\n    /**\n     * @note Since `XMLHttpRequestController` delegates the handling of the responses\n     * to the \"load\" event listener that doesn't distinguish between the mocked and original\n     * responses, mark the request that had a mocked response with a corresponding symbol.\n     *\n     * Mark this request as having a mocked response immediately since\n     * calculating request/response total body length is asynchronous.\n     */\n    this[kIsRequestHandled] = true\n\n    /**\n     * Dispatch request upload events for requests with a body.\n     * @see https://github.com/mswjs/interceptors/issues/573\n     */\n    if (this[kFetchRequest]) {\n      const totalRequestBodyLength = await getBodyByteLength(\n        this[kFetchRequest]\n      )\n\n      this.trigger('loadstart', this.request.upload, {\n        loaded: 0,\n        total: totalRequestBodyLength,\n      })\n      this.trigger('progress', this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength,\n      })\n      this.trigger('load', this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength,\n      })\n      this.trigger('loadend', this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength,\n      })\n    }\n\n    this.logger.info(\n      'responding with a mocked response: %d %s',\n      response.status,\n      response.statusText\n    )\n\n    define(this.request, 'status', response.status)\n    define(this.request, 'statusText', response.statusText)\n    define(this.request, 'responseURL', this.url.href)\n\n    this.request.getResponseHeader = new Proxy(this.request.getResponseHeader, {\n      apply: (_, __, args: [name: string]) => {\n        this.logger.info('getResponseHeader', args[0])\n\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info('headers not received yet, returning null')\n\n          // Headers not received yet, nothing to return.\n          return null\n        }\n\n        const headerValue = response.headers.get(args[0])\n        this.logger.info(\n          'resolved response header \"%s\" to',\n          args[0],\n          headerValue\n        )\n\n        return headerValue\n      },\n    })\n\n    this.request.getAllResponseHeaders = new Proxy(\n      this.request.getAllResponseHeaders,\n      {\n        apply: () => {\n          this.logger.info('getAllResponseHeaders')\n\n          if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n            this.logger.info('headers not received yet, returning empty string')\n\n            // Headers not received yet, nothing to return.\n            return ''\n          }\n\n          const headersList = Array.from(response.headers.entries())\n          const allHeaders = headersList\n            .map(([headerName, headerValue]) => {\n              return `${headerName}: ${headerValue}`\n            })\n            .join('\\r\\n')\n\n          this.logger.info('resolved all response headers to', allHeaders)\n\n          return allHeaders\n        },\n      }\n    )\n\n    // Update the response getters to resolve against the mocked response.\n    Object.defineProperties(this.request, {\n      response: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.response,\n      },\n      responseText: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseText,\n      },\n      responseXML: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseXML,\n      },\n    })\n\n    const totalResponseBodyLength = await getBodyByteLength(response.clone())\n\n    this.logger.info('calculated response body length', totalResponseBodyLength)\n\n    this.trigger('loadstart', this.request, {\n      loaded: 0,\n      total: totalResponseBodyLength,\n    })\n\n    this.setReadyState(this.request.HEADERS_RECEIVED)\n    this.setReadyState(this.request.LOADING)\n\n    const finalizeResponse = () => {\n      this.logger.info('finalizing the mocked response...')\n\n      this.setReadyState(this.request.DONE)\n\n      this.trigger('load', this.request, {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength,\n      })\n\n      this.trigger('loadend', this.request, {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength,\n      })\n    }\n\n    if (response.body) {\n      this.logger.info('mocked response has body, streaming...')\n\n      const reader = response.body.getReader()\n\n      const readNextResponseBodyChunk = async () => {\n        const { value, done } = await reader.read()\n\n        if (done) {\n          this.logger.info('response body stream done!')\n          finalizeResponse()\n          return\n        }\n\n        if (value) {\n          this.logger.info('read response body chunk:', value)\n          this.responseBuffer = concatArrayBuffer(this.responseBuffer, value)\n\n          this.trigger('progress', this.request, {\n            loaded: this.responseBuffer.byteLength,\n            total: totalResponseBodyLength,\n          })\n        }\n\n        readNextResponseBodyChunk()\n      }\n\n      readNextResponseBodyChunk()\n    } else {\n      finalizeResponse()\n    }\n  }\n\n  private responseBufferToText(): string {\n    return decodeBuffer(this.responseBuffer)\n  }\n\n  get response(): unknown {\n    this.logger.info(\n      'getResponse (responseType: %s)',\n      this.request.responseType\n    )\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null\n    }\n\n    switch (this.request.responseType) {\n      case 'json': {\n        const responseJson = parseJson(this.responseBufferToText())\n        this.logger.info('resolved response JSON', responseJson)\n\n        return responseJson\n      }\n\n      case 'arraybuffer': {\n        const arrayBuffer = toArrayBuffer(this.responseBuffer)\n        this.logger.info('resolved response ArrayBuffer', arrayBuffer)\n\n        return arrayBuffer\n      }\n\n      case 'blob': {\n        const mimeType =\n          this.request.getResponseHeader('Content-Type') || 'text/plain'\n        const responseBlob = new Blob([this.responseBufferToText()], {\n          type: mimeType,\n        })\n\n        this.logger.info(\n          'resolved response Blob (mime type: %s)',\n          responseBlob,\n          mimeType\n        )\n\n        return responseBlob\n      }\n\n      default: {\n        const responseText = this.responseBufferToText()\n        this.logger.info(\n          'resolving \"%s\" response type as text',\n          this.request.responseType,\n          responseText\n        )\n\n        return responseText\n      }\n    }\n  }\n\n  get responseText(): string {\n    /**\n     * Throw when trying to read the response body as text when the\n     * \"responseType\" doesn't expect text. This just respects the spec better.\n     * @see https://xhr.spec.whatwg.org/#the-responsetext-attribute\n     */\n    invariant(\n      this.request.responseType === '' || this.request.responseType === 'text',\n      'InvalidStateError: The object is in invalid state.'\n    )\n\n    if (\n      this.request.readyState !== this.request.LOADING &&\n      this.request.readyState !== this.request.DONE\n    ) {\n      return ''\n    }\n\n    const responseText = this.responseBufferToText()\n    this.logger.info('getResponseText: \"%s\"', responseText)\n\n    return responseText\n  }\n\n  get responseXML(): Document | null {\n    invariant(\n      this.request.responseType === '' ||\n        this.request.responseType === 'document',\n      'InvalidStateError: The object is in invalid state.'\n    )\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null\n    }\n\n    const contentType = this.request.getResponseHeader('Content-Type') || ''\n\n    if (typeof DOMParser === 'undefined') {\n      console.warn(\n        'Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly.'\n      )\n      return null\n    }\n\n    if (isDomParserSupportedType(contentType)) {\n      return new DOMParser().parseFromString(\n        this.responseBufferToText(),\n        contentType\n      )\n    }\n\n    return null\n  }\n\n  public errorWith(error?: Error): void {\n    /**\n     * @note Mark this request as handled even if it received a mock error.\n     * This prevents the controller from trying to perform this request as-is.\n     */\n    this[kIsRequestHandled] = true\n    this.logger.info('responding with an error')\n\n    this.setReadyState(this.request.DONE)\n    this.trigger('error', this.request)\n    this.trigger('loadend', this.request)\n  }\n\n  /**\n   * Transitions this request's `readyState` to the given one.\n   */\n  private setReadyState(nextReadyState: number): void {\n    this.logger.info(\n      'setReadyState: %d -> %d',\n      this.request.readyState,\n      nextReadyState\n    )\n\n    if (this.request.readyState === nextReadyState) {\n      this.logger.info('ready state identical, skipping transition...')\n      return\n    }\n\n    define(this.request, 'readyState', nextReadyState)\n\n    this.logger.info('set readyState to: %d', nextReadyState)\n\n    if (nextReadyState !== this.request.UNSENT) {\n      this.logger.info('triggerring \"readystatechange\" event...')\n\n      this.trigger('readystatechange', this.request)\n    }\n  }\n\n  /**\n   * Triggers given event on the `XMLHttpRequest` instance.\n   */\n  private trigger<\n    EventName extends keyof (XMLHttpRequestEventTargetEventMap & {\n      readystatechange: ProgressEvent<XMLHttpRequestEventTarget>\n    })\n  >(\n    eventName: EventName,\n    target: XMLHttpRequest | XMLHttpRequestUpload,\n    options?: ProgressEventInit\n  ): void {\n    const callback = (target as XMLHttpRequest)[`on${eventName}`]\n    const event = createEvent(target, eventName, options)\n\n    this.logger.info('trigger \"%s\"', eventName, options || '')\n\n    // Invoke direct callbacks.\n    if (typeof callback === 'function') {\n      this.logger.info('found a direct \"%s\" callback, calling...', eventName)\n      callback.call(target as XMLHttpRequest, event)\n    }\n\n    // Invoke event listeners.\n    const events =\n      target instanceof XMLHttpRequestUpload ? this.uploadEvents : this.events\n\n    for (const [registeredEventName, listeners] of events) {\n      if (registeredEventName === eventName) {\n        this.logger.info(\n          'found %d listener(s) for \"%s\" event, calling...',\n          listeners.length,\n          eventName\n        )\n\n        listeners.forEach((listener) => listener.call(target, event))\n      }\n    }\n  }\n\n  /**\n   * Converts this `XMLHttpRequest` instance into a Fetch API `Request` instance.\n   */\n  private toFetchApiRequest(\n    body: XMLHttpRequestBodyInit | Document | null | undefined\n  ): Request {\n    this.logger.info('converting request to a Fetch API Request...')\n\n    // If the `Document` is used as the body of this XMLHttpRequest,\n    // set its inner text as the Fetch API Request body.\n    const resolvedBody =\n      body instanceof Document ? body.documentElement.innerText : body\n\n    const fetchRequest = new Request(this.url.href, {\n      method: this.method,\n      headers: this.requestHeaders,\n      /**\n       * @see https://xhr.spec.whatwg.org/#cross-origin-credentials\n       */\n      credentials: this.request.withCredentials ? 'include' : 'same-origin',\n      body: ['GET', 'HEAD'].includes(this.method.toUpperCase())\n        ? null\n        : resolvedBody,\n    })\n\n    const proxyHeaders = createProxy(fetchRequest.headers, {\n      methodCall: ([methodName, args], invoke) => {\n        // Forward the latest state of the internal request headers\n        // because the interceptor might have modified them\n        // without responding to the request.\n        switch (methodName) {\n          case 'append':\n          case 'set': {\n            const [headerName, headerValue] = args as [string, string]\n            this.request.setRequestHeader(headerName, headerValue)\n            break\n          }\n\n          case 'delete': {\n            const [headerName] = args as [string]\n            console.warn(\n              `XMLHttpRequest: Cannot remove a \"${headerName}\" header from the Fetch API representation of the \"${fetchRequest.method} ${fetchRequest.url}\" request. XMLHttpRequest headers cannot be removed.`\n            )\n            break\n          }\n        }\n\n        return invoke()\n      },\n    })\n    define(fetchRequest, 'headers', proxyHeaders)\n    setRawRequest(fetchRequest, this.request)\n\n    this.logger.info('converted request to a Fetch API Request!', fetchRequest)\n\n    return fetchRequest\n  }\n}\n\nfunction toAbsoluteUrl(url: string | URL): URL {\n  /**\n   * @note XMLHttpRequest interceptor may run in environments\n   * that implement XMLHttpRequest but don't implement \"location\"\n   * (for example, React Native). If that's the case, return the\n   * input URL as-is (nothing to be relative to).\n   * @see https://github.com/mswjs/msw/issues/1777\n   */\n  if (typeof location === 'undefined') {\n    return new URL(url)\n  }\n\n  return new URL(url.toString(), location.href)\n}\n\nfunction define(\n  target: object,\n  property: string | symbol,\n  value: unknown\n): void {\n  Reflect.defineProperty(target, property, {\n    // Ensure writable properties to allow redefining readonly properties.\n    writable: true,\n    enumerable: true,\n    value,\n  })\n}\n","/**\n * Concatenate two `Uint8Array` buffers.\n */\nexport function concatArrayBuffer(\n  left: Uint8Array,\n  right: Uint8Array\n): Uint8Array {\n  const result = new Uint8Array(left.byteLength + right.byteLength)\n  result.set(left, 0)\n  result.set(right, left.byteLength)\n  return result\n}\n","export class EventPolyfill implements Event {\n  readonly NONE = 0\n  readonly CAPTURING_PHASE = 1\n  readonly AT_TARGET = 2\n  readonly BUBBLING_PHASE = 3\n\n  public type: string = ''\n  public srcElement: EventTarget | null = null\n  public target: EventTarget | null\n  public currentTarget: EventTarget | null = null\n  public eventPhase: number = 0\n  public timeStamp: number\n  public isTrusted: boolean = true\n  public composed: boolean = false\n  public cancelable: boolean = true\n  public defaultPrevented: boolean = false\n  public bubbles: boolean = true\n  public lengthComputable: boolean = true\n  public loaded: number = 0\n  public total: number = 0\n\n  cancelBubble: boolean = false\n  returnValue: boolean = true\n\n  constructor(\n    type: string,\n    options?: { target: EventTarget; currentTarget: EventTarget }\n  ) {\n    this.type = type\n    this.target = options?.target || null\n    this.currentTarget = options?.currentTarget || null\n    this.timeStamp = Date.now()\n  }\n\n  public composedPath(): EventTarget[] {\n    return []\n  }\n\n  public initEvent(type: string, bubbles?: boolean, cancelable?: boolean) {\n    this.type = type\n    this.bubbles = !!bubbles\n    this.cancelable = !!cancelable\n  }\n\n  public preventDefault() {\n    this.defaultPrevented = true\n  }\n\n  public stopPropagation() {}\n  public stopImmediatePropagation() {}\n}\n","import { EventPolyfill } from './EventPolyfill'\n\nexport class ProgressEventPolyfill extends EventPolyfill {\n  readonly lengthComputable: boolean\n  readonly composed: boolean\n  readonly loaded: number\n  readonly total: number\n\n  constructor(type: string, init?: ProgressEventInit) {\n    super(type)\n\n    this.lengthComputable = init?.lengthComputable || false\n    this.composed = init?.composed || false\n    this.loaded = init?.loaded || 0\n    this.total = init?.total || 0\n  }\n}\n","import { EventPolyfill } from '../polyfills/EventPolyfill'\nimport { ProgressEventPolyfill } from '../polyfills/ProgressEventPolyfill'\n\nconst SUPPORTS_PROGRESS_EVENT = typeof ProgressEvent !== 'undefined'\n\nexport function createEvent(\n  target: XMLHttpRequest | XMLHttpRequestUpload,\n  type: string,\n  init?: ProgressEventInit\n): EventPolyfill | ProgressEvent {\n  const progressEvents = [\n    'error',\n    'progress',\n    'loadstart',\n    'loadend',\n    'load',\n    'timeout',\n    'abort',\n  ]\n\n  /**\n   * `ProgressEvent` is not supported in React Native.\n   * @see https://github.com/mswjs/interceptors/issues/40\n   */\n  const ProgressEventClass = SUPPORTS_PROGRESS_EVENT\n    ? ProgressEvent\n    : ProgressEventPolyfill\n\n  const event = progressEvents.includes(type)\n    ? new ProgressEventClass(type, {\n        lengthComputable: true,\n        loaded: init?.loaded || 0,\n        total: init?.total || 0,\n      })\n    : new EventPolyfill(type, {\n        target,\n        currentTarget: target,\n      })\n\n  return event\n}\n","/**\n * Returns the source object of the given property on the target object\n * (the target itself, any parent in its prototype, or null).\n */\nexport function findPropertySource(\n  target: object,\n  propertyName: string | symbol\n): object | null {\n  if (!(propertyName in target)) {\n    return null\n  }\n\n  const hasProperty = Object.prototype.hasOwnProperty.call(target, propertyName)\n  if (hasProperty) {\n    return target\n  }\n\n  const prototype = Reflect.getPrototypeOf(target)\n  return prototype ? findPropertySource(prototype, propertyName) : null\n}\n","import { findPropertySource } from './findPropertySource'\n\nexport interface ProxyOptions<Target extends Record<string, any>> {\n  constructorCall?(args: Array<unknown>, next: NextFunction<Target>): Target\n\n  methodCall?<F extends keyof Target>(\n    this: Target,\n    data: [methodName: F, args: Array<unknown>],\n    next: NextFunction<void>\n  ): void\n\n  setProperty?(\n    data: [propertyName: string | symbol, nextValue: unknown],\n    next: NextFunction<boolean>\n  ): boolean\n\n  getProperty?(\n    data: [propertyName: string | symbol, receiver: Target],\n    next: NextFunction<void>\n  ): void\n}\n\nexport type NextFunction<ReturnType> = () => ReturnType\n\nexport function createProxy<Target extends object>(\n  target: Target,\n  options: ProxyOptions<Target>\n): Target {\n  const proxy = new Proxy(target, optionsToProxyHandler(options))\n\n  return proxy\n}\n\nfunction optionsToProxyHandler<T extends Record<string, any>>(\n  options: ProxyOptions<T>\n): ProxyHandler<T> {\n  const { constructorCall, methodCall, getProperty, setProperty } = options\n  const handler: ProxyHandler<T> = {}\n\n  if (typeof constructorCall !== 'undefined') {\n    handler.construct = function (target, args, newTarget) {\n      const next = Reflect.construct.bind(null, target as any, args, newTarget)\n      return constructorCall.call(newTarget, args, next)\n    }\n  }\n\n  handler.set = function (target, propertyName, nextValue) {\n    const next = () => {\n      const propertySource = findPropertySource(target, propertyName) || target\n      const ownDescriptors = Reflect.getOwnPropertyDescriptor(\n        propertySource,\n        propertyName\n      )\n\n      // Respect any custom setters present for this property.\n      if (typeof ownDescriptors?.set !== 'undefined') {\n        ownDescriptors.set.apply(target, [nextValue])\n        return true\n      }\n\n      // Otherwise, set the property on the source.\n      return Reflect.defineProperty(propertySource, propertyName, {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: nextValue,\n      })\n    }\n\n    if (typeof setProperty !== 'undefined') {\n      return setProperty.call(target, [propertyName, nextValue], next)\n    }\n\n    return next()\n  }\n\n  handler.get = function (target, propertyName, receiver) {\n    /**\n     * @note Using `Reflect.get()` here causes \"TypeError: Illegal invocation\".\n     */\n    const next = () => target[propertyName as any]\n\n    const value =\n      typeof getProperty !== 'undefined'\n        ? getProperty.call(target, [propertyName, receiver], next)\n        : next()\n\n    if (typeof value === 'function') {\n      return (...args: Array<any>) => {\n        const next = value.bind(target, ...args)\n\n        if (typeof methodCall !== 'undefined') {\n          return methodCall.call(target, [propertyName as any, args], next)\n        }\n\n        return next()\n      }\n    }\n\n    return value\n  }\n\n  return handler\n}\n","export function isDomParserSupportedType(\n  type: string\n): type is DOMParserSupportedType {\n  const supportedTypes: Array<DOMParserSupportedType> = [\n    'application/xhtml+xml',\n    'application/xml',\n    'image/svg+xml',\n    'text/html',\n    'text/xml',\n  ]\n  return supportedTypes.some((supportedType) => {\n    return type.startsWith(supportedType)\n  })\n}\n","/**\n * Parses a given string into JSON.\n * Gracefully handles invalid JSON by returning `null`.\n */\nexport function parseJson(data: string): Record<string, unknown> | null {\n  try {\n    const json = JSON.parse(data)\n    return json\n  } catch (_) {\n    return null\n  }\n}\n","import { FetchResponse } from '../../../utils/fetchUtils'\n\n/**\n * Creates a Fetch API `Response` instance from the given\n * `XMLHttpRequest` instance and a response body.\n */\nexport function createResponse(\n  request: XMLHttpRequest,\n  body: BodyInit | null\n): Response {\n  /**\n   * Handle XMLHttpRequest responses that must have null as the\n   * response body when represented using Fetch API Response.\n   * XMLHttpRequest response will always have an empty string\n   * as the \"request.response\" in those cases, resulting in an error\n   * when constructing a Response instance.\n   * @see https://github.com/mswjs/interceptors/issues/379\n   */\n  const responseBodyOrNull = FetchResponse.isResponseWithBody(request.status)\n    ? body\n    : null\n\n  return new FetchResponse(responseBodyOrNull, {\n    url: request.responseURL,\n    status: request.status,\n    statusText: request.statusText,\n    headers: createHeadersFromXMLHttpReqestHeaders(\n      request.getAllResponseHeaders()\n    ),\n  })\n}\n\nfunction createHeadersFromXMLHttpReqestHeaders(headersString: string): Headers {\n  const headers = new Headers()\n\n  const lines = headersString.split(/[\\r\\n]+/)\n  for (const line of lines) {\n    if (line.trim() === '') {\n      continue\n    }\n\n    const [name, ...parts] = line.split(': ')\n    const value = parts.join(': ')\n\n    headers.append(name, value)\n  }\n\n  return headers\n}\n","/**\n * Return a total byte length of the given request/response body.\n * If the `Content-Length` header is present, it will be used as the byte length.\n */\nexport async function getBodyByteLength(\n  input: Request | Response\n): Promise<number> {\n  const explicitContentLength = input.headers.get('content-length')\n\n  if (explicitContentLength != null && explicitContentLength !== '') {\n    return Number(explicitContentLength)\n  }\n\n  const buffer = await input.arrayBuffer()\n  return buffer.byteLength\n}\n","import type { Logger } from '@open-draft/logger'\nimport { XMLHttpRequestEmitter } from '.'\nimport { RequestController } from '../../RequestController'\nimport { XMLHttpRequestController } from './XMLHttpRequestController'\nimport { handleRequest } from '../../utils/handleRequest'\n\nexport interface XMLHttpRequestProxyOptions {\n  emitter: XMLHttpRequestEmitter\n  logger: Logger\n}\n\n/**\n * Create a proxied `XMLHttpRequest` class.\n * The proxied class establishes spies on certain methods,\n * allowing us to intercept requests and respond to them.\n */\nexport function createXMLHttpRequestProxy({\n  emitter,\n  logger,\n}: XMLHttpRequestProxyOptions) {\n  const XMLHttpRequestProxy = new Proxy(globalThis.XMLHttpRequest, {\n    construct(target, args, newTarget) {\n      logger.info('constructed new XMLHttpRequest')\n\n      const originalRequest = Reflect.construct(\n        target,\n        args,\n        newTarget\n      ) as XMLHttpRequest\n\n      /**\n       * @note Forward prototype descriptors onto the proxied object.\n       * XMLHttpRequest is implemented in JSDOM in a way that assigns\n       * a bunch of descriptors, like \"set responseType()\" on the prototype.\n       * With this propagation, we make sure that those descriptors trigger\n       * when the user operates with the proxied request instance.\n       */\n      const prototypeDescriptors = Object.getOwnPropertyDescriptors(\n        target.prototype\n      )\n      for (const propertyName in prototypeDescriptors) {\n        Reflect.defineProperty(\n          originalRequest,\n          propertyName,\n          prototypeDescriptors[propertyName]\n        )\n      }\n\n      const xhrRequestController = new XMLHttpRequestController(\n        originalRequest,\n        logger\n      )\n\n      xhrRequestController.onRequest = async function ({ request, requestId }) {\n        const controller = new RequestController(request)\n\n        this.logger.info('awaiting mocked response...')\n\n        this.logger.info(\n          'emitting the \"request\" event for %s listener(s)...',\n          emitter.listenerCount('request')\n        )\n\n        const isRequestHandled = await handleRequest({\n          request,\n          requestId,\n          controller,\n          emitter,\n          onResponse: async (response) => {\n            await this.respondWith(response)\n          },\n          onRequestError: () => {\n            this.errorWith(new TypeError('Network error'))\n          },\n          onError: (error) => {\n            this.logger.info('request errored!', { error })\n\n            if (error instanceof Error) {\n              this.errorWith(error)\n            }\n          },\n        })\n\n        if (!isRequestHandled) {\n          this.logger.info(\n            'no mocked response received, performing request as-is...'\n          )\n        }\n      }\n\n      xhrRequestController.onResponse = async function ({\n        response,\n        isMockedResponse,\n        request,\n        requestId,\n      }) {\n        this.logger.info(\n          'emitting the \"response\" event for %s listener(s)...',\n          emitter.listenerCount('response')\n        )\n\n        emitter.emit('response', {\n          response,\n          isMockedResponse,\n          request,\n          requestId,\n        })\n      }\n\n      // Return the proxied request from the controller\n      // so that the controller can react to the consumer's interactions\n      // with this request (opening/sending/etc).\n      return xhrRequestController.request\n    },\n  })\n\n  return XMLHttpRequestProxy\n}\n","import {\n  Interceptor,\n  BatchInterceptor,\n  HttpRequestEventMap,\n} from '@mswjs/interceptors'\nimport { FetchInterceptor } from '@mswjs/interceptors/fetch'\nimport { XMLHttpRequestInterceptor } from '@mswjs/interceptors/XMLHttpRequest'\nimport { SetupWorkerInternalContext, StartOptions } from '../glossary'\nimport type { RequiredDeep } from '~/core/typeUtils'\nimport { handleRequest } from '~/core/utils/handleRequest'\nimport { isHandlerKind } from '~/core/utils/internal/isHandlerKind'\n\nexport function createFallbackRequestListener(\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n): Interceptor<HttpRequestEventMap> {\n  const interceptor = new BatchInterceptor({\n    name: 'fallback',\n    interceptors: [new FetchInterceptor(), new XMLHttpRequestInterceptor()],\n  })\n\n  interceptor.on('request', async ({ request, requestId, controller }) => {\n    const requestCloneForLogs = request.clone()\n\n    const response = await handleRequest(\n      request,\n      requestId,\n      context.getRequestHandlers().filter(isHandlerKind('RequestHandler')),\n      options,\n      context.emitter,\n      {\n        onMockedResponse(_, { handler, parsedResult }) {\n          if (!options.quiet) {\n            context.emitter.once('response:mocked', ({ response }) => {\n              handler.log({\n                request: requestCloneForLogs,\n                response,\n                parsedResult,\n              })\n            })\n          }\n        },\n      },\n    )\n\n    if (response) {\n      controller.respondWith(response)\n    }\n  })\n\n  interceptor.on(\n    'response',\n    ({ response, isMockedResponse, request, requestId }) => {\n      context.emitter.emit(\n        isMockedResponse ? 'response:mocked' : 'response:bypass',\n        {\n          response,\n          request,\n          requestId,\n        },\n      )\n    },\n  )\n\n  interceptor.apply()\n\n  return interceptor\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\n\nexport function printStopMessage(args: { quiet?: boolean } = {}): void {\n  if (args.quiet) {\n    return\n  }\n\n  // eslint-disable-next-line no-console\n  console.log(\n    `%c${devUtils.formatMessage('Mocking disabled.')}`,\n    'color:orangered;font-weight:bold;',\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}