{"ast":null,"code":"/**\n * Check if `vhost` is a valid suffix of `hostname` (top-domain)\n *\n * It means that `vhost` needs to be a suffix of `hostname` and we then need to\n * make sure that: either they are equal, or the character preceding `vhost` in\n * `hostname` is a '.' (it should not be a partial label).\n *\n * * hostname = 'not.evil.com' and vhost = 'vil.com'      => not ok\n * * hostname = 'not.evil.com' and vhost = 'evil.com'     => ok\n * * hostname = 'not.evil.com' and vhost = 'not.evil.com' => ok\n */\nfunction shareSameDomainSuffix(hostname, vhost) {\n  if (hostname.endsWith(vhost)) {\n    return hostname.length === vhost.length || hostname[hostname.length - vhost.length - 1] === '.';\n  }\n  return false;\n}\n/**\n * Given a hostname and its public suffix, extract the general domain.\n */\nfunction extractDomainWithSuffix(hostname, publicSuffix) {\n  // Locate the index of the last '.' in the part of the `hostname` preceding\n  // the public suffix.\n  //\n  // examples:\n  //   1. not.evil.co.uk  => evil.co.uk\n  //         ^    ^\n  //         |    | start of public suffix\n  //         | index of the last dot\n  //\n  //   2. example.co.uk   => example.co.uk\n  //     ^       ^\n  //     |       | start of public suffix\n  //     |\n  //     | (-1) no dot found before the public suffix\n  const publicSuffixIndex = hostname.length - publicSuffix.length - 2;\n  const lastDotBeforeSuffixIndex = hostname.lastIndexOf('.', publicSuffixIndex);\n  // No '.' found, then `hostname` is the general domain (no sub-domain)\n  if (lastDotBeforeSuffixIndex === -1) {\n    return hostname;\n  }\n  // Extract the part between the last '.'\n  return hostname.slice(lastDotBeforeSuffixIndex + 1);\n}\n/**\n * Detects the domain based on rules and upon and a host string\n */\nexport default function getDomain(suffix, hostname, options) {\n  // Check if `hostname` ends with a member of `validHosts`.\n  if (options.validHosts !== null) {\n    const validHosts = options.validHosts;\n    for (const vhost of validHosts) {\n      if (/*@__INLINE__*/shareSameDomainSuffix(hostname, vhost)) {\n        return vhost;\n      }\n    }\n  }\n  let numberOfLeadingDots = 0;\n  if (hostname.startsWith('.')) {\n    while (numberOfLeadingDots < hostname.length && hostname[numberOfLeadingDots] === '.') {\n      numberOfLeadingDots += 1;\n    }\n  }\n  // If `hostname` is a valid public suffix, then there is no domain to return.\n  // Since we already know that `getPublicSuffix` returns a suffix of `hostname`\n  // there is no need to perform a string comparison and we only compare the\n  // size.\n  if (suffix.length === hostname.length - numberOfLeadingDots) {\n    return null;\n  }\n  // To extract the general domain, we start by identifying the public suffix\n  // (if any), then consider the domain to be the public suffix with one added\n  // level of depth. (e.g.: if hostname is `not.evil.co.uk` and public suffix:\n  // `co.uk`, then we take one more level: `evil`, giving the final result:\n  // `evil.co.uk`).\n  return /*@__INLINE__*/extractDomainWithSuffix(hostname, suffix);\n}","map":{"version":3,"names":["shareSameDomainSuffix","hostname","vhost","endsWith","length","extractDomainWithSuffix","publicSuffix","publicSuffixIndex","lastDotBeforeSuffixIndex","lastIndexOf","slice","getDomain","suffix","options","validHosts","numberOfLeadingDots","startsWith"],"sources":["C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\tldts-core\\src\\domain.ts"],"sourcesContent":["import { IOptions } from './options';\n\n/**\n * Check if `vhost` is a valid suffix of `hostname` (top-domain)\n *\n * It means that `vhost` needs to be a suffix of `hostname` and we then need to\n * make sure that: either they are equal, or the character preceding `vhost` in\n * `hostname` is a '.' (it should not be a partial label).\n *\n * * hostname = 'not.evil.com' and vhost = 'vil.com'      => not ok\n * * hostname = 'not.evil.com' and vhost = 'evil.com'     => ok\n * * hostname = 'not.evil.com' and vhost = 'not.evil.com' => ok\n */\nfunction shareSameDomainSuffix(hostname: string, vhost: string): boolean {\n  if (hostname.endsWith(vhost)) {\n    return (\n      hostname.length === vhost.length ||\n      hostname[hostname.length - vhost.length - 1] === '.'\n    );\n  }\n\n  return false;\n}\n\n/**\n * Given a hostname and its public suffix, extract the general domain.\n */\nfunction extractDomainWithSuffix(\n  hostname: string,\n  publicSuffix: string,\n): string {\n  // Locate the index of the last '.' in the part of the `hostname` preceding\n  // the public suffix.\n  //\n  // examples:\n  //   1. not.evil.co.uk  => evil.co.uk\n  //         ^    ^\n  //         |    | start of public suffix\n  //         | index of the last dot\n  //\n  //   2. example.co.uk   => example.co.uk\n  //     ^       ^\n  //     |       | start of public suffix\n  //     |\n  //     | (-1) no dot found before the public suffix\n  const publicSuffixIndex = hostname.length - publicSuffix.length - 2;\n  const lastDotBeforeSuffixIndex = hostname.lastIndexOf('.', publicSuffixIndex);\n\n  // No '.' found, then `hostname` is the general domain (no sub-domain)\n  if (lastDotBeforeSuffixIndex === -1) {\n    return hostname;\n  }\n\n  // Extract the part between the last '.'\n  return hostname.slice(lastDotBeforeSuffixIndex + 1);\n}\n\n/**\n * Detects the domain based on rules and upon and a host string\n */\nexport default function getDomain(\n  suffix: string,\n  hostname: string,\n  options: IOptions,\n): string | null {\n  // Check if `hostname` ends with a member of `validHosts`.\n  if (options.validHosts !== null) {\n    const validHosts = options.validHosts;\n    for (const vhost of validHosts) {\n      if (/*@__INLINE__*/ shareSameDomainSuffix(hostname, vhost)) {\n        return vhost;\n      }\n    }\n  }\n\n  let numberOfLeadingDots = 0;\n  if (hostname.startsWith('.')) {\n    while (\n      numberOfLeadingDots < hostname.length &&\n      hostname[numberOfLeadingDots] === '.'\n    ) {\n      numberOfLeadingDots += 1;\n    }\n  }\n\n  // If `hostname` is a valid public suffix, then there is no domain to return.\n  // Since we already know that `getPublicSuffix` returns a suffix of `hostname`\n  // there is no need to perform a string comparison and we only compare the\n  // size.\n  if (suffix.length === hostname.length - numberOfLeadingDots) {\n    return null;\n  }\n\n  // To extract the general domain, we start by identifying the public suffix\n  // (if any), then consider the domain to be the public suffix with one added\n  // level of depth. (e.g.: if hostname is `not.evil.co.uk` and public suffix:\n  // `co.uk`, then we take one more level: `evil`, giving the final result:\n  // `evil.co.uk`).\n  return /*@__INLINE__*/ extractDomainWithSuffix(hostname, suffix);\n}\n"],"mappings":"AAEA;;;;;;;;;;;AAWA,SAASA,qBAAqBA,CAACC,QAAgB,EAAEC,KAAa;EAC5D,IAAID,QAAQ,CAACE,QAAQ,CAACD,KAAK,CAAC,EAAE;IAC5B,OACED,QAAQ,CAACG,MAAM,KAAKF,KAAK,CAACE,MAAM,IAChCH,QAAQ,CAACA,QAAQ,CAACG,MAAM,GAAGF,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG;EAExD;EAEA,OAAO,KAAK;AACd;AAEA;;;AAGA,SAASC,uBAAuBA,CAC9BJ,QAAgB,EAChBK,YAAoB;EAEpB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAMC,iBAAiB,GAAGN,QAAQ,CAACG,MAAM,GAAGE,YAAY,CAACF,MAAM,GAAG,CAAC;EACnE,MAAMI,wBAAwB,GAAGP,QAAQ,CAACQ,WAAW,CAAC,GAAG,EAAEF,iBAAiB,CAAC;EAE7E;EACA,IAAIC,wBAAwB,KAAK,CAAC,CAAC,EAAE;IACnC,OAAOP,QAAQ;EACjB;EAEA;EACA,OAAOA,QAAQ,CAACS,KAAK,CAACF,wBAAwB,GAAG,CAAC,CAAC;AACrD;AAEA;;;AAGA,eAAc,SAAUG,SAASA,CAC/BC,MAAc,EACdX,QAAgB,EAChBY,OAAiB;EAEjB;EACA,IAAIA,OAAO,CAACC,UAAU,KAAK,IAAI,EAAE;IAC/B,MAAMA,UAAU,GAAGD,OAAO,CAACC,UAAU;IACrC,KAAK,MAAMZ,KAAK,IAAIY,UAAU,EAAE;MAC9B,IAAI,eAAgBd,qBAAqB,CAACC,QAAQ,EAAEC,KAAK,CAAC,EAAE;QAC1D,OAAOA,KAAK;MACd;IACF;EACF;EAEA,IAAIa,mBAAmB,GAAG,CAAC;EAC3B,IAAId,QAAQ,CAACe,UAAU,CAAC,GAAG,CAAC,EAAE;IAC5B,OACED,mBAAmB,GAAGd,QAAQ,CAACG,MAAM,IACrCH,QAAQ,CAACc,mBAAmB,CAAC,KAAK,GAAG,EACrC;MACAA,mBAAmB,IAAI,CAAC;IAC1B;EACF;EAEA;EACA;EACA;EACA;EACA,IAAIH,MAAM,CAACR,MAAM,KAAKH,QAAQ,CAACG,MAAM,GAAGW,mBAAmB,EAAE;IAC3D,OAAO,IAAI;EACb;EAEA;EACA;EACA;EACA;EACA;EACA,OAAO,eAAgBV,uBAAuB,CAACJ,QAAQ,EAAEW,MAAM,CAAC;AAClE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}