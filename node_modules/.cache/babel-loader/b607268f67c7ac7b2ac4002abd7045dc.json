{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _chunkA7U44ARPjs = require('./chunk-A7U44ARP.js');\n\n// src/BatchInterceptor.ts\nvar BatchInterceptor = class extends _chunkA7U44ARPjs.Interceptor {\n  constructor(options) {\n    BatchInterceptor.symbol = Symbol(options.name);\n    super(BatchInterceptor.symbol);\n    this.interceptors = options.interceptors;\n  }\n  setup() {\n    const logger = this.logger.extend(\"setup\");\n    logger.info(\"applying all %d interceptors...\", this.interceptors.length);\n    for (const interceptor of this.interceptors) {\n      logger.info('applying \"%s\" interceptor...', interceptor.constructor.name);\n      interceptor.apply();\n      logger.info(\"adding interceptor dispose subscription\");\n      this.subscriptions.push(() => interceptor.dispose());\n    }\n  }\n  on(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.on(event, listener);\n    }\n    return this;\n  }\n  once(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.once(event, listener);\n    }\n    return this;\n  }\n  off(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.off(event, listener);\n    }\n    return this;\n  }\n  removeAllListeners(event) {\n    for (const interceptors of this.interceptors) {\n      interceptors.removeAllListeners(event);\n    }\n    return this;\n  }\n};\nexports.BatchInterceptor = BatchInterceptor;","map":{"version":3,"names":["BatchInterceptor","_chunkA7U44ARPjs","Interceptor","constructor","options","symbol","Symbol","name","interceptors","setup","logger","extend","info","length","interceptor","apply","subscriptions","push","dispose","on","event","listener","once","off","removeAllListeners"],"sources":["../../src/BatchInterceptor.ts"],"sourcesContent":["import { EventMap, Listener } from 'strict-event-emitter'\nimport { Interceptor, ExtractEventNames } from './Interceptor'\n\nexport interface BatchInterceptorOptions<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> {\n  name: string\n  interceptors: InterceptorList\n}\n\nexport type ExtractEventMapType<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> = InterceptorList extends ReadonlyArray<infer InterceptorType>\n  ? InterceptorType extends Interceptor<infer EventMap>\n    ? EventMap\n    : never\n  : never\n\n/**\n * A batch interceptor that exposes a single interface\n * to apply and operate with multiple interceptors at once.\n */\nexport class BatchInterceptor<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>,\n  Events extends EventMap = ExtractEventMapType<InterceptorList>\n> extends Interceptor<Events> {\n  static symbol: symbol\n\n  private interceptors: InterceptorList\n\n  constructor(options: BatchInterceptorOptions<InterceptorList>) {\n    BatchInterceptor.symbol = Symbol(options.name)\n    super(BatchInterceptor.symbol)\n    this.interceptors = options.interceptors\n  }\n\n  protected setup() {\n    const logger = this.logger.extend('setup')\n\n    logger.info('applying all %d interceptors...', this.interceptors.length)\n\n    for (const interceptor of this.interceptors) {\n      logger.info('applying \"%s\" interceptor...', interceptor.constructor.name)\n      interceptor.apply()\n\n      logger.info('adding interceptor dispose subscription')\n      this.subscriptions.push(() => interceptor.dispose())\n    }\n  }\n\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    // Instead of adding a listener to the batch interceptor,\n    // propagate the listener to each of the individual interceptors.\n    for (const interceptor of this.interceptors) {\n      interceptor.on(event, listener)\n    }\n\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.once(event, listener)\n    }\n\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.off(event, listener)\n    }\n\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName | undefined\n  ): this {\n    for (const interceptors of this.interceptors) {\n      interceptors.removeAllListeners(event)\n    }\n\n    return this\n  }\n}\n"],"mappings":";;;;;;;;AAsBO,IAAMA,gBAAA,GAAN,cAGGC,gBAAoB,CAAAC,WAAA;EAK5BC,YAAYC,OAAA,EAAmD;IAC7DJ,gBAAA,CAAiBK,MAAA,GAASC,MAAA,CAAOF,OAAA,CAAQG,IAAI;IAC7C,MAAMP,gBAAA,CAAiBK,MAAM;IAC7B,KAAKG,YAAA,GAAeJ,OAAA,CAAQI,YAAA;EAC9B;EAEUC,MAAA,EAAQ;IAChB,MAAMC,MAAA,GAAS,KAAKA,MAAA,CAAOC,MAAA,CAAO,OAAO;IAEzCD,MAAA,CAAOE,IAAA,CAAK,mCAAmC,KAAKJ,YAAA,CAAaK,MAAM;IAEvE,WAAWC,WAAA,IAAe,KAAKN,YAAA,EAAc;MAC3CE,MAAA,CAAOE,IAAA,CAAK,gCAAgCE,WAAA,CAAYX,WAAA,CAAYI,IAAI;MACxEO,WAAA,CAAYC,KAAA,CAAM;MAElBL,MAAA,CAAOE,IAAA,CAAK,yCAAyC;MACrD,KAAKI,aAAA,CAAcC,IAAA,CAAK,MAAMH,WAAA,CAAYI,OAAA,CAAQ,CAAC;IACrD;EACF;EAEOC,GACLC,KAAA,EACAC,QAAA,EACM;IAGN,WAAWP,WAAA,IAAe,KAAKN,YAAA,EAAc;MAC3CM,WAAA,CAAYK,EAAA,CAAGC,KAAA,EAAOC,QAAQ;IAChC;IAEA,OAAO;EACT;EAEOC,KACLF,KAAA,EACAC,QAAA,EACM;IACN,WAAWP,WAAA,IAAe,KAAKN,YAAA,EAAc;MAC3CM,WAAA,CAAYQ,IAAA,CAAKF,KAAA,EAAOC,QAAQ;IAClC;IAEA,OAAO;EACT;EAEOE,IACLH,KAAA,EACAC,QAAA,EACM;IACN,WAAWP,WAAA,IAAe,KAAKN,YAAA,EAAc;MAC3CM,WAAA,CAAYS,GAAA,CAAIH,KAAA,EAAOC,QAAQ;IACjC;IAEA,OAAO;EACT;EAEOG,mBACLJ,KAAA,EACM;IACN,WAAWZ,YAAA,IAAgB,KAAKA,YAAA,EAAc;MAC5CA,YAAA,CAAagB,kBAAA,CAAmBJ,KAAK;IACvC;IAEA,OAAO;EACT;AACF","ignoreList":[]},"metadata":{},"sourceType":"script"}