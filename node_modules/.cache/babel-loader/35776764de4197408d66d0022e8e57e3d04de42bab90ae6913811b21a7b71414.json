{"ast":null,"code":"import { Emitter } from \"strict-event-emitter\";\nimport { createRequestId } from \"@mswjs/interceptors\";\nimport { matchRequestUrl } from '../utils/matching/matchRequestUrl.mjs';\nimport { getCallFrame } from '../utils/internal/getCallFrame.mjs';\nconst kEmitter = Symbol(\"kEmitter\");\nconst kSender = Symbol(\"kSender\");\nconst kStopPropagationPatched = Symbol(\"kStopPropagationPatched\");\nconst KOnStopPropagation = Symbol(\"KOnStopPropagation\");\nclass WebSocketHandler {\n  constructor(url) {\n    this.url = url;\n    this.id = createRequestId();\n    this[kEmitter] = new Emitter();\n    this.callFrame = getCallFrame(new Error());\n    this.__kind = \"EventHandler\";\n  }\n  __kind;\n  id;\n  callFrame;\n  [kEmitter];\n  parse(args) {\n    const clientUrl = new URL(args.url);\n    clientUrl.pathname = clientUrl.pathname.replace(/^\\/socket.io\\//, \"/\");\n    const match = matchRequestUrl(clientUrl, this.url, args.resolutionContext?.baseUrl);\n    return {\n      match\n    };\n  }\n  predicate(args) {\n    return args.parsedResult.match.matches;\n  }\n  async run(connection, resolutionContext) {\n    const parsedResult = this.parse({\n      url: connection.client.url,\n      resolutionContext\n    });\n    if (!this.predicate({\n      url: connection.client.url,\n      parsedResult\n    })) {\n      return false;\n    }\n    const resolvedConnection = {\n      ...connection,\n      params: parsedResult.match.params || {}\n    };\n    return this.connect(resolvedConnection);\n  }\n  connect(connection) {\n    connection.client.addEventListener(\"message\", createStopPropagationListener(this));\n    connection.client.addEventListener(\"close\", createStopPropagationListener(this));\n    connection.server.addEventListener(\"open\", createStopPropagationListener(this));\n    connection.server.addEventListener(\"message\", createStopPropagationListener(this));\n    connection.server.addEventListener(\"error\", createStopPropagationListener(this));\n    connection.server.addEventListener(\"close\", createStopPropagationListener(this));\n    return this[kEmitter].emit(\"connection\", connection);\n  }\n}\nfunction createStopPropagationListener(handler) {\n  return function stopPropagationListener(event) {\n    const propagationStoppedAt = Reflect.get(event, \"kPropagationStoppedAt\");\n    if (propagationStoppedAt && handler.id !== propagationStoppedAt) {\n      event.stopImmediatePropagation();\n      return;\n    }\n    Object.defineProperty(event, KOnStopPropagation, {\n      value() {\n        Object.defineProperty(event, \"kPropagationStoppedAt\", {\n          value: handler.id\n        });\n      },\n      configurable: true\n    });\n    if (!Reflect.get(event, kStopPropagationPatched)) {\n      event.stopPropagation = new Proxy(event.stopPropagation, {\n        apply: (target, thisArg, args) => {\n          Reflect.get(event, KOnStopPropagation)?.call(handler);\n          return Reflect.apply(target, thisArg, args);\n        }\n      });\n      Object.defineProperty(event, kStopPropagationPatched, {\n        value: true,\n        // If something else attempts to redefine this, throw.\n        configurable: false\n      });\n    }\n  };\n}\nexport { WebSocketHandler, kEmitter, kSender };\n//# sourceMappingURL=WebSocketHandler.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}