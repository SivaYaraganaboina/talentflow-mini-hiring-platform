{"ast":null,"code":"class OfflineQueue {\n  constructor() {\n    this.queue = [];\n    this.isOnline = navigator.onLine;\n    this.maxRetries = 3;\n    this.retryDelay = 1000;\n    this.loadQueue();\n    this.setupEventListeners();\n    this.processQueue();\n  }\n  setupEventListeners() {\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      this.processQueue();\n    });\n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n    });\n  }\n  loadQueue() {\n    try {\n      const stored = localStorage.getItem('offlineQueue');\n      if (stored) {\n        this.queue = JSON.parse(stored);\n      }\n    } catch (error) {\n      console.error('Failed to load offline queue:', error);\n      this.queue = [];\n    }\n  }\n  saveQueue() {\n    try {\n      localStorage.setItem('offlineQueue', JSON.stringify(this.queue));\n    } catch (error) {\n      console.error('Failed to save offline queue:', error);\n    }\n  }\n  addRequest(url, options = {}) {\n    const request = {\n      id: `${Date.now()}-${Math.random()}`,\n      url,\n      method: options.method || 'GET',\n      body: options.body ? JSON.parse(options.body) : undefined,\n      headers: options.headers,\n      timestamp: Date.now(),\n      retryCount: 0\n    };\n    this.queue.push(request);\n    this.saveQueue();\n    if (this.isOnline) {\n      this.processQueue();\n    }\n    return request.id;\n  }\n  async processQueue() {\n    if (!this.isOnline || this.queue.length === 0) return;\n    const request = this.queue[0];\n    try {\n      const response = await fetch(request.url, {\n        method: request.method,\n        headers: {\n          'Content-Type': 'application/json',\n          ...request.headers\n        },\n        body: request.body ? JSON.stringify(request.body) : undefined\n      });\n      if (response.ok) {\n        // Success - remove from queue\n        this.queue.shift();\n        this.saveQueue();\n\n        // Process next request\n        setTimeout(() => this.processQueue(), 100);\n      } else {\n        throw new Error(`HTTP ${response.status}`);\n      }\n    } catch (error) {\n      console.error('Failed to process queued request:', error);\n      request.retryCount++;\n      if (request.retryCount >= this.maxRetries) {\n        // Max retries reached - remove from queue\n        this.queue.shift();\n        console.error('Max retries reached for request:', request.url);\n      }\n      this.saveQueue();\n\n      // Retry after delay\n      setTimeout(() => this.processQueue(), this.retryDelay * request.retryCount);\n    }\n  }\n  getQueueLength() {\n    return this.queue.length;\n  }\n  clearQueue() {\n    this.queue = [];\n    this.saveQueue();\n  }\n}\nexport const offlineQueue = new OfflineQueue();","map":{"version":3,"names":["OfflineQueue","constructor","queue","isOnline","navigator","onLine","maxRetries","retryDelay","loadQueue","setupEventListeners","processQueue","window","addEventListener","stored","localStorage","getItem","JSON","parse","error","console","saveQueue","setItem","stringify","addRequest","url","options","request","id","Date","now","Math","random","method","body","undefined","headers","timestamp","retryCount","push","length","response","fetch","ok","shift","setTimeout","Error","status","getQueueLength","clearQueue","offlineQueue"],"sources":["C:/Users/shiva/Desktop/talentflow-mini-hiring-platform/TalentFlow/src/services/offlineQueue.ts"],"sourcesContent":["interface QueuedRequest {\n  id: string;\n  url: string;\n  method: string;\n  body?: any;\n  headers?: Record<string, string>;\n  timestamp: number;\n  retryCount: number;\n}\n\nclass OfflineQueue {\n  private queue: QueuedRequest[] = [];\n  private isOnline = navigator.onLine;\n  private maxRetries = 3;\n  private retryDelay = 1000;\n\n  constructor() {\n    this.loadQueue();\n    this.setupEventListeners();\n    this.processQueue();\n  }\n\n  private setupEventListeners() {\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      this.processQueue();\n    });\n\n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n    });\n  }\n\n  private loadQueue() {\n    try {\n      const stored = localStorage.getItem('offlineQueue');\n      if (stored) {\n        this.queue = JSON.parse(stored);\n      }\n    } catch (error) {\n      console.error('Failed to load offline queue:', error);\n      this.queue = [];\n    }\n  }\n\n  private saveQueue() {\n    try {\n      localStorage.setItem('offlineQueue', JSON.stringify(this.queue));\n    } catch (error) {\n      console.error('Failed to save offline queue:', error);\n    }\n  }\n\n  public addRequest(url: string, options: RequestInit = {}) {\n    const request: QueuedRequest = {\n      id: `${Date.now()}-${Math.random()}`,\n      url,\n      method: options.method || 'GET',\n      body: options.body ? JSON.parse(options.body as string) : undefined,\n      headers: options.headers as Record<string, string>,\n      timestamp: Date.now(),\n      retryCount: 0\n    };\n\n    this.queue.push(request);\n    this.saveQueue();\n\n    if (this.isOnline) {\n      this.processQueue();\n    }\n\n    return request.id;\n  }\n\n  private async processQueue() {\n    if (!this.isOnline || this.queue.length === 0) return;\n\n    const request = this.queue[0];\n    \n    try {\n      const response = await fetch(request.url, {\n        method: request.method,\n        headers: {\n          'Content-Type': 'application/json',\n          ...request.headers\n        },\n        body: request.body ? JSON.stringify(request.body) : undefined\n      });\n\n      if (response.ok) {\n        // Success - remove from queue\n        this.queue.shift();\n        this.saveQueue();\n        \n        // Process next request\n        setTimeout(() => this.processQueue(), 100);\n      } else {\n        throw new Error(`HTTP ${response.status}`);\n      }\n    } catch (error) {\n      console.error('Failed to process queued request:', error);\n      \n      request.retryCount++;\n      \n      if (request.retryCount >= this.maxRetries) {\n        // Max retries reached - remove from queue\n        this.queue.shift();\n        console.error('Max retries reached for request:', request.url);\n      }\n      \n      this.saveQueue();\n      \n      // Retry after delay\n      setTimeout(() => this.processQueue(), this.retryDelay * request.retryCount);\n    }\n  }\n\n  public getQueueLength(): number {\n    return this.queue.length;\n  }\n\n  public clearQueue() {\n    this.queue = [];\n    this.saveQueue();\n  }\n}\n\nexport const offlineQueue = new OfflineQueue();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}