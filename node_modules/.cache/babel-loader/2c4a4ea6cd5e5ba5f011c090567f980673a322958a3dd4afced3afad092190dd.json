{"ast":null,"code":"/**\n * @param url - URL we want to extract a hostname from.\n * @param urlIsValidHostname - hint from caller; true if `url` is already a valid hostname.\n */\nexport default function extractHostname(url, urlIsValidHostname) {\n  let start = 0;\n  let end = url.length;\n  let hasUpper = false;\n  // If url is not already a valid hostname, then try to extract hostname.\n  if (!urlIsValidHostname) {\n    // Special handling of data URLs\n    if (url.startsWith('data:')) {\n      return null;\n    }\n    // Trim leading spaces\n    while (start < url.length && url.charCodeAt(start) <= 32) {\n      start += 1;\n    }\n    // Trim trailing spaces\n    while (end > start + 1 && url.charCodeAt(end - 1) <= 32) {\n      end -= 1;\n    }\n    // Skip scheme.\n    if (url.charCodeAt(start) === 47 /* '/' */ && url.charCodeAt(start + 1) === 47 /* '/' */) {\n      start += 2;\n    } else {\n      const indexOfProtocol = url.indexOf(':/', start);\n      if (indexOfProtocol !== -1) {\n        // Implement fast-path for common protocols. We expect most protocols\n        // should be one of these 4 and thus we will not need to perform the\n        // more expansive validity check most of the time.\n        const protocolSize = indexOfProtocol - start;\n        const c0 = url.charCodeAt(start);\n        const c1 = url.charCodeAt(start + 1);\n        const c2 = url.charCodeAt(start + 2);\n        const c3 = url.charCodeAt(start + 3);\n        const c4 = url.charCodeAt(start + 4);\n        if (protocolSize === 5 && c0 === 104 /* 'h' */ && c1 === 116 /* 't' */ && c2 === 116 /* 't' */ && c3 === 112 /* 'p' */ && c4 === 115 /* 's' */) {\n          // https\n        } else if (protocolSize === 4 && c0 === 104 /* 'h' */ && c1 === 116 /* 't' */ && c2 === 116 /* 't' */ && c3 === 112 /* 'p' */) {\n          // http\n        } else if (protocolSize === 3 && c0 === 119 /* 'w' */ && c1 === 115 /* 's' */ && c2 === 115 /* 's' */) {\n          // wss\n        } else if (protocolSize === 2 && c0 === 119 /* 'w' */ && c1 === 115 /* 's' */) {\n          // ws\n        } else {\n          // Check that scheme is valid\n          for (let i = start; i < indexOfProtocol; i += 1) {\n            const lowerCaseCode = url.charCodeAt(i) | 32;\n            if (!(lowerCaseCode >= 97 && lowerCaseCode <= 122 ||\n            // [a, z]\n            lowerCaseCode >= 48 && lowerCaseCode <= 57 ||\n            // [0, 9]\n            lowerCaseCode === 46 ||\n            // '.'\n            lowerCaseCode === 45 ||\n            // '-'\n            lowerCaseCode === 43 // '+'\n            )) {\n              return null;\n            }\n          }\n        }\n        // Skip 0, 1 or more '/' after ':/'\n        start = indexOfProtocol + 2;\n        while (url.charCodeAt(start) === 47 /* '/' */) {\n          start += 1;\n        }\n      }\n    }\n    // Detect first occurrence of '/', '?' or '#'. We also keep track of the\n    // last occurrence of '@', ']' or ':' to speed-up subsequent parsing of\n    // (respectively), identifier, ipv6 or port.\n    let indexOfIdentifier = -1;\n    let indexOfClosingBracket = -1;\n    let indexOfPort = -1;\n    for (let i = start; i < end; i += 1) {\n      const code = url.charCodeAt(i);\n      if (code === 35 ||\n      // '#'\n      code === 47 ||\n      // '/'\n      code === 63 // '?'\n      ) {\n        end = i;\n        break;\n      } else if (code === 64) {\n        // '@'\n        indexOfIdentifier = i;\n      } else if (code === 93) {\n        // ']'\n        indexOfClosingBracket = i;\n      } else if (code === 58) {\n        // ':'\n        indexOfPort = i;\n      } else if (code >= 65 && code <= 90) {\n        hasUpper = true;\n      }\n    }\n    // Detect identifier: '@'\n    if (indexOfIdentifier !== -1 && indexOfIdentifier > start && indexOfIdentifier < end) {\n      start = indexOfIdentifier + 1;\n    }\n    // Handle ipv6 addresses\n    if (url.charCodeAt(start) === 91 /* '[' */) {\n      if (indexOfClosingBracket !== -1) {\n        return url.slice(start + 1, indexOfClosingBracket).toLowerCase();\n      }\n      return null;\n    } else if (indexOfPort !== -1 && indexOfPort > start && indexOfPort < end) {\n      // Detect port: ':'\n      end = indexOfPort;\n    }\n  }\n  // Trim trailing dots\n  while (end > start + 1 && url.charCodeAt(end - 1) === 46 /* '.' */) {\n    end -= 1;\n  }\n  const hostname = start !== 0 || end !== url.length ? url.slice(start, end) : url;\n  if (hasUpper) {\n    return hostname.toLowerCase();\n  }\n  return hostname;\n}","map":{"version":3,"names":["extractHostname","url","urlIsValidHostname","start","end","length","hasUpper","startsWith","charCodeAt","indexOfProtocol","indexOf","protocolSize","c0","c1","c2","c3","c4","i","lowerCaseCode","indexOfIdentifier","indexOfClosingBracket","indexOfPort","code","slice","toLowerCase","hostname"],"sources":["C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\tldts-core\\src\\extract-hostname.ts"],"sourcesContent":["/**\n * @param url - URL we want to extract a hostname from.\n * @param urlIsValidHostname - hint from caller; true if `url` is already a valid hostname.\n */\nexport default function extractHostname(\n  url: string,\n  urlIsValidHostname: boolean,\n): string | null {\n  let start = 0;\n  let end: number = url.length;\n  let hasUpper = false;\n\n  // If url is not already a valid hostname, then try to extract hostname.\n  if (!urlIsValidHostname) {\n    // Special handling of data URLs\n    if (url.startsWith('data:')) {\n      return null;\n    }\n\n    // Trim leading spaces\n    while (start < url.length && url.charCodeAt(start) <= 32) {\n      start += 1;\n    }\n\n    // Trim trailing spaces\n    while (end > start + 1 && url.charCodeAt(end - 1) <= 32) {\n      end -= 1;\n    }\n\n    // Skip scheme.\n    if (\n      url.charCodeAt(start) === 47 /* '/' */ &&\n      url.charCodeAt(start + 1) === 47 /* '/' */\n    ) {\n      start += 2;\n    } else {\n      const indexOfProtocol = url.indexOf(':/', start);\n      if (indexOfProtocol !== -1) {\n        // Implement fast-path for common protocols. We expect most protocols\n        // should be one of these 4 and thus we will not need to perform the\n        // more expansive validity check most of the time.\n        const protocolSize = indexOfProtocol - start;\n        const c0 = url.charCodeAt(start);\n        const c1 = url.charCodeAt(start + 1);\n        const c2 = url.charCodeAt(start + 2);\n        const c3 = url.charCodeAt(start + 3);\n        const c4 = url.charCodeAt(start + 4);\n\n        if (\n          protocolSize === 5 &&\n          c0 === 104 /* 'h' */ &&\n          c1 === 116 /* 't' */ &&\n          c2 === 116 /* 't' */ &&\n          c3 === 112 /* 'p' */ &&\n          c4 === 115 /* 's' */\n        ) {\n          // https\n        } else if (\n          protocolSize === 4 &&\n          c0 === 104 /* 'h' */ &&\n          c1 === 116 /* 't' */ &&\n          c2 === 116 /* 't' */ &&\n          c3 === 112 /* 'p' */\n        ) {\n          // http\n        } else if (\n          protocolSize === 3 &&\n          c0 === 119 /* 'w' */ &&\n          c1 === 115 /* 's' */ &&\n          c2 === 115 /* 's' */\n        ) {\n          // wss\n        } else if (\n          protocolSize === 2 &&\n          c0 === 119 /* 'w' */ &&\n          c1 === 115 /* 's' */\n        ) {\n          // ws\n        } else {\n          // Check that scheme is valid\n          for (let i = start; i < indexOfProtocol; i += 1) {\n            const lowerCaseCode = url.charCodeAt(i) | 32;\n            if (\n              !(\n                (\n                  (lowerCaseCode >= 97 && lowerCaseCode <= 122) || // [a, z]\n                  (lowerCaseCode >= 48 && lowerCaseCode <= 57) || // [0, 9]\n                  lowerCaseCode === 46 || // '.'\n                  lowerCaseCode === 45 || // '-'\n                  lowerCaseCode === 43\n                ) // '+'\n              )\n            ) {\n              return null;\n            }\n          }\n        }\n\n        // Skip 0, 1 or more '/' after ':/'\n        start = indexOfProtocol + 2;\n        while (url.charCodeAt(start) === 47 /* '/' */) {\n          start += 1;\n        }\n      }\n    }\n\n    // Detect first occurrence of '/', '?' or '#'. We also keep track of the\n    // last occurrence of '@', ']' or ':' to speed-up subsequent parsing of\n    // (respectively), identifier, ipv6 or port.\n    let indexOfIdentifier = -1;\n    let indexOfClosingBracket = -1;\n    let indexOfPort = -1;\n    for (let i = start; i < end; i += 1) {\n      const code: number = url.charCodeAt(i);\n      if (\n        code === 35 || // '#'\n        code === 47 || // '/'\n        code === 63 // '?'\n      ) {\n        end = i;\n        break;\n      } else if (code === 64) {\n        // '@'\n        indexOfIdentifier = i;\n      } else if (code === 93) {\n        // ']'\n        indexOfClosingBracket = i;\n      } else if (code === 58) {\n        // ':'\n        indexOfPort = i;\n      } else if (code >= 65 && code <= 90) {\n        hasUpper = true;\n      }\n    }\n\n    // Detect identifier: '@'\n    if (\n      indexOfIdentifier !== -1 &&\n      indexOfIdentifier > start &&\n      indexOfIdentifier < end\n    ) {\n      start = indexOfIdentifier + 1;\n    }\n\n    // Handle ipv6 addresses\n    if (url.charCodeAt(start) === 91 /* '[' */) {\n      if (indexOfClosingBracket !== -1) {\n        return url.slice(start + 1, indexOfClosingBracket).toLowerCase();\n      }\n      return null;\n    } else if (indexOfPort !== -1 && indexOfPort > start && indexOfPort < end) {\n      // Detect port: ':'\n      end = indexOfPort;\n    }\n  }\n\n  // Trim trailing dots\n  while (end > start + 1 && url.charCodeAt(end - 1) === 46 /* '.' */) {\n    end -= 1;\n  }\n\n  const hostname: string =\n    start !== 0 || end !== url.length ? url.slice(start, end) : url;\n\n  if (hasUpper) {\n    return hostname.toLowerCase();\n  }\n\n  return hostname;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}