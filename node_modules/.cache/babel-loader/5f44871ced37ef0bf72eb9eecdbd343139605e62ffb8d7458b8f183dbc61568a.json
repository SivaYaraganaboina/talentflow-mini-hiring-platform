{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/shiva/Desktop/talentflow-mini-hiring-platform/TalentFlow/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"operations\", \"map\"];\nimport { toPublicUrl } from '../request/toPublicUrl.mjs';\nimport { devUtils } from './devUtils.mjs';\nimport { jsonParse } from './jsonParse.mjs';\nimport { parseMultipartData } from './parseMultipartData.mjs';\nfunction parseDocumentNode(node) {\n  var _operationDef$name;\n  const operationDef = node.definitions.find(definition => {\n    return definition.kind === \"OperationDefinition\";\n  });\n  return {\n    operationType: operationDef === null || operationDef === void 0 ? void 0 : operationDef.operation,\n    operationName: operationDef === null || operationDef === void 0 || (_operationDef$name = operationDef.name) === null || _operationDef$name === void 0 ? void 0 : _operationDef$name.value\n  };\n}\nasync function parseQuery(query) {\n  const {\n    parse\n  } = await import(\"graphql\").catch(error => {\n    console.error('[MSW] Failed to parse a GraphQL query: cannot import the \"graphql\" module. Please make sure you install it if you wish to intercept GraphQL requests. See the original import error below.');\n    throw error;\n  });\n  try {\n    const ast = parse(query);\n    return parseDocumentNode(ast);\n  } catch (error) {\n    return error;\n  }\n}\nfunction extractMultipartVariables(variables, map, files) {\n  const operations = {\n    variables\n  };\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(\"Given files do not have a key '\".concat(key, \"' .\"));\n    }\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split(\".\").reverse();\n      const paths = reversedPaths.reverse();\n      let target = operations;\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(\"Property '\".concat(paths, \"' is not in operations.\"));\n        }\n        target = target[path];\n      }\n      target[lastPath] = files[key];\n    }\n  }\n  return operations.variables;\n}\nasync function getGraphQLInput(request) {\n  switch (request.method) {\n    case \"GET\":\n      {\n        const url = new URL(request.url);\n        const query = url.searchParams.get(\"query\");\n        const variables = url.searchParams.get(\"variables\") || \"\";\n        return {\n          query,\n          variables: jsonParse(variables)\n        };\n      }\n    case \"POST\":\n      {\n        var _request$headers$get;\n        const requestClone = request.clone();\n        if ((_request$headers$get = request.headers.get(\"content-type\")) !== null && _request$headers$get !== void 0 && _request$headers$get.includes(\"multipart/form-data\")) {\n          const responseJson = parseMultipartData(await requestClone.text(), request.headers);\n          if (!responseJson) {\n            return null;\n          }\n          const {\n              operations,\n              map\n            } = responseJson,\n            files = _objectWithoutProperties(responseJson, _excluded);\n          const parsedOperations = jsonParse(operations) || {};\n          if (!parsedOperations.query) {\n            return null;\n          }\n          const parsedMap = jsonParse(map || \"\") || {};\n          const variables = parsedOperations.variables ? extractMultipartVariables(parsedOperations.variables, parsedMap, files) : {};\n          return {\n            query: parsedOperations.query,\n            variables\n          };\n        }\n        const requestJson = await requestClone.json().catch(() => null);\n        if (requestJson !== null && requestJson !== void 0 && requestJson.query) {\n          const {\n            query,\n            variables\n          } = requestJson;\n          return {\n            query,\n            variables\n          };\n        }\n        return null;\n      }\n    default:\n      return null;\n  }\n}\nasync function parseGraphQLRequest(request) {\n  const input = await getGraphQLInput(request);\n  if (!input || !input.query) {\n    return;\n  }\n  const {\n    query,\n    variables\n  } = input;\n  const parsedResult = await parseQuery(query);\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = toPublicUrl(request.url);\n    throw new Error(devUtils.formatMessage('Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s', request.method, requestPublicUrl, parsedResult.message));\n  }\n  return {\n    query: input.query,\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables\n  };\n}\nexport { parseDocumentNode, parseGraphQLRequest };","map":{"version":3,"names":["toPublicUrl","devUtils","jsonParse","parseMultipartData","parseDocumentNode","node","_operationDef$name","operationDef","definitions","find","definition","kind","operationType","operation","operationName","name","value","parseQuery","query","parse","catch","error","console","ast","extractMultipartVariables","variables","map","files","operations","key","pathArray","Object","entries","Error","concat","dotPath","lastPath","reversedPaths","split","reverse","paths","target","path","getGraphQLInput","request","method","url","URL","searchParams","get","_request$headers$get","requestClone","clone","headers","includes","responseJson","text","_objectWithoutProperties","_excluded","parsedOperations","parsedMap","requestJson","json","parseGraphQLRequest","input","parsedResult","requestPublicUrl","formatMessage","message"],"sources":["C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\core\\utils\\internal\\parseGraphQLRequest.ts"],"sourcesContent":["import type {\n  DocumentNode,\n  OperationDefinitionNode,\n  OperationTypeNode,\n} from 'graphql'\nimport type { GraphQLVariables } from '../../handlers/GraphQLHandler'\nimport { toPublicUrl } from '../request/toPublicUrl'\nimport { devUtils } from './devUtils'\nimport { jsonParse } from './jsonParse'\nimport { parseMultipartData } from './parseMultipartData'\n\ninterface GraphQLInput {\n  query: string | null\n  variables?: GraphQLVariables\n}\n\nexport interface ParsedGraphQLQuery {\n  operationType: OperationTypeNode\n  operationName?: string\n}\n\nexport type ParsedGraphQLRequest<\n  VariablesType extends GraphQLVariables = GraphQLVariables,\n> =\n  | (ParsedGraphQLQuery & {\n      query: string\n      variables?: VariablesType\n    })\n  | undefined\n\nexport function parseDocumentNode(node: DocumentNode): ParsedGraphQLQuery {\n  const operationDef = node.definitions.find((definition) => {\n    return definition.kind === 'OperationDefinition'\n  }) as OperationDefinitionNode\n\n  return {\n    operationType: operationDef?.operation,\n    operationName: operationDef?.name?.value,\n  }\n}\n\nasync function parseQuery(query: string): Promise<ParsedGraphQLQuery | Error> {\n  /**\n   * @note Use `require` to get the \"graphql\" module here.\n   * It has to be scoped to this function because this module leaks to the\n   * root export. It has to be `require` because tools like Jest have trouble\n   * handling dynamic imports. It gets replaced with a dynamic import on build time.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  const { parse } =await import('graphql').catch((error) => {console.error('[MSW] Failed to parse a GraphQL query: cannot import the \"graphql\" module. Please make sure you install it if you wish to intercept GraphQL requests. See the original import error below.'); throw error})\n\n  try {\n    const ast = parse(query)\n    return parseDocumentNode(ast)\n  } catch (error) {\n    return error as Error\n  }\n}\n\nexport type GraphQLParsedOperationsMap = Record<string, string[]>\nexport type GraphQLMultipartRequestBody = {\n  operations: string\n  map?: string\n} & {\n  [fileName: string]: File\n}\n\nfunction extractMultipartVariables<VariablesType extends GraphQLVariables>(\n  variables: VariablesType,\n  map: GraphQLParsedOperationsMap,\n  files: Record<string, File>,\n) {\n  const operations = { variables }\n\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`)\n    }\n\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split('.').reverse()\n      const paths = reversedPaths.reverse()\n      let target: Record<string, any> = operations\n\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`)\n        }\n\n        target = target[path]\n      }\n\n      target[lastPath] = files[key]\n    }\n  }\n\n  return operations.variables\n}\n\nasync function getGraphQLInput(request: Request): Promise<GraphQLInput | null> {\n  switch (request.method) {\n    case 'GET': {\n      const url = new URL(request.url)\n      const query = url.searchParams.get('query')\n      const variables = url.searchParams.get('variables') || ''\n\n      return {\n        query,\n        variables: jsonParse(variables),\n      }\n    }\n\n    case 'POST': {\n      // Clone the request so we could read its body without locking\n      // the body stream to the downward consumers.\n      const requestClone = request.clone()\n\n      // Handle multipart body GraphQL operations.\n      if (\n        request.headers.get('content-type')?.includes('multipart/form-data')\n      ) {\n        const responseJson = parseMultipartData<GraphQLMultipartRequestBody>(\n          await requestClone.text(),\n          request.headers,\n        )\n\n        if (!responseJson) {\n          return null\n        }\n\n        const { operations, map, ...files } = responseJson\n        const parsedOperations =\n          jsonParse<{ query?: string; variables?: GraphQLVariables }>(\n            operations,\n          ) || {}\n\n        if (!parsedOperations.query) {\n          return null\n        }\n\n        const parsedMap = jsonParse<GraphQLParsedOperationsMap>(map || '') || {}\n        const variables = parsedOperations.variables\n          ? extractMultipartVariables(\n              parsedOperations.variables,\n              parsedMap,\n              files,\n            )\n          : {}\n\n        return {\n          query: parsedOperations.query,\n          variables,\n        }\n      }\n\n      // Handle plain POST GraphQL operations.\n      const requestJson: {\n        query: string\n        variables?: GraphQLVariables\n        operations?: any /** @todo Annotate this */\n      } = await requestClone.json().catch(() => null)\n\n      if (requestJson?.query) {\n        const { query, variables } = requestJson\n\n        return {\n          query,\n          variables,\n        }\n      }\n      return null\n    }\n\n    default:\n      return null\n  }\n}\n\n/**\n * Determines if a given request can be considered a GraphQL request.\n * Does not parse the query and does not guarantee its validity.\n */\nexport async function parseGraphQLRequest(\n  request: Request,\n): Promise<ParsedGraphQLRequest> {\n  const input = await getGraphQLInput(request)\n\n  if (!input || !input.query) {\n    return\n  }\n\n  const { query, variables } = input\n  const parsedResult = await parseQuery(query)\n\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = toPublicUrl(request.url)\n\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message,\n      ),\n    )\n  }\n\n  return {\n    query: input.query,\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}