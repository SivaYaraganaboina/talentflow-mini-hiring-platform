{"ast":null,"code":"// node_modules/.pnpm/outvariant@1.4.3/node_modules/outvariant/lib/index.mjs\nvar POSITIONALS_EXP = /(%?)(%([sdijo]))/g;\nfunction serializePositional(positional, flag) {\n  switch (flag) {\n    case \"s\":\n      return positional;\n    case \"d\":\n    case \"i\":\n      return Number(positional);\n    case \"j\":\n      return JSON.stringify(positional);\n    case \"o\":\n      {\n        if (typeof positional === \"string\") {\n          return positional;\n        }\n        const json = JSON.stringify(positional);\n        if (json === \"{}\" || json === \"[]\" || /^\\[object .+?\\]$/.test(json)) {\n          return positional;\n        }\n        return json;\n      }\n  }\n}\nfunction format(message, ...positionals) {\n  if (positionals.length === 0) {\n    return message;\n  }\n  let positionalIndex = 0;\n  let formattedMessage = message.replace(POSITIONALS_EXP, (match, isEscaped, _, flag) => {\n    const positional = positionals[positionalIndex];\n    const value = serializePositional(positional, flag);\n    if (!isEscaped) {\n      positionalIndex++;\n      return value;\n    }\n    return match;\n  });\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(\" \")}`;\n  }\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, \"%\");\n  return formattedMessage;\n}\nvar STACK_FRAMES_TO_IGNORE = 2;\nfunction cleanErrorStack(error2) {\n  if (!error2.stack) {\n    return;\n  }\n  const nextStack = error2.stack.split(\"\\n\");\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE);\n  error2.stack = nextStack.join(\"\\n\");\n}\nvar InvariantError = class extends Error {\n  constructor(message, ...positionals) {\n    super(message);\n    this.message = message;\n    this.name = \"Invariant Violation\";\n    this.message = format(message, ...positionals);\n    cleanErrorStack(this);\n  }\n};\nvar invariant = (predicate, message, ...positionals) => {\n  if (!predicate) {\n    throw new InvariantError(message, ...positionals);\n  }\n};\ninvariant.as = (ErrorConstructor, predicate, message, ...positionals) => {\n  if (!predicate) {\n    const formatMessage = positionals.length === 0 ? message : format(message, ...positionals);\n    let error2;\n    try {\n      error2 = Reflect.construct(ErrorConstructor, [formatMessage]);\n    } catch (err) {\n      error2 = ErrorConstructor(formatMessage);\n    }\n    throw error2;\n  }\n};\n\n// node_modules/.pnpm/is-node-process@1.2.0/node_modules/is-node-process/lib/index.mjs\nfunction isNodeProcess() {\n  if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n    return true;\n  }\n  if (typeof process !== \"undefined\") {\n    const type = process.type;\n    if (type === \"renderer\" || type === \"worker\") {\n      return false;\n    }\n    return !!(process.versions && process.versions.node);\n  }\n  return false;\n}\n\n// src/browser/setupWorker/start/utils/prepareStartHandler.ts\nimport { mergeRight } from '../core/utils/internal/mergeRight.mjs';\nvar DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: \"/mockServiceWorker.js\",\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: \"warn\",\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n};\n\n// src/browser/setupWorker/start/createStartHandler.ts\nimport { devUtils as devUtils6 } from '../core/utils/internal/devUtils.mjs';\n\n// node_modules/.pnpm/@open-draft+until@2.1.0/node_modules/@open-draft/until/lib/index.mjs\nvar until = async promise => {\n  try {\n    const data = await promise().catch(error2 => {\n      throw error2;\n    });\n    return {\n      error: null,\n      data\n    };\n  } catch (error2) {\n    return {\n      error: error2,\n      data: null\n    };\n  }\n};\n\n// src/browser/setupWorker/start/utils/getWorkerInstance.ts\nimport { devUtils } from '../core/utils/internal/devUtils.mjs';\n\n// src/browser/utils/getAbsoluteWorkerUrl.ts\nfunction getAbsoluteWorkerUrl(workerUrl) {\n  return new URL(workerUrl, location.href).href;\n}\n\n// src/browser/setupWorker/start/utils/getWorkerByRegistration.ts\nfunction getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker) {\n  const allStates = [registration.active, registration.installing, registration.waiting];\n  const relevantStates = allStates.filter(state => {\n    return state != null;\n  });\n  const worker = relevantStates.find(worker2 => {\n    return findWorker(worker2.scriptURL, absoluteWorkerUrl);\n  });\n  return worker || null;\n}\n\n// src/browser/setupWorker/start/utils/getWorkerInstance.ts\nvar getWorkerInstance = async (url, options = {}, findWorker) => {\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n  const mockRegistrations = await navigator.serviceWorker.getRegistrations().then(registrations => registrations.filter(registration => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)));\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    location.reload();\n  }\n  const [existingRegistration] = mockRegistrations;\n  if (existingRegistration) {\n    existingRegistration.update();\n    return [getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker), existingRegistration];\n  }\n  const registrationResult = await until(async () => {\n    const registration = await navigator.serviceWorker.register(url, options);\n    return [\n    // Compare existing worker registration by its worker URL,\n    // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n    getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker), registration];\n  });\n  if (registrationResult.error) {\n    const isWorkerMissing = registrationResult.error.message.includes(\"(404)\");\n    if (isWorkerMissing) {\n      const scopeUrl = new URL(options?.scope || \"/\", location.href);\n      throw new Error(devUtils.formatMessage(`Failed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`));\n    }\n    throw new Error(devUtils.formatMessage(\"Failed to register the Service Worker:\\n\\n%s\", registrationResult.error.message));\n  }\n  return registrationResult.data;\n};\n\n// node_modules/.pnpm/@open-draft+deferred-promise@2.2.0/node_modules/@open-draft/deferred-promise/build/index.mjs\nfunction createDeferredExecutor() {\n  const executor = (resolve, reject) => {\n    executor.state = \"pending\";\n    executor.resolve = data => {\n      if (executor.state !== \"pending\") {\n        return;\n      }\n      executor.result = data;\n      const onFulfilled = value => {\n        executor.state = \"fulfilled\";\n        return value;\n      };\n      return resolve(data instanceof Promise ? data : Promise.resolve(data).then(onFulfilled));\n    };\n    executor.reject = reason => {\n      if (executor.state !== \"pending\") {\n        return;\n      }\n      queueMicrotask(() => {\n        executor.state = \"rejected\";\n      });\n      return reject(executor.rejectionReason = reason);\n    };\n  };\n  return executor;\n}\nvar DeferredPromise = class extends Promise {\n  #executor;\n  resolve;\n  reject;\n  constructor(executor = null) {\n    const deferredExecutor = createDeferredExecutor();\n    super((originalResolve, originalReject) => {\n      deferredExecutor(originalResolve, originalReject);\n      executor?.(deferredExecutor.resolve, deferredExecutor.reject);\n    });\n    this.#executor = deferredExecutor;\n    this.resolve = this.#executor.resolve;\n    this.reject = this.#executor.reject;\n  }\n  get state() {\n    return this.#executor.state;\n  }\n  get rejectionReason() {\n    return this.#executor.rejectionReason;\n  }\n  then(onFulfilled, onRejected) {\n    return this.#decorate(super.then(onFulfilled, onRejected));\n  }\n  catch(onRejected) {\n    return this.#decorate(super.catch(onRejected));\n  }\n  finally(onfinally) {\n    return this.#decorate(super.finally(onfinally));\n  }\n  #decorate(promise) {\n    return Object.defineProperties(promise, {\n      resolve: {\n        configurable: true,\n        value: this.resolve\n      },\n      reject: {\n        configurable: true,\n        value: this.reject\n      }\n    });\n  }\n};\n\n// src/browser/setupWorker/start/utils/printStartMessage.ts\nimport { devUtils as devUtils2 } from '../core/utils/internal/devUtils.mjs';\nfunction printStartMessage(args = {}) {\n  if (args.quiet) {\n    return;\n  }\n  const message = args.message || \"Mocking enabled.\";\n  console.groupCollapsed(`%c${devUtils2.formatMessage(message)}`, \"color:orangered;font-weight:bold;\");\n  console.log(\"%cDocumentation: %chttps://mswjs.io/docs\", \"font-weight:bold\", \"font-weight:normal\");\n  console.log(\"Found an issue? https://github.com/mswjs/msw/issues\");\n  if (args.workerUrl) {\n    console.log(\"Worker script URL:\", args.workerUrl);\n  }\n  if (args.workerScope) {\n    console.log(\"Worker scope:\", args.workerScope);\n  }\n  if (args.client) {\n    console.log(\"Client ID: %s (%s)\", args.client.id, args.client.frameType);\n  }\n  console.groupEnd();\n}\n\n// src/browser/setupWorker/start/utils/enableMocking.ts\nfunction enableMocking(context, options) {\n  const mockingEnabledPromise = new DeferredPromise();\n  context.workerChannel.postMessage(\"MOCK_ACTIVATE\");\n  context.workerChannel.once(\"MOCKING_ENABLED\", async event => {\n    context.isMockingEnabled = true;\n    const worker = await context.workerPromise;\n    printStartMessage({\n      quiet: options.quiet,\n      workerScope: context.registration?.scope,\n      workerUrl: worker.scriptURL,\n      client: event.data.client\n    });\n    mockingEnabledPromise.resolve(true);\n  });\n  return mockingEnabledPromise;\n}\n\n// src/browser/utils/pruneGetRequestBody.ts\nfunction pruneGetRequestBody(request) {\n  if ([\"HEAD\", \"GET\"].includes(request.method)) {\n    return void 0;\n  }\n  return request.body;\n}\n\n// src/browser/utils/deserializeRequest.ts\nfunction deserializeRequest(serializedRequest) {\n  return new Request(serializedRequest.url, {\n    ...serializedRequest,\n    body: pruneGetRequestBody(serializedRequest)\n  });\n}\n\n// src/browser/setupWorker/start/createRequestListener.ts\nimport { RequestHandler } from '../core/handlers/RequestHandler.mjs';\nimport { handleRequest } from '../core/utils/handleRequest.mjs';\nimport { devUtils as devUtils3 } from '../core/utils/internal/devUtils.mjs';\nimport { toResponseInit } from '../core/utils/toResponseInit.mjs';\nimport { isHandlerKind } from '../core/utils/internal/isHandlerKind.mjs';\nvar createRequestListener = (context, options) => {\n  return async event => {\n    if (!context.isMockingEnabled && context.workerStoppedAt && event.data.interceptedAt > context.workerStoppedAt) {\n      event.postMessage(\"PASSTHROUGH\");\n      return;\n    }\n    const requestId = event.data.id;\n    const request = deserializeRequest(event.data);\n    const requestCloneForLogs = request.clone();\n    const requestClone = request.clone();\n    RequestHandler.cache.set(request, requestClone);\n    try {\n      await handleRequest(request, requestId, context.getRequestHandlers().filter(isHandlerKind(\"RequestHandler\")), options, context.emitter, {\n        onPassthroughResponse() {\n          event.postMessage(\"PASSTHROUGH\");\n        },\n        async onMockedResponse(response, {\n          handler,\n          parsedResult\n        }) {\n          const responseClone = response.clone();\n          const responseCloneForLogs = response.clone();\n          const responseInit = toResponseInit(response);\n          if (context.supports.readableStreamTransfer) {\n            const responseStreamOrNull = response.body;\n            event.postMessage(\"MOCK_RESPONSE\", {\n              ...responseInit,\n              body: responseStreamOrNull\n            }, responseStreamOrNull ? [responseStreamOrNull] : void 0);\n          } else {\n            const responseBufferOrNull = response.body === null ? null : await responseClone.arrayBuffer();\n            event.postMessage(\"MOCK_RESPONSE\", {\n              ...responseInit,\n              body: responseBufferOrNull\n            });\n          }\n          if (!options.quiet) {\n            context.emitter.once(\"response:mocked\", () => {\n              handler.log({\n                request: requestCloneForLogs,\n                response: responseCloneForLogs,\n                parsedResult\n              });\n            });\n          }\n        }\n      });\n    } catch (error2) {\n      if (error2 instanceof Error) {\n        devUtils3.error(`Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/http/mocking-responses/error-responses`, request.method, request.url, error2.stack ?? error2);\n        event.postMessage(\"MOCK_RESPONSE\", {\n          status: 500,\n          statusText: \"Request Handler Error\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            name: error2.name,\n            message: error2.message,\n            stack: error2.stack\n          })\n        });\n      }\n    }\n  };\n};\n\n// src/browser/utils/checkWorkerIntegrity.ts\nimport { devUtils as devUtils4 } from '../core/utils/internal/devUtils.mjs';\nfunction checkWorkerIntegrity(context) {\n  const integrityCheckPromise = new DeferredPromise();\n  context.workerChannel.postMessage(\"INTEGRITY_CHECK_REQUEST\");\n  context.workerChannel.once(\"INTEGRITY_CHECK_RESPONSE\", event => {\n    const {\n      checksum,\n      packageVersion\n    } = event.data;\n    if (checksum !== \"4db4a41e972cec1b64cc569c66952d82\") {\n      devUtils4.warn(`The currently registered Service Worker has been generated by a different version of MSW (${packageVersion}) and may not be fully compatible with the installed version.\n\nIt's recommended you update your worker script by running this command:\n\n  \\u2022 npx msw init <PUBLIC_DIR>\n\nYou can also automate this process and make the worker script update automatically upon the library installations. Read more: https://mswjs.io/docs/cli/init.`);\n    }\n    integrityCheckPromise.resolve();\n  });\n  return integrityCheckPromise;\n}\n\n// node_modules/.pnpm/@mswjs+interceptors@0.39.1/node_modules/@mswjs/interceptors/lib/browser/chunk-6HYIRFX2.mjs\nvar encoder = new TextEncoder();\nfunction encodeBuffer(text) {\n  return encoder.encode(text);\n}\nfunction decodeBuffer(buffer, encoding) {\n  const decoder = new TextDecoder(encoding);\n  return decoder.decode(buffer);\n}\nfunction toArrayBuffer(array) {\n  return array.buffer.slice(array.byteOffset, array.byteOffset + array.byteLength);\n}\n\n// node_modules/.pnpm/@mswjs+interceptors@0.39.1/node_modules/@mswjs/interceptors/lib/browser/chunk-3RXCRGL2.mjs\nvar IS_PATCHED_MODULE = Symbol(\"isPatchedModule\");\nfunction canParseUrl(url) {\n  try {\n    new URL(url);\n    return true;\n  } catch (_error) {\n    return false;\n  }\n}\nfunction getValueBySymbol(symbolName, source) {\n  const ownSymbols = Object.getOwnPropertySymbols(source);\n  const symbol = ownSymbols.find(symbol2 => {\n    return symbol2.description === symbolName;\n  });\n  if (symbol) {\n    return Reflect.get(source, symbol);\n  }\n  return;\n}\nvar _FetchResponse = class extends Response {\n  static isConfigurableStatusCode(status) {\n    return status >= 200 && status <= 599;\n  }\n  static isRedirectResponse(status) {\n    return _FetchResponse.STATUS_CODES_WITH_REDIRECT.includes(status);\n  }\n  /**\n   * Returns a boolean indicating whether the given response status\n   * code represents a response that can have a body.\n   */\n  static isResponseWithBody(status) {\n    return !_FetchResponse.STATUS_CODES_WITHOUT_BODY.includes(status);\n  }\n  static setUrl(url, response) {\n    if (!url || url === \"about:\" || !canParseUrl(url)) {\n      return;\n    }\n    const state = getValueBySymbol(\"state\", response);\n    if (state) {\n      state.urlList.push(new URL(url));\n    } else {\n      Object.defineProperty(response, \"url\", {\n        value: url,\n        enumerable: true,\n        configurable: true,\n        writable: false\n      });\n    }\n  }\n  /**\n   * Parses the given raw HTTP headers into a Fetch API `Headers` instance.\n   */\n  static parseRawHeaders(rawHeaders) {\n    const headers = new Headers();\n    for (let line = 0; line < rawHeaders.length; line += 2) {\n      headers.append(rawHeaders[line], rawHeaders[line + 1]);\n    }\n    return headers;\n  }\n  constructor(body, init = {}) {\n    var _a;\n    const status = (_a = init.status) != null ? _a : 200;\n    const safeStatus = _FetchResponse.isConfigurableStatusCode(status) ? status : 200;\n    const finalBody = _FetchResponse.isResponseWithBody(status) ? body : null;\n    super(finalBody, {\n      status: safeStatus,\n      statusText: init.statusText,\n      headers: init.headers\n    });\n    if (status !== safeStatus) {\n      const state = getValueBySymbol(\"state\", this);\n      if (state) {\n        state.status = status;\n      } else {\n        Object.defineProperty(this, \"status\", {\n          value: status,\n          enumerable: true,\n          configurable: true,\n          writable: false\n        });\n      }\n    }\n    _FetchResponse.setUrl(init.url, this);\n  }\n};\nvar FetchResponse = _FetchResponse;\nFetchResponse.STATUS_CODES_WITHOUT_BODY = [101, 103, 204, 205, 304];\nFetchResponse.STATUS_CODES_WITH_REDIRECT = [301, 302, 303, 307, 308];\nvar kRawRequest = Symbol(\"kRawRequest\");\nfunction setRawRequest(request, rawRequest) {\n  Reflect.set(request, kRawRequest, rawRequest);\n}\n\n// node_modules/.pnpm/@open-draft+logger@0.3.0/node_modules/@open-draft/logger/lib/index.mjs\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar colors_exports = {};\n__export(colors_exports, {\n  blue: () => blue,\n  gray: () => gray,\n  green: () => green,\n  red: () => red,\n  yellow: () => yellow\n});\nfunction yellow(text) {\n  return `\\x1B[33m${text}\\x1B[0m`;\n}\nfunction blue(text) {\n  return `\\x1B[34m${text}\\x1B[0m`;\n}\nfunction gray(text) {\n  return `\\x1B[90m${text}\\x1B[0m`;\n}\nfunction red(text) {\n  return `\\x1B[31m${text}\\x1B[0m`;\n}\nfunction green(text) {\n  return `\\x1B[32m${text}\\x1B[0m`;\n}\nvar IS_NODE = isNodeProcess();\nvar Logger = class {\n  constructor(name) {\n    this.name = name;\n    this.prefix = `[${this.name}]`;\n    const LOGGER_NAME = getVariable(\"DEBUG\");\n    const LOGGER_LEVEL = getVariable(\"LOG_LEVEL\");\n    const isLoggingEnabled = LOGGER_NAME === \"1\" || LOGGER_NAME === \"true\" || typeof LOGGER_NAME !== \"undefined\" && this.name.startsWith(LOGGER_NAME);\n    if (isLoggingEnabled) {\n      this.debug = isDefinedAndNotEquals(LOGGER_LEVEL, \"debug\") ? noop : this.debug;\n      this.info = isDefinedAndNotEquals(LOGGER_LEVEL, \"info\") ? noop : this.info;\n      this.success = isDefinedAndNotEquals(LOGGER_LEVEL, \"success\") ? noop : this.success;\n      this.warning = isDefinedAndNotEquals(LOGGER_LEVEL, \"warning\") ? noop : this.warning;\n      this.error = isDefinedAndNotEquals(LOGGER_LEVEL, \"error\") ? noop : this.error;\n    } else {\n      this.info = noop;\n      this.success = noop;\n      this.warning = noop;\n      this.error = noop;\n      this.only = noop;\n    }\n  }\n  prefix;\n  extend(domain) {\n    return new Logger(`${this.name}:${domain}`);\n  }\n  /**\n   * Print a debug message.\n   * @example\n   * logger.debug('no duplicates found, creating a document...')\n   */\n  debug(message, ...positionals) {\n    this.logEntry({\n      level: \"debug\",\n      message: gray(message),\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"gray\"\n      }\n    });\n  }\n  /**\n   * Print an info message.\n   * @example\n   * logger.info('start parsing...')\n   */\n  info(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"blue\"\n      }\n    });\n    const performance2 = new PerformanceEntry();\n    return (message2, ...positionals2) => {\n      performance2.measure();\n      this.logEntry({\n        level: \"info\",\n        message: `${message2} ${gray(`${performance2.deltaTime}ms`)}`,\n        positionals: positionals2,\n        prefix: this.prefix,\n        colors: {\n          prefix: \"blue\"\n        }\n      });\n    };\n  }\n  /**\n   * Print a success message.\n   * @example\n   * logger.success('successfully created document')\n   */\n  success(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: `\\u2714 ${this.prefix}`,\n      colors: {\n        timestamp: \"green\",\n        prefix: \"green\"\n      }\n    });\n  }\n  /**\n   * Print a warning.\n   * @example\n   * logger.warning('found legacy document format')\n   */\n  warning(message, ...positionals) {\n    this.logEntry({\n      level: \"warning\",\n      message,\n      positionals,\n      prefix: `\\u26A0 ${this.prefix}`,\n      colors: {\n        timestamp: \"yellow\",\n        prefix: \"yellow\"\n      }\n    });\n  }\n  /**\n   * Print an error message.\n   * @example\n   * logger.error('something went wrong')\n   */\n  error(message, ...positionals) {\n    this.logEntry({\n      level: \"error\",\n      message,\n      positionals,\n      prefix: `\\u2716 ${this.prefix}`,\n      colors: {\n        timestamp: \"red\",\n        prefix: \"red\"\n      }\n    });\n  }\n  /**\n   * Execute the given callback only when the logging is enabled.\n   * This is skipped in its entirety and has no runtime cost otherwise.\n   * This executes regardless of the log level.\n   * @example\n   * logger.only(() => {\n   *   logger.info('additional info')\n   * })\n   */\n  only(callback) {\n    callback();\n  }\n  createEntry(level, message) {\n    return {\n      timestamp: /* @__PURE__ */new Date(),\n      level,\n      message\n    };\n  }\n  logEntry(args) {\n    const {\n      level,\n      message,\n      prefix,\n      colors: customColors,\n      positionals = []\n    } = args;\n    const entry = this.createEntry(level, message);\n    const timestampColor = customColors?.timestamp || \"gray\";\n    const prefixColor = customColors?.prefix || \"gray\";\n    const colorize = {\n      timestamp: colors_exports[timestampColor],\n      prefix: colors_exports[prefixColor]\n    };\n    const write = this.getWriter(level);\n    write([colorize.timestamp(this.formatTimestamp(entry.timestamp))].concat(prefix != null ? colorize.prefix(prefix) : []).concat(serializeInput(message)).join(\" \"), ...positionals.map(serializeInput));\n  }\n  formatTimestamp(timestamp) {\n    return `${timestamp.toLocaleTimeString(\"en-GB\")}:${timestamp.getMilliseconds()}`;\n  }\n  getWriter(level) {\n    switch (level) {\n      case \"debug\":\n      case \"success\":\n      case \"info\":\n        {\n          return log;\n        }\n      case \"warning\":\n        {\n          return warn;\n        }\n      case \"error\":\n        {\n          return error;\n        }\n    }\n  }\n};\nvar PerformanceEntry = class {\n  startTime;\n  endTime;\n  deltaTime;\n  constructor() {\n    this.startTime = performance.now();\n  }\n  measure() {\n    this.endTime = performance.now();\n    const deltaTime = this.endTime - this.startTime;\n    this.deltaTime = deltaTime.toFixed(2);\n  }\n};\nvar noop = () => void 0;\nfunction log(message, ...positionals) {\n  if (IS_NODE) {\n    process.stdout.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.log(message, ...positionals);\n}\nfunction warn(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.warn(message, ...positionals);\n}\nfunction error(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.error(message, ...positionals);\n}\nfunction getVariable(variableName) {\n  if (IS_NODE) {\n    return process.env[variableName];\n  }\n  return globalThis[variableName]?.toString();\n}\nfunction isDefinedAndNotEquals(value, expected) {\n  return value !== void 0 && value !== expected;\n}\nfunction serializeInput(message) {\n  if (typeof message === \"undefined\") {\n    return \"undefined\";\n  }\n  if (message === null) {\n    return \"null\";\n  }\n  if (typeof message === \"string\") {\n    return message;\n  }\n  if (typeof message === \"object\") {\n    return JSON.stringify(message);\n  }\n  return message.toString();\n}\n\n// node_modules/.pnpm/strict-event-emitter@0.5.1/node_modules/strict-event-emitter/lib/index.mjs\nvar MemoryLeakError = class extends Error {\n  constructor(emitter, type, count) {\n    super(`Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`);\n    this.emitter = emitter;\n    this.type = type;\n    this.count = count;\n    this.name = \"MaxListenersExceededWarning\";\n  }\n};\nvar _Emitter = class {\n  static listenerCount(emitter, eventName) {\n    return emitter.listenerCount(eventName);\n  }\n  constructor() {\n    this.events = /* @__PURE__ */new Map();\n    this.maxListeners = _Emitter.defaultMaxListeners;\n    this.hasWarnedAboutPotentialMemoryLeak = false;\n  }\n  _emitInternalEvent(internalEventName, eventName, listener) {\n    this.emit(internalEventName, ...[eventName, listener]);\n  }\n  _getListeners(eventName) {\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || [];\n  }\n  _removeListener(listeners, listener) {\n    const index = listeners.indexOf(listener);\n    if (index > -1) {\n      listeners.splice(index, 1);\n    }\n    return [];\n  }\n  _wrapOnceListener(eventName, listener) {\n    const onceListener = (...data) => {\n      this.removeListener(eventName, onceListener);\n      return listener.apply(this, data);\n    };\n    Object.defineProperty(onceListener, \"name\", {\n      value: listener.name\n    });\n    return onceListener;\n  }\n  setMaxListeners(maxListeners) {\n    this.maxListeners = maxListeners;\n    return this;\n  }\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n  getMaxListeners() {\n    return this.maxListeners;\n  }\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n  eventNames() {\n    return Array.from(this.events.keys());\n  }\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n  emit(eventName, ...data) {\n    const listeners = this._getListeners(eventName);\n    listeners.forEach(listener => {\n      listener.apply(this, data);\n    });\n    return listeners.length > 0;\n  }\n  addListener(eventName, listener) {\n    this._emitInternalEvent(\"newListener\", eventName, listener);\n    const nextListeners = this._getListeners(eventName).concat(listener);\n    this.events.set(eventName, nextListeners);\n    if (this.maxListeners > 0 && this.listenerCount(eventName) > this.maxListeners && !this.hasWarnedAboutPotentialMemoryLeak) {\n      this.hasWarnedAboutPotentialMemoryLeak = true;\n      const memoryLeakWarning = new MemoryLeakError(this, eventName, this.listenerCount(eventName));\n      console.warn(memoryLeakWarning);\n    }\n    return this;\n  }\n  on(eventName, listener) {\n    return this.addListener(eventName, listener);\n  }\n  once(eventName, listener) {\n    return this.addListener(eventName, this._wrapOnceListener(eventName, listener));\n  }\n  prependListener(eventName, listener) {\n    const listeners = this._getListeners(eventName);\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners);\n      this.events.set(eventName, nextListeners);\n    } else {\n      this.events.set(eventName, listeners.concat(listener));\n    }\n    return this;\n  }\n  prependOnceListener(eventName, listener) {\n    return this.prependListener(eventName, this._wrapOnceListener(eventName, listener));\n  }\n  removeListener(eventName, listener) {\n    const listeners = this._getListeners(eventName);\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener);\n      this.events.set(eventName, listeners);\n      this._emitInternalEvent(\"removeListener\", eventName, listener);\n    }\n    return this;\n  }\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n  off(eventName, listener) {\n    return this.removeListener(eventName, listener);\n  }\n  removeAllListeners(eventName) {\n    if (eventName) {\n      this.events.delete(eventName);\n    } else {\n      this.events.clear();\n    }\n    return this;\n  }\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n  listeners(eventName) {\n    return Array.from(this._getListeners(eventName));\n  }\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n  listenerCount(eventName) {\n    return this._getListeners(eventName).length;\n  }\n  rawListeners(eventName) {\n    return this.listeners(eventName);\n  }\n};\nvar Emitter = _Emitter;\nEmitter.defaultMaxListeners = 10;\n\n// node_modules/.pnpm/@mswjs+interceptors@0.39.1/node_modules/@mswjs/interceptors/lib/browser/chunk-QED3Q6Z2.mjs\nvar INTERNAL_REQUEST_ID_HEADER_NAME = \"x-interceptors-internal-request-id\";\nfunction getGlobalSymbol(symbol) {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || void 0\n  );\n}\nfunction setGlobalSymbol(symbol, value) {\n  globalThis[symbol] = value;\n}\nfunction deleteGlobalSymbol(symbol) {\n  delete globalThis[symbol];\n}\nvar Interceptor = class {\n  constructor(symbol) {\n    this.symbol = symbol;\n    this.readyState = \"INACTIVE\";\n    this.emitter = new Emitter();\n    this.subscriptions = [];\n    this.logger = new Logger(symbol.description);\n    this.emitter.setMaxListeners(0);\n    this.logger.info(\"constructing the interceptor...\");\n  }\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  checkEnvironment() {\n    return true;\n  }\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  apply() {\n    const logger = this.logger.extend(\"apply\");\n    logger.info(\"applying the interceptor...\");\n    if (this.readyState === \"APPLIED\") {\n      logger.info(\"intercepted already applied!\");\n      return;\n    }\n    const shouldApply = this.checkEnvironment();\n    if (!shouldApply) {\n      logger.info(\"the interceptor cannot be applied in this environment!\");\n      return;\n    }\n    this.readyState = \"APPLYING\";\n    const runningInstance = this.getInstance();\n    if (runningInstance) {\n      logger.info(\"found a running instance, reusing...\");\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event);\n        runningInstance.emitter.addListener(event, listener);\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener);\n          logger.info('removed proxied \"%s\" listener!', event);\n        });\n        return this;\n      };\n      this.readyState = \"APPLIED\";\n      return;\n    }\n    logger.info(\"no running instance found, setting up a new instance...\");\n    this.setup();\n    this.setInstance();\n    this.readyState = \"APPLIED\";\n  }\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  setup() {}\n  /**\n   * Listen to the interceptor's public events.\n   */\n  on(event, listener) {\n    const logger = this.logger.extend(\"on\");\n    if (this.readyState === \"DISPOSING\" || this.readyState === \"DISPOSED\") {\n      logger.info(\"cannot listen to events, already disposed!\");\n      return this;\n    }\n    logger.info('adding \"%s\" event listener:', event, listener);\n    this.emitter.on(event, listener);\n    return this;\n  }\n  once(event, listener) {\n    this.emitter.once(event, listener);\n    return this;\n  }\n  off(event, listener) {\n    this.emitter.off(event, listener);\n    return this;\n  }\n  removeAllListeners(event) {\n    this.emitter.removeAllListeners(event);\n    return this;\n  }\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  dispose() {\n    const logger = this.logger.extend(\"dispose\");\n    if (this.readyState === \"DISPOSED\") {\n      logger.info(\"cannot dispose, already disposed!\");\n      return;\n    }\n    logger.info(\"disposing the interceptor...\");\n    this.readyState = \"DISPOSING\";\n    if (!this.getInstance()) {\n      logger.info(\"no interceptors running, skipping dispose...\");\n      return;\n    }\n    this.clearInstance();\n    logger.info(\"global symbol deleted:\", getGlobalSymbol(this.symbol));\n    if (this.subscriptions.length > 0) {\n      logger.info(\"disposing of %d subscriptions...\", this.subscriptions.length);\n      for (const dispose of this.subscriptions) {\n        dispose();\n      }\n      this.subscriptions = [];\n      logger.info(\"disposed of all subscriptions!\", this.subscriptions.length);\n    }\n    this.emitter.removeAllListeners();\n    logger.info(\"destroyed the listener!\");\n    this.readyState = \"DISPOSED\";\n  }\n  getInstance() {\n    var _a;\n    const instance = getGlobalSymbol(this.symbol);\n    this.logger.info(\"retrieved global instance:\", (_a = instance == null ? void 0 : instance.constructor) == null ? void 0 : _a.name);\n    return instance;\n  }\n  setInstance() {\n    setGlobalSymbol(this.symbol, this);\n    this.logger.info(\"set global instance!\", this.symbol.description);\n  }\n  clearInstance() {\n    deleteGlobalSymbol(this.symbol);\n    this.logger.info(\"cleared global instance!\", this.symbol.description);\n  }\n};\nfunction createRequestId() {\n  return Math.random().toString(16).slice(2);\n}\n\n// node_modules/.pnpm/@mswjs+interceptors@0.39.1/node_modules/@mswjs/interceptors/lib/browser/index.mjs\nvar BatchInterceptor = class extends Interceptor {\n  constructor(options) {\n    BatchInterceptor.symbol = Symbol(options.name);\n    super(BatchInterceptor.symbol);\n    this.interceptors = options.interceptors;\n  }\n  setup() {\n    const logger = this.logger.extend(\"setup\");\n    logger.info(\"applying all %d interceptors...\", this.interceptors.length);\n    for (const interceptor of this.interceptors) {\n      logger.info('applying \"%s\" interceptor...', interceptor.constructor.name);\n      interceptor.apply();\n      logger.info(\"adding interceptor dispose subscription\");\n      this.subscriptions.push(() => interceptor.dispose());\n    }\n  }\n  on(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.on(event, listener);\n    }\n    return this;\n  }\n  once(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.once(event, listener);\n    }\n    return this;\n  }\n  off(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.off(event, listener);\n    }\n    return this;\n  }\n  removeAllListeners(event) {\n    for (const interceptors of this.interceptors) {\n      interceptors.removeAllListeners(event);\n    }\n    return this;\n  }\n};\n\n// src/browser/setupWorker/start/createResponseListener.ts\nfunction createResponseListener(context) {\n  return event => {\n    const responseMessage = event.data;\n    const request = deserializeRequest(responseMessage.request);\n    if (responseMessage.response.type?.includes(\"opaque\")) {\n      return;\n    }\n    const response = responseMessage.response.status === 0 ? Response.error() : new FetchResponse(\n    /**\n     * Responses may be streams here, but when we create a response object\n     * with null-body status codes, like 204, 205, 304 Response will\n     * throw when passed a non-null body, so ensure it's null here\n     * for those codes\n     */\n    FetchResponse.isResponseWithBody(responseMessage.response.status) ? responseMessage.response.body : null, {\n      ...responseMessage,\n      /**\n       * Set response URL if it's not set already.\n       * @see https://github.com/mswjs/msw/issues/2030\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/Response/url\n       */\n      url: request.url\n    });\n    context.emitter.emit(responseMessage.isMockedResponse ? \"response:mocked\" : \"response:bypass\", {\n      requestId: responseMessage.request.id,\n      request,\n      response\n    });\n  };\n}\n\n// src/browser/setupWorker/start/utils/validateWorkerScope.ts\nimport { devUtils as devUtils5 } from '../core/utils/internal/devUtils.mjs';\nfunction validateWorkerScope(registration, options) {\n  if (!options?.quiet && !location.href.startsWith(registration.scope)) {\n    devUtils5.warn(`Cannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.`);\n  }\n}\n\n// src/browser/setupWorker/start/createStartHandler.ts\nvar createStartHandler = context => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      context.workerChannel.removeAllListeners();\n      context.workerChannel.on(\"REQUEST\", createRequestListener(context, options));\n      context.workerChannel.on(\"RESPONSE\", createResponseListener(context));\n      const instance = await getWorkerInstance(options.serviceWorker.url, options.serviceWorker.options, options.findWorker);\n      const [worker, registration] = instance;\n      if (!worker) {\n        const missingWorkerMessage = customOptions?.findWorker ? devUtils6.formatMessage(`Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`, options.serviceWorker.url) : devUtils6.formatMessage(`Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`, options.serviceWorker.url, location.host);\n        throw new Error(missingWorkerMessage);\n      }\n      context.workerPromise.resolve(worker);\n      context.registration = registration;\n      window.addEventListener(\"beforeunload\", () => {\n        if (worker.state !== \"redundant\") {\n          context.workerChannel.postMessage(\"CLIENT_CLOSED\");\n        }\n        window.clearInterval(context.keepAliveInterval);\n        window.postMessage({\n          type: \"msw/worker:stop\"\n        });\n      });\n      await checkWorkerIntegrity(context).catch(error2 => {\n        devUtils6.error(\"Error while checking the worker script integrity. Please report this on GitHub (https://github.com/mswjs/msw/issues) and include the original error below.\");\n        console.error(error2);\n      });\n      context.keepAliveInterval = window.setInterval(() => context.workerChannel.postMessage(\"KEEPALIVE_REQUEST\"), 5e3);\n      validateWorkerScope(registration, context.startOptions);\n      return registration;\n    };\n    const workerRegistration = startWorkerInstance().then(async registration => {\n      const pendingInstance = registration.installing || registration.waiting;\n      if (pendingInstance) {\n        const activationPromise = new DeferredPromise();\n        pendingInstance.addEventListener(\"statechange\", () => {\n          if (pendingInstance.state === \"activated\") {\n            activationPromise.resolve();\n          }\n        });\n        await activationPromise;\n      }\n      await enableMocking(context, options).catch(error2 => {\n        devUtils6.error(\"Failed to enable mocking. Please report this on GitHub (https://github.com/mswjs/msw/issues) and include the original error below.\");\n        throw error2;\n      });\n      return registration;\n    });\n    return workerRegistration;\n  };\n};\n\n// src/browser/setupWorker/setupWorker.ts\nimport { devUtils as devUtils8 } from '../core/utils/internal/devUtils.mjs';\nimport { SetupApi } from '../core/SetupApi.mjs';\nimport { mergeRight as mergeRight2 } from '../core/utils/internal/mergeRight.mjs';\n\n// src/browser/utils/supportsReadableStreamTransfer.ts\nfunction supportsReadableStreamTransfer() {\n  try {\n    const stream = new ReadableStream({\n      start: controller => controller.close()\n    });\n    const message = new MessageChannel();\n    message.port1.postMessage(stream, [stream]);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// src/browser/setupWorker/setupWorker.ts\nimport { webSocketInterceptor } from '../core/ws/webSocketInterceptor.mjs';\nimport { handleWebSocketEvent } from '../core/ws/handleWebSocketEvent.mjs';\nimport { attachWebSocketLogger } from '../core/ws/utils/attachWebSocketLogger.mjs';\n\n// node_modules/.pnpm/rettime@0.7.0/node_modules/rettime/build/index.js\nvar kDefaultPrevented = Symbol(\"kDefaultPrevented\");\nvar kPropagationStopped = Symbol(\"kPropagationStopped\");\nvar kImmediatePropagationStopped = Symbol(\"kImmediatePropagationStopped\");\nvar TypedEvent = class extends MessageEvent {\n  /**\n   * @note Keep a placeholder property with the return type\n   * because the type must be set somewhere in order to be\n   * correctly associated and inferred from the event.\n   */\n  #returnType;\n  [kDefaultPrevented];\n  [kPropagationStopped];\n  [kImmediatePropagationStopped];\n  constructor(...args) {\n    super(args[0], args[1]);\n    this[kDefaultPrevented] = false;\n  }\n  get defaultPrevented() {\n    return this[kDefaultPrevented];\n  }\n  preventDefault() {\n    super.preventDefault();\n    this[kDefaultPrevented] = true;\n  }\n  stopImmediatePropagation() {\n    super.stopImmediatePropagation();\n    this[kImmediatePropagationStopped] = true;\n  }\n};\nvar kListenerOptions = Symbol(\"kListenerOptions\");\nvar Emitter2 = class {\n  #listeners;\n  constructor() {\n    this.#listeners = {};\n  }\n  /**\n   * Adds a listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  on(type, listener, options) {\n    return this.#addListener(type, listener, options);\n  }\n  /**\n   * Adds a one-time listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  once(type, listener, options) {\n    return this.on(type, listener, {\n      ...(options || {}),\n      once: true\n    });\n  }\n  /**\n   * Prepends a listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  earlyOn(type, listener, options) {\n    return this.#addListener(type, listener, options, \"prepend\");\n  }\n  /**\n   * Prepends a one-time listener for the given event type.\n   */\n  earlyOnce(type, listener, options) {\n    return this.earlyOn(type, listener, {\n      ...(options || {}),\n      once: true\n    });\n  }\n  /**\n   * Emits the given typed event.\n   *\n   * @returns {boolean} Returns `true` if the event had any listeners, `false` otherwise.\n   */\n  emit(event) {\n    if (this.listenerCount(event.type) === 0) {\n      return false;\n    }\n    const proxiedEvent = this.#proxyEvent(event);\n    for (const listener of this.#listeners[event.type]) {\n      if (proxiedEvent.event[kPropagationStopped] != null && proxiedEvent.event[kPropagationStopped] !== this) {\n        return false;\n      }\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break;\n      }\n      this.#callListener(proxiedEvent.event, listener);\n    }\n    proxiedEvent.revoke();\n    return true;\n  }\n  /**\n   * Emits the given typed event and returns a promise that resolves\n   * when all the listeners for that event have settled.\n   *\n   * @returns {Promise<Array<Emitter.ListenerReturnType>>} A promise that resolves\n   * with the return values of all listeners.\n   */\n  async emitAsPromise(event) {\n    if (this.listenerCount(event.type) === 0) {\n      return [];\n    }\n    const pendingListeners = [];\n    const proxiedEvent = this.#proxyEvent(event);\n    for (const listener of this.#listeners[event.type]) {\n      if (proxiedEvent.event[kPropagationStopped] != null && proxiedEvent.event[kPropagationStopped] !== this) {\n        return [];\n      }\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break;\n      }\n      pendingListeners.push(\n      // Awaiting individual listeners guarantees their call order.\n      await Promise.resolve(this.#callListener(proxiedEvent.event, listener)));\n    }\n    proxiedEvent.revoke();\n    return Promise.allSettled(pendingListeners).then(results => {\n      return results.map(result => result.status === \"fulfilled\" ? result.value : result.reason);\n    });\n  }\n  /**\n   * Emits the given event and returns a generator that yields\n   * the result of each listener in the order of their registration.\n   * This way, you stop exhausting the listeners once you get the expected value.\n   */\n  *emitAsGenerator(event) {\n    if (this.listenerCount(event.type) === 0) {\n      return;\n    }\n    const proxiedEvent = this.#proxyEvent(event);\n    for (const listener of this.#listeners[event.type]) {\n      if (proxiedEvent.event[kPropagationStopped] != null && proxiedEvent.event[kPropagationStopped] !== this) {\n        return;\n      }\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break;\n      }\n      yield this.#callListener(proxiedEvent.event, listener);\n    }\n    proxiedEvent.revoke();\n  }\n  /**\n   * Removes a listener for the given event type.\n   */\n  removeListener(type, listener) {\n    if (this.listenerCount(type) === 0) {\n      return;\n    }\n    const nextListeners = [];\n    for (const existingListener of this.#listeners[type]) {\n      if (existingListener !== listener) {\n        nextListeners.push(existingListener);\n      }\n    }\n    this.#listeners[type] = nextListeners;\n  }\n  /**\n   * Removes all listeners for the given event type.\n   * If no event type is provided, removes all existing listeners.\n   */\n  removeAllListeners(type) {\n    if (type == null) {\n      this.#listeners = {};\n      return;\n    }\n    this.#listeners[type] = [];\n  }\n  /**\n   * Returns the list of listeners for the given event type.\n   * If no even type is provided, returns all listeners.\n   */\n  listeners(type) {\n    if (type == null) {\n      return Object.values(this.#listeners).flat();\n    }\n    return this.#listeners[type] || [];\n  }\n  /**\n   * Returns the number of listeners for the given event type.\n   * If no even type is provided, returns the total number of listeners.\n   */\n  listenerCount(type) {\n    return this.listeners(type).length;\n  }\n  #addListener(type, listener, options, insertMode = \"append\") {\n    this.#listeners[type] ??= [];\n    if (insertMode === \"prepend\") {\n      this.#listeners[type].unshift(listener);\n    } else {\n      this.#listeners[type].push(listener);\n    }\n    if (options) {\n      Object.defineProperty(listener, kListenerOptions, {\n        value: options,\n        enumerable: false,\n        writable: false\n      });\n      if (options.signal) {\n        options.signal.addEventListener(\"abort\", () => {\n          this.removeListener(type, listener);\n        }, {\n          once: true\n        });\n      }\n    }\n    return this;\n  }\n  #proxyEvent(event) {\n    const {\n      stopPropagation\n    } = event;\n    event.stopPropagation = new Proxy(event.stopPropagation, {\n      apply: (target, thisArg, argArray) => {\n        event[kPropagationStopped] = this;\n        return Reflect.apply(target, thisArg, argArray);\n      }\n    });\n    return {\n      event,\n      revoke() {\n        event.stopPropagation = stopPropagation;\n      }\n    };\n  }\n  #callListener(event, listener) {\n    const returnValue = listener.call(this, event);\n    if (listener[kListenerOptions]?.once) {\n      this.removeListener(event.type, listener);\n    }\n    return returnValue;\n  }\n};\n\n// src/browser/utils/workerChannel.ts\nimport { isObject } from '../core/utils/internal/isObject.mjs';\nvar WorkerEvent = class extends TypedEvent {\n  #workerEvent;\n  constructor(workerEvent) {\n    const type = workerEvent.data.type;\n    const data = workerEvent.data.payload;\n    super(\n    // @ts-expect-error Troublesome `TypedEvent` extension.\n    type, {\n      data\n    });\n    this.#workerEvent = workerEvent;\n  }\n  get ports() {\n    return this.#workerEvent.ports;\n  }\n  /**\n   * Reply directly to this event using its `MessagePort`.\n   */\n  postMessage(type, ...rest) {\n    this.#workerEvent.ports[0].postMessage({\n      type,\n      data: rest[0]\n    }, {\n      transfer: rest[1]\n    });\n  }\n};\nvar WorkerChannel = class extends Emitter2 {\n  constructor(options) {\n    super();\n    this.options = options;\n    navigator.serviceWorker.addEventListener(\"message\", async event => {\n      const worker = await this.options.worker;\n      if (event.source != null && event.source !== worker) {\n        return;\n      }\n      if (event.data && isObject(event.data) && \"type\" in event.data) {\n        this.emit(new WorkerEvent(event));\n      }\n    });\n  }\n  /**\n   * Send data to the Service Worker controlling this client.\n   * This triggers the `message` event listener on ServiceWorkerGlobalScope.\n   */\n  postMessage(type) {\n    this.options.worker.then(worker => {\n      worker.postMessage(type);\n    });\n  }\n};\n\n// node_modules/.pnpm/@mswjs+interceptors@0.39.1/node_modules/@mswjs/interceptors/lib/browser/chunk-L37TY7LC.mjs\nvar InterceptorError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"InterceptorError\";\n    Object.setPrototypeOf(this, InterceptorError.prototype);\n  }\n};\nvar kRequestHandled = Symbol(\"kRequestHandled\");\nvar kResponsePromise = Symbol(\"kResponsePromise\");\nvar RequestController = class {\n  constructor(request) {\n    this.request = request;\n    this[kRequestHandled] = false;\n    this[kResponsePromise] = new DeferredPromise();\n  }\n  /**\n   * Respond to this request with the given `Response` instance.\n   * @example\n   * controller.respondWith(new Response())\n   * controller.respondWith(Response.json({ id }))\n   * controller.respondWith(Response.error())\n   */\n  respondWith(response) {\n    invariant.as(InterceptorError, !this[kRequestHandled], 'Failed to respond to the \"%s %s\" request: the \"request\" event has already been handled.', this.request.method, this.request.url);\n    this[kRequestHandled] = true;\n    this[kResponsePromise].resolve(response);\n  }\n  /**\n   * Error this request with the given reason.\n   *\n   * @example\n   * controller.errorWith()\n   * controller.errorWith(new Error('Oops!'))\n   * controller.errorWith({ message: 'Oops!'})\n   */\n  errorWith(reason) {\n    invariant.as(InterceptorError, !this[kRequestHandled], 'Failed to error the \"%s %s\" request: the \"request\" event has already been handled.', this.request.method, this.request.url);\n    this[kRequestHandled] = true;\n    this[kResponsePromise].resolve(reason);\n  }\n};\nasync function emitAsync(emitter, eventName, ...data) {\n  const listners = emitter.listeners(eventName);\n  if (listners.length === 0) {\n    return;\n  }\n  for (const listener of listners) {\n    await listener.apply(emitter, data);\n  }\n}\nfunction isObject2(value, loose = false) {\n  return loose ? Object.prototype.toString.call(value).startsWith(\"[object \") : Object.prototype.toString.call(value) === \"[object Object]\";\n}\nfunction isPropertyAccessible(obj, key) {\n  try {\n    obj[key];\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction createServerErrorResponse(body) {\n  return new Response(JSON.stringify(body instanceof Error ? {\n    name: body.name,\n    message: body.message,\n    stack: body.stack\n  } : body), {\n    status: 500,\n    statusText: \"Unhandled Exception\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  });\n}\nfunction isResponseError(response) {\n  return response != null && response instanceof Response && isPropertyAccessible(response, \"type\") && response.type === \"error\";\n}\nfunction isResponseLike(value) {\n  return isObject2(value, true) && isPropertyAccessible(value, \"status\") && isPropertyAccessible(value, \"statusText\") && isPropertyAccessible(value, \"bodyUsed\");\n}\nfunction isNodeLikeError(error2) {\n  if (error2 == null) {\n    return false;\n  }\n  if (!(error2 instanceof Error)) {\n    return false;\n  }\n  return \"code\" in error2 && \"errno\" in error2;\n}\nasync function handleRequest2(options) {\n  const handleResponse = async response => {\n    if (response instanceof Error) {\n      options.onError(response);\n      return true;\n    }\n    if (isResponseError(response)) {\n      options.onRequestError(response);\n      return true;\n    }\n    if (isResponseLike(response)) {\n      await options.onResponse(response);\n      return true;\n    }\n    if (isObject2(response)) {\n      options.onError(response);\n      return true;\n    }\n    return false;\n  };\n  const handleResponseError = async error2 => {\n    if (error2 instanceof InterceptorError) {\n      throw result.error;\n    }\n    if (isNodeLikeError(error2)) {\n      options.onError(error2);\n      return true;\n    }\n    if (error2 instanceof Response) {\n      return await handleResponse(error2);\n    }\n    return false;\n  };\n  options.emitter.once(\"request\", ({\n    requestId: pendingRequestId\n  }) => {\n    if (pendingRequestId !== options.requestId) {\n      return;\n    }\n    if (options.controller[kResponsePromise].state === \"pending\") {\n      options.controller[kResponsePromise].resolve(void 0);\n    }\n  });\n  const requestAbortPromise = new DeferredPromise();\n  if (options.request.signal) {\n    if (options.request.signal.aborted) {\n      requestAbortPromise.reject(options.request.signal.reason);\n    } else {\n      options.request.signal.addEventListener(\"abort\", () => {\n        requestAbortPromise.reject(options.request.signal.reason);\n      }, {\n        once: true\n      });\n    }\n  }\n  const result = await until(async () => {\n    const requestListenersPromise = emitAsync(options.emitter, \"request\", {\n      requestId: options.requestId,\n      request: options.request,\n      controller: options.controller\n    });\n    await Promise.race([\n    // Short-circuit the request handling promise if the request gets aborted.\n    requestAbortPromise, requestListenersPromise, options.controller[kResponsePromise]]);\n    return await options.controller[kResponsePromise];\n  });\n  if (requestAbortPromise.state === \"rejected\") {\n    options.onError(requestAbortPromise.rejectionReason);\n    return true;\n  }\n  if (result.error) {\n    if (await handleResponseError(result.error)) {\n      return true;\n    }\n    if (options.emitter.listenerCount(\"unhandledException\") > 0) {\n      const unhandledExceptionController = new RequestController(options.request);\n      await emitAsync(options.emitter, \"unhandledException\", {\n        error: result.error,\n        request: options.request,\n        requestId: options.requestId,\n        controller: unhandledExceptionController\n      }).then(() => {\n        if (unhandledExceptionController[kResponsePromise].state === \"pending\") {\n          unhandledExceptionController[kResponsePromise].resolve(void 0);\n        }\n      });\n      const nextResult = await until(() => unhandledExceptionController[kResponsePromise]);\n      if (nextResult.error) {\n        return handleResponseError(nextResult.error);\n      }\n      if (nextResult.data) {\n        return handleResponse(nextResult.data);\n      }\n    }\n    options.onResponse(createServerErrorResponse(result.error));\n    return true;\n  }\n  if (result.data) {\n    return handleResponse(result.data);\n  }\n  return false;\n}\n\n// node_modules/.pnpm/@mswjs+interceptors@0.39.1/node_modules/@mswjs/interceptors/lib/browser/chunk-TX5GBTFY.mjs\nfunction hasConfigurableGlobal(propertyName) {\n  const descriptor = Object.getOwnPropertyDescriptor(globalThis, propertyName);\n  if (typeof descriptor === \"undefined\") {\n    return false;\n  }\n  if (typeof descriptor.get === \"function\" && typeof descriptor.get() === \"undefined\") {\n    return false;\n  }\n  if (typeof descriptor.get === \"undefined\" && descriptor.value == null) {\n    return false;\n  }\n  if (typeof descriptor.set === \"undefined\" && !descriptor.configurable) {\n    console.error(`[MSW] Failed to apply interceptor: the global \\`${propertyName}\\` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.`);\n    return false;\n  }\n  return true;\n}\n\n// node_modules/.pnpm/@mswjs+interceptors@0.39.1/node_modules/@mswjs/interceptors/lib/browser/chunk-ARPHZXGT.mjs\nfunction createNetworkError(cause) {\n  return Object.assign(new TypeError(\"Failed to fetch\"), {\n    cause\n  });\n}\nvar REQUEST_BODY_HEADERS = [\"content-encoding\", \"content-language\", \"content-location\", \"content-type\", \"content-length\"];\nvar kRedirectCount = Symbol(\"kRedirectCount\");\nasync function followFetchRedirect(request, response) {\n  if (response.status !== 303 && request.body != null) {\n    return Promise.reject(createNetworkError());\n  }\n  const requestUrl = new URL(request.url);\n  let locationUrl;\n  try {\n    locationUrl = new URL(response.headers.get(\"location\"), request.url);\n  } catch (error2) {\n    return Promise.reject(createNetworkError(error2));\n  }\n  if (!(locationUrl.protocol === \"http:\" || locationUrl.protocol === \"https:\")) {\n    return Promise.reject(createNetworkError(\"URL scheme must be a HTTP(S) scheme\"));\n  }\n  if (Reflect.get(request, kRedirectCount) > 20) {\n    return Promise.reject(createNetworkError(\"redirect count exceeded\"));\n  }\n  Object.defineProperty(request, kRedirectCount, {\n    value: (Reflect.get(request, kRedirectCount) || 0) + 1\n  });\n  if (request.mode === \"cors\" && (locationUrl.username || locationUrl.password) && !sameOrigin(requestUrl, locationUrl)) {\n    return Promise.reject(createNetworkError('cross origin not allowed for request mode \"cors\"'));\n  }\n  const requestInit = {};\n  if ([301, 302].includes(response.status) && request.method === \"POST\" || response.status === 303 && ![\"HEAD\", \"GET\"].includes(request.method)) {\n    requestInit.method = \"GET\";\n    requestInit.body = null;\n    REQUEST_BODY_HEADERS.forEach(headerName => {\n      request.headers.delete(headerName);\n    });\n  }\n  if (!sameOrigin(requestUrl, locationUrl)) {\n    request.headers.delete(\"authorization\");\n    request.headers.delete(\"proxy-authorization\");\n    request.headers.delete(\"cookie\");\n    request.headers.delete(\"host\");\n  }\n  requestInit.headers = request.headers;\n  return fetch(new Request(locationUrl, requestInit));\n}\nfunction sameOrigin(left, right) {\n  if (left.origin === right.origin && left.origin === \"null\") {\n    return true;\n  }\n  if (left.protocol === right.protocol && left.hostname === right.hostname && left.port === right.port) {\n    return true;\n  }\n  return false;\n}\nvar BrotliDecompressionStream = class extends TransformStream {\n  constructor() {\n    console.warn(\"[Interceptors]: Brotli decompression of response streams is not supported in the browser\");\n    super({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      }\n    });\n  }\n};\nvar PipelineStream = class extends TransformStream {\n  constructor(transformStreams, ...strategies) {\n    super({}, ...strategies);\n    const readable = [super.readable, ...transformStreams].reduce((readable2, transform) => readable2.pipeThrough(transform));\n    Object.defineProperty(this, \"readable\", {\n      get() {\n        return readable;\n      }\n    });\n  }\n};\nfunction parseContentEncoding(contentEncoding) {\n  return contentEncoding.toLowerCase().split(\",\").map(coding => coding.trim());\n}\nfunction createDecompressionStream(contentEncoding) {\n  if (contentEncoding === \"\") {\n    return null;\n  }\n  const codings = parseContentEncoding(contentEncoding);\n  if (codings.length === 0) {\n    return null;\n  }\n  const transformers = codings.reduceRight((transformers2, coding) => {\n    if (coding === \"gzip\" || coding === \"x-gzip\") {\n      return transformers2.concat(new DecompressionStream(\"gzip\"));\n    } else if (coding === \"deflate\") {\n      return transformers2.concat(new DecompressionStream(\"deflate\"));\n    } else if (coding === \"br\") {\n      return transformers2.concat(new BrotliDecompressionStream());\n    } else {\n      transformers2.length = 0;\n    }\n    return transformers2;\n  }, []);\n  return new PipelineStream(transformers);\n}\nfunction decompressResponse(response) {\n  if (response.body === null) {\n    return null;\n  }\n  const decompressionStream = createDecompressionStream(response.headers.get(\"content-encoding\") || \"\");\n  if (!decompressionStream) {\n    return null;\n  }\n  response.body.pipeTo(decompressionStream.writable);\n  return decompressionStream.readable;\n}\nvar _FetchInterceptor = class extends Interceptor {\n  constructor() {\n    super(_FetchInterceptor.symbol);\n  }\n  checkEnvironment() {\n    return hasConfigurableGlobal(\"fetch\");\n  }\n  async setup() {\n    const pureFetch = globalThis.fetch;\n    invariant(!pureFetch[IS_PATCHED_MODULE], 'Failed to patch the \"fetch\" module: already patched.');\n    globalThis.fetch = async (input, init) => {\n      const requestId = createRequestId();\n      const resolvedInput = typeof input === \"string\" && typeof location !== \"undefined\" && !canParseUrl(input) ? new URL(input, location.href) : input;\n      const request = new Request(resolvedInput, init);\n      if (input instanceof Request) {\n        setRawRequest(request, input);\n      }\n      const responsePromise = new DeferredPromise();\n      const controller = new RequestController(request);\n      this.logger.info(\"[%s] %s\", request.method, request.url);\n      this.logger.info(\"awaiting for the mocked response...\");\n      this.logger.info('emitting the \"request\" event for %s listener(s)...', this.emitter.listenerCount(\"request\"));\n      const isRequestHandled = await handleRequest2({\n        request,\n        requestId,\n        emitter: this.emitter,\n        controller,\n        onResponse: async rawResponse => {\n          this.logger.info(\"received mocked response!\", {\n            rawResponse\n          });\n          const decompressedStream = decompressResponse(rawResponse);\n          const response = decompressedStream === null ? rawResponse : new FetchResponse(decompressedStream, rawResponse);\n          FetchResponse.setUrl(request.url, response);\n          if (FetchResponse.isRedirectResponse(response.status)) {\n            if (request.redirect === \"error\") {\n              responsePromise.reject(createNetworkError(\"unexpected redirect\"));\n              return;\n            }\n            if (request.redirect === \"follow\") {\n              followFetchRedirect(request, response).then(response2 => {\n                responsePromise.resolve(response2);\n              }, reason => {\n                responsePromise.reject(reason);\n              });\n              return;\n            }\n          }\n          if (this.emitter.listenerCount(\"response\") > 0) {\n            this.logger.info('emitting the \"response\" event...');\n            await emitAsync(this.emitter, \"response\", {\n              // Clone the mocked response for the \"response\" event listener.\n              // This way, the listener can read the response and not lock its body\n              // for the actual fetch consumer.\n              response: response.clone(),\n              isMockedResponse: true,\n              request,\n              requestId\n            });\n          }\n          responsePromise.resolve(response);\n        },\n        onRequestError: response => {\n          this.logger.info(\"request has errored!\", {\n            response\n          });\n          responsePromise.reject(createNetworkError(response));\n        },\n        onError: error2 => {\n          this.logger.info(\"request has been aborted!\", {\n            error: error2\n          });\n          responsePromise.reject(error2);\n        }\n      });\n      if (isRequestHandled) {\n        this.logger.info(\"request has been handled, returning mock promise...\");\n        return responsePromise;\n      }\n      this.logger.info(\"no mocked response received, performing request as-is...\");\n      const requestCloneForResponseEvent = request.clone();\n      return pureFetch(request).then(async response => {\n        this.logger.info(\"original fetch performed\", response);\n        if (this.emitter.listenerCount(\"response\") > 0) {\n          this.logger.info('emitting the \"response\" event...');\n          const responseClone = response.clone();\n          await emitAsync(this.emitter, \"response\", {\n            response: responseClone,\n            isMockedResponse: false,\n            request: requestCloneForResponseEvent,\n            requestId\n          });\n        }\n        return response;\n      });\n    };\n    Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true\n    });\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n        value: void 0\n      });\n      globalThis.fetch = pureFetch;\n      this.logger.info('restored native \"globalThis.fetch\"!', globalThis.fetch.name);\n    });\n  }\n};\nvar FetchInterceptor = _FetchInterceptor;\nFetchInterceptor.symbol = Symbol(\"fetch\");\n\n// node_modules/.pnpm/@mswjs+interceptors@0.39.1/node_modules/@mswjs/interceptors/lib/browser/chunk-QKSBFQDK.mjs\nfunction concatArrayBuffer(left, right) {\n  const result = new Uint8Array(left.byteLength + right.byteLength);\n  result.set(left, 0);\n  result.set(right, left.byteLength);\n  return result;\n}\nvar EventPolyfill = class {\n  constructor(type, options) {\n    this.NONE = 0;\n    this.CAPTURING_PHASE = 1;\n    this.AT_TARGET = 2;\n    this.BUBBLING_PHASE = 3;\n    this.type = \"\";\n    this.srcElement = null;\n    this.currentTarget = null;\n    this.eventPhase = 0;\n    this.isTrusted = true;\n    this.composed = false;\n    this.cancelable = true;\n    this.defaultPrevented = false;\n    this.bubbles = true;\n    this.lengthComputable = true;\n    this.loaded = 0;\n    this.total = 0;\n    this.cancelBubble = false;\n    this.returnValue = true;\n    this.type = type;\n    this.target = (options == null ? void 0 : options.target) || null;\n    this.currentTarget = (options == null ? void 0 : options.currentTarget) || null;\n    this.timeStamp = Date.now();\n  }\n  composedPath() {\n    return [];\n  }\n  initEvent(type, bubbles, cancelable) {\n    this.type = type;\n    this.bubbles = !!bubbles;\n    this.cancelable = !!cancelable;\n  }\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n  stopPropagation() {}\n  stopImmediatePropagation() {}\n};\nvar ProgressEventPolyfill = class extends EventPolyfill {\n  constructor(type, init) {\n    super(type);\n    this.lengthComputable = (init == null ? void 0 : init.lengthComputable) || false;\n    this.composed = (init == null ? void 0 : init.composed) || false;\n    this.loaded = (init == null ? void 0 : init.loaded) || 0;\n    this.total = (init == null ? void 0 : init.total) || 0;\n  }\n};\nvar SUPPORTS_PROGRESS_EVENT = typeof ProgressEvent !== \"undefined\";\nfunction createEvent(target, type, init) {\n  const progressEvents = [\"error\", \"progress\", \"loadstart\", \"loadend\", \"load\", \"timeout\", \"abort\"];\n  const ProgressEventClass = SUPPORTS_PROGRESS_EVENT ? ProgressEvent : ProgressEventPolyfill;\n  const event = progressEvents.includes(type) ? new ProgressEventClass(type, {\n    lengthComputable: true,\n    loaded: (init == null ? void 0 : init.loaded) || 0,\n    total: (init == null ? void 0 : init.total) || 0\n  }) : new EventPolyfill(type, {\n    target,\n    currentTarget: target\n  });\n  return event;\n}\nfunction findPropertySource(target, propertyName) {\n  if (!(propertyName in target)) {\n    return null;\n  }\n  const hasProperty = Object.prototype.hasOwnProperty.call(target, propertyName);\n  if (hasProperty) {\n    return target;\n  }\n  const prototype = Reflect.getPrototypeOf(target);\n  return prototype ? findPropertySource(prototype, propertyName) : null;\n}\nfunction createProxy(target, options) {\n  const proxy = new Proxy(target, optionsToProxyHandler(options));\n  return proxy;\n}\nfunction optionsToProxyHandler(options) {\n  const {\n    constructorCall,\n    methodCall,\n    getProperty,\n    setProperty\n  } = options;\n  const handler = {};\n  if (typeof constructorCall !== \"undefined\") {\n    handler.construct = function (target, args, newTarget) {\n      const next = Reflect.construct.bind(null, target, args, newTarget);\n      return constructorCall.call(newTarget, args, next);\n    };\n  }\n  handler.set = function (target, propertyName, nextValue) {\n    const next = () => {\n      const propertySource = findPropertySource(target, propertyName) || target;\n      const ownDescriptors = Reflect.getOwnPropertyDescriptor(propertySource, propertyName);\n      if (typeof (ownDescriptors == null ? void 0 : ownDescriptors.set) !== \"undefined\") {\n        ownDescriptors.set.apply(target, [nextValue]);\n        return true;\n      }\n      return Reflect.defineProperty(propertySource, propertyName, {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: nextValue\n      });\n    };\n    if (typeof setProperty !== \"undefined\") {\n      return setProperty.call(target, [propertyName, nextValue], next);\n    }\n    return next();\n  };\n  handler.get = function (target, propertyName, receiver) {\n    const next = () => target[propertyName];\n    const value = typeof getProperty !== \"undefined\" ? getProperty.call(target, [propertyName, receiver], next) : next();\n    if (typeof value === \"function\") {\n      return (...args) => {\n        const next2 = value.bind(target, ...args);\n        if (typeof methodCall !== \"undefined\") {\n          return methodCall.call(target, [propertyName, args], next2);\n        }\n        return next2();\n      };\n    }\n    return value;\n  };\n  return handler;\n}\nfunction isDomParserSupportedType(type) {\n  const supportedTypes = [\"application/xhtml+xml\", \"application/xml\", \"image/svg+xml\", \"text/html\", \"text/xml\"];\n  return supportedTypes.some(supportedType => {\n    return type.startsWith(supportedType);\n  });\n}\nfunction parseJson(data) {\n  try {\n    const json = JSON.parse(data);\n    return json;\n  } catch (_) {\n    return null;\n  }\n}\nfunction createResponse(request, body) {\n  const responseBodyOrNull = FetchResponse.isResponseWithBody(request.status) ? body : null;\n  return new FetchResponse(responseBodyOrNull, {\n    url: request.responseURL,\n    status: request.status,\n    statusText: request.statusText,\n    headers: createHeadersFromXMLHttpReqestHeaders(request.getAllResponseHeaders())\n  });\n}\nfunction createHeadersFromXMLHttpReqestHeaders(headersString) {\n  const headers = new Headers();\n  const lines = headersString.split(/[\\r\\n]+/);\n  for (const line of lines) {\n    if (line.trim() === \"\") {\n      continue;\n    }\n    const [name, ...parts] = line.split(\": \");\n    const value = parts.join(\": \");\n    headers.append(name, value);\n  }\n  return headers;\n}\nasync function getBodyByteLength(input) {\n  const explicitContentLength = input.headers.get(\"content-length\");\n  if (explicitContentLength != null && explicitContentLength !== \"\") {\n    return Number(explicitContentLength);\n  }\n  const buffer = await input.arrayBuffer();\n  return buffer.byteLength;\n}\nvar kIsRequestHandled = Symbol(\"kIsRequestHandled\");\nvar IS_NODE2 = isNodeProcess();\nvar kFetchRequest = Symbol(\"kFetchRequest\");\nvar XMLHttpRequestController = class {\n  constructor(initialRequest, logger) {\n    this.initialRequest = initialRequest;\n    this.logger = logger;\n    this.method = \"GET\";\n    this.url = null;\n    this[kIsRequestHandled] = false;\n    this.events = /* @__PURE__ */new Map();\n    this.uploadEvents = /* @__PURE__ */new Map();\n    this.requestId = createRequestId();\n    this.requestHeaders = new Headers();\n    this.responseBuffer = new Uint8Array();\n    this.request = createProxy(initialRequest, {\n      setProperty: ([propertyName, nextValue], invoke) => {\n        switch (propertyName) {\n          case \"ontimeout\":\n            {\n              const eventName = propertyName.slice(2);\n              this.request.addEventListener(eventName, nextValue);\n              return invoke();\n            }\n          default:\n            {\n              return invoke();\n            }\n        }\n      },\n      methodCall: ([methodName, args], invoke) => {\n        var _a;\n        switch (methodName) {\n          case \"open\":\n            {\n              const [method, url] = args;\n              if (typeof url === \"undefined\") {\n                this.method = \"GET\";\n                this.url = toAbsoluteUrl(method);\n              } else {\n                this.method = method;\n                this.url = toAbsoluteUrl(url);\n              }\n              this.logger = this.logger.extend(`${this.method} ${this.url.href}`);\n              this.logger.info(\"open\", this.method, this.url.href);\n              return invoke();\n            }\n          case \"addEventListener\":\n            {\n              const [eventName, listener] = args;\n              this.registerEvent(eventName, listener);\n              this.logger.info(\"addEventListener\", eventName, listener);\n              return invoke();\n            }\n          case \"setRequestHeader\":\n            {\n              const [name, value] = args;\n              this.requestHeaders.set(name, value);\n              this.logger.info(\"setRequestHeader\", name, value);\n              return invoke();\n            }\n          case \"send\":\n            {\n              const [body] = args;\n              this.request.addEventListener(\"load\", () => {\n                if (typeof this.onResponse !== \"undefined\") {\n                  const fetchResponse = createResponse(this.request,\n                  /**\n                   * The `response` property is the right way to read\n                   * the ambiguous response body, as the request's \"responseType\" may differ.\n                   * @see https://xhr.spec.whatwg.org/#the-response-attribute\n                   */\n                  this.request.response);\n                  this.onResponse.call(this, {\n                    response: fetchResponse,\n                    isMockedResponse: this[kIsRequestHandled],\n                    request: fetchRequest,\n                    requestId: this.requestId\n                  });\n                }\n              });\n              const requestBody = typeof body === \"string\" ? encodeBuffer(body) : body;\n              const fetchRequest = this.toFetchApiRequest(requestBody);\n              this[kFetchRequest] = fetchRequest.clone();\n              const onceRequestSettled = ((_a = this.onRequest) == null ? void 0 : _a.call(this, {\n                request: fetchRequest,\n                requestId: this.requestId\n              })) || Promise.resolve();\n              onceRequestSettled.finally(() => {\n                if (!this[kIsRequestHandled]) {\n                  this.logger.info(\"request callback settled but request has not been handled (readystate %d), performing as-is...\", this.request.readyState);\n                  if (IS_NODE2) {\n                    this.request.setRequestHeader(INTERNAL_REQUEST_ID_HEADER_NAME, this.requestId);\n                  }\n                  return invoke();\n                }\n              });\n              break;\n            }\n          default:\n            {\n              return invoke();\n            }\n        }\n      }\n    });\n    define(this.request, \"upload\", createProxy(this.request.upload, {\n      setProperty: ([propertyName, nextValue], invoke) => {\n        switch (propertyName) {\n          case \"onloadstart\":\n          case \"onprogress\":\n          case \"onaboart\":\n          case \"onerror\":\n          case \"onload\":\n          case \"ontimeout\":\n          case \"onloadend\":\n            {\n              const eventName = propertyName.slice(2);\n              this.registerUploadEvent(eventName, nextValue);\n            }\n        }\n        return invoke();\n      },\n      methodCall: ([methodName, args], invoke) => {\n        switch (methodName) {\n          case \"addEventListener\":\n            {\n              const [eventName, listener] = args;\n              this.registerUploadEvent(eventName, listener);\n              this.logger.info(\"upload.addEventListener\", eventName, listener);\n              return invoke();\n            }\n        }\n      }\n    }));\n  }\n  registerEvent(eventName, listener) {\n    const prevEvents = this.events.get(eventName) || [];\n    const nextEvents = prevEvents.concat(listener);\n    this.events.set(eventName, nextEvents);\n    this.logger.info('registered event \"%s\"', eventName, listener);\n  }\n  registerUploadEvent(eventName, listener) {\n    const prevEvents = this.uploadEvents.get(eventName) || [];\n    const nextEvents = prevEvents.concat(listener);\n    this.uploadEvents.set(eventName, nextEvents);\n    this.logger.info('registered upload event \"%s\"', eventName, listener);\n  }\n  /**\n   * Responds to the current request with the given\n   * Fetch API `Response` instance.\n   */\n  async respondWith(response) {\n    this[kIsRequestHandled] = true;\n    if (this[kFetchRequest]) {\n      const totalRequestBodyLength = await getBodyByteLength(this[kFetchRequest]);\n      this.trigger(\"loadstart\", this.request.upload, {\n        loaded: 0,\n        total: totalRequestBodyLength\n      });\n      this.trigger(\"progress\", this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength\n      });\n      this.trigger(\"load\", this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength\n      });\n      this.trigger(\"loadend\", this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength\n      });\n    }\n    this.logger.info(\"responding with a mocked response: %d %s\", response.status, response.statusText);\n    define(this.request, \"status\", response.status);\n    define(this.request, \"statusText\", response.statusText);\n    define(this.request, \"responseURL\", this.url.href);\n    this.request.getResponseHeader = new Proxy(this.request.getResponseHeader, {\n      apply: (_, __, args) => {\n        this.logger.info(\"getResponseHeader\", args[0]);\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info(\"headers not received yet, returning null\");\n          return null;\n        }\n        const headerValue = response.headers.get(args[0]);\n        this.logger.info('resolved response header \"%s\" to', args[0], headerValue);\n        return headerValue;\n      }\n    });\n    this.request.getAllResponseHeaders = new Proxy(this.request.getAllResponseHeaders, {\n      apply: () => {\n        this.logger.info(\"getAllResponseHeaders\");\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info(\"headers not received yet, returning empty string\");\n          return \"\";\n        }\n        const headersList = Array.from(response.headers.entries());\n        const allHeaders = headersList.map(([headerName, headerValue]) => {\n          return `${headerName}: ${headerValue}`;\n        }).join(\"\\r\\n\");\n        this.logger.info(\"resolved all response headers to\", allHeaders);\n        return allHeaders;\n      }\n    });\n    Object.defineProperties(this.request, {\n      response: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.response\n      },\n      responseText: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseText\n      },\n      responseXML: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseXML\n      }\n    });\n    const totalResponseBodyLength = await getBodyByteLength(response.clone());\n    this.logger.info(\"calculated response body length\", totalResponseBodyLength);\n    this.trigger(\"loadstart\", this.request, {\n      loaded: 0,\n      total: totalResponseBodyLength\n    });\n    this.setReadyState(this.request.HEADERS_RECEIVED);\n    this.setReadyState(this.request.LOADING);\n    const finalizeResponse = () => {\n      this.logger.info(\"finalizing the mocked response...\");\n      this.setReadyState(this.request.DONE);\n      this.trigger(\"load\", this.request, {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength\n      });\n      this.trigger(\"loadend\", this.request, {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength\n      });\n    };\n    if (response.body) {\n      this.logger.info(\"mocked response has body, streaming...\");\n      const reader = response.body.getReader();\n      const readNextResponseBodyChunk = async () => {\n        const {\n          value,\n          done\n        } = await reader.read();\n        if (done) {\n          this.logger.info(\"response body stream done!\");\n          finalizeResponse();\n          return;\n        }\n        if (value) {\n          this.logger.info(\"read response body chunk:\", value);\n          this.responseBuffer = concatArrayBuffer(this.responseBuffer, value);\n          this.trigger(\"progress\", this.request, {\n            loaded: this.responseBuffer.byteLength,\n            total: totalResponseBodyLength\n          });\n        }\n        readNextResponseBodyChunk();\n      };\n      readNextResponseBodyChunk();\n    } else {\n      finalizeResponse();\n    }\n  }\n  responseBufferToText() {\n    return decodeBuffer(this.responseBuffer);\n  }\n  get response() {\n    this.logger.info(\"getResponse (responseType: %s)\", this.request.responseType);\n    if (this.request.readyState !== this.request.DONE) {\n      return null;\n    }\n    switch (this.request.responseType) {\n      case \"json\":\n        {\n          const responseJson = parseJson(this.responseBufferToText());\n          this.logger.info(\"resolved response JSON\", responseJson);\n          return responseJson;\n        }\n      case \"arraybuffer\":\n        {\n          const arrayBuffer = toArrayBuffer(this.responseBuffer);\n          this.logger.info(\"resolved response ArrayBuffer\", arrayBuffer);\n          return arrayBuffer;\n        }\n      case \"blob\":\n        {\n          const mimeType = this.request.getResponseHeader(\"Content-Type\") || \"text/plain\";\n          const responseBlob = new Blob([this.responseBufferToText()], {\n            type: mimeType\n          });\n          this.logger.info(\"resolved response Blob (mime type: %s)\", responseBlob, mimeType);\n          return responseBlob;\n        }\n      default:\n        {\n          const responseText = this.responseBufferToText();\n          this.logger.info('resolving \"%s\" response type as text', this.request.responseType, responseText);\n          return responseText;\n        }\n    }\n  }\n  get responseText() {\n    invariant(this.request.responseType === \"\" || this.request.responseType === \"text\", \"InvalidStateError: The object is in invalid state.\");\n    if (this.request.readyState !== this.request.LOADING && this.request.readyState !== this.request.DONE) {\n      return \"\";\n    }\n    const responseText = this.responseBufferToText();\n    this.logger.info('getResponseText: \"%s\"', responseText);\n    return responseText;\n  }\n  get responseXML() {\n    invariant(this.request.responseType === \"\" || this.request.responseType === \"document\", \"InvalidStateError: The object is in invalid state.\");\n    if (this.request.readyState !== this.request.DONE) {\n      return null;\n    }\n    const contentType = this.request.getResponseHeader(\"Content-Type\") || \"\";\n    if (typeof DOMParser === \"undefined\") {\n      console.warn(\"Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly.\");\n      return null;\n    }\n    if (isDomParserSupportedType(contentType)) {\n      return new DOMParser().parseFromString(this.responseBufferToText(), contentType);\n    }\n    return null;\n  }\n  errorWith(error2) {\n    this[kIsRequestHandled] = true;\n    this.logger.info(\"responding with an error\");\n    this.setReadyState(this.request.DONE);\n    this.trigger(\"error\", this.request);\n    this.trigger(\"loadend\", this.request);\n  }\n  /**\n   * Transitions this request's `readyState` to the given one.\n   */\n  setReadyState(nextReadyState) {\n    this.logger.info(\"setReadyState: %d -> %d\", this.request.readyState, nextReadyState);\n    if (this.request.readyState === nextReadyState) {\n      this.logger.info(\"ready state identical, skipping transition...\");\n      return;\n    }\n    define(this.request, \"readyState\", nextReadyState);\n    this.logger.info(\"set readyState to: %d\", nextReadyState);\n    if (nextReadyState !== this.request.UNSENT) {\n      this.logger.info('triggerring \"readystatechange\" event...');\n      this.trigger(\"readystatechange\", this.request);\n    }\n  }\n  /**\n   * Triggers given event on the `XMLHttpRequest` instance.\n   */\n  trigger(eventName, target, options) {\n    const callback = target[`on${eventName}`];\n    const event = createEvent(target, eventName, options);\n    this.logger.info('trigger \"%s\"', eventName, options || \"\");\n    if (typeof callback === \"function\") {\n      this.logger.info('found a direct \"%s\" callback, calling...', eventName);\n      callback.call(target, event);\n    }\n    const events = target instanceof XMLHttpRequestUpload ? this.uploadEvents : this.events;\n    for (const [registeredEventName, listeners] of events) {\n      if (registeredEventName === eventName) {\n        this.logger.info('found %d listener(s) for \"%s\" event, calling...', listeners.length, eventName);\n        listeners.forEach(listener => listener.call(target, event));\n      }\n    }\n  }\n  /**\n   * Converts this `XMLHttpRequest` instance into a Fetch API `Request` instance.\n   */\n  toFetchApiRequest(body) {\n    this.logger.info(\"converting request to a Fetch API Request...\");\n    const resolvedBody = body instanceof Document ? body.documentElement.innerText : body;\n    const fetchRequest = new Request(this.url.href, {\n      method: this.method,\n      headers: this.requestHeaders,\n      /**\n       * @see https://xhr.spec.whatwg.org/#cross-origin-credentials\n       */\n      credentials: this.request.withCredentials ? \"include\" : \"same-origin\",\n      body: [\"GET\", \"HEAD\"].includes(this.method.toUpperCase()) ? null : resolvedBody\n    });\n    const proxyHeaders = createProxy(fetchRequest.headers, {\n      methodCall: ([methodName, args], invoke) => {\n        switch (methodName) {\n          case \"append\":\n          case \"set\":\n            {\n              const [headerName, headerValue] = args;\n              this.request.setRequestHeader(headerName, headerValue);\n              break;\n            }\n          case \"delete\":\n            {\n              const [headerName] = args;\n              console.warn(`XMLHttpRequest: Cannot remove a \"${headerName}\" header from the Fetch API representation of the \"${fetchRequest.method} ${fetchRequest.url}\" request. XMLHttpRequest headers cannot be removed.`);\n              break;\n            }\n        }\n        return invoke();\n      }\n    });\n    define(fetchRequest, \"headers\", proxyHeaders);\n    setRawRequest(fetchRequest, this.request);\n    this.logger.info(\"converted request to a Fetch API Request!\", fetchRequest);\n    return fetchRequest;\n  }\n};\nfunction toAbsoluteUrl(url) {\n  if (typeof location === \"undefined\") {\n    return new URL(url);\n  }\n  return new URL(url.toString(), location.href);\n}\nfunction define(target, property, value) {\n  Reflect.defineProperty(target, property, {\n    // Ensure writable properties to allow redefining readonly properties.\n    writable: true,\n    enumerable: true,\n    value\n  });\n}\nfunction createXMLHttpRequestProxy({\n  emitter,\n  logger\n}) {\n  const XMLHttpRequestProxy = new Proxy(globalThis.XMLHttpRequest, {\n    construct(target, args, newTarget) {\n      logger.info(\"constructed new XMLHttpRequest\");\n      const originalRequest = Reflect.construct(target, args, newTarget);\n      const prototypeDescriptors = Object.getOwnPropertyDescriptors(target.prototype);\n      for (const propertyName in prototypeDescriptors) {\n        Reflect.defineProperty(originalRequest, propertyName, prototypeDescriptors[propertyName]);\n      }\n      const xhrRequestController = new XMLHttpRequestController(originalRequest, logger);\n      xhrRequestController.onRequest = async function ({\n        request,\n        requestId\n      }) {\n        const controller = new RequestController(request);\n        this.logger.info(\"awaiting mocked response...\");\n        this.logger.info('emitting the \"request\" event for %s listener(s)...', emitter.listenerCount(\"request\"));\n        const isRequestHandled = await handleRequest2({\n          request,\n          requestId,\n          controller,\n          emitter,\n          onResponse: async response => {\n            await this.respondWith(response);\n          },\n          onRequestError: () => {\n            this.errorWith(new TypeError(\"Network error\"));\n          },\n          onError: error2 => {\n            this.logger.info(\"request errored!\", {\n              error: error2\n            });\n            if (error2 instanceof Error) {\n              this.errorWith(error2);\n            }\n          }\n        });\n        if (!isRequestHandled) {\n          this.logger.info(\"no mocked response received, performing request as-is...\");\n        }\n      };\n      xhrRequestController.onResponse = async function ({\n        response,\n        isMockedResponse,\n        request,\n        requestId\n      }) {\n        this.logger.info('emitting the \"response\" event for %s listener(s)...', emitter.listenerCount(\"response\"));\n        emitter.emit(\"response\", {\n          response,\n          isMockedResponse,\n          request,\n          requestId\n        });\n      };\n      return xhrRequestController.request;\n    }\n  });\n  return XMLHttpRequestProxy;\n}\nvar _XMLHttpRequestInterceptor = class extends Interceptor {\n  constructor() {\n    super(_XMLHttpRequestInterceptor.interceptorSymbol);\n  }\n  checkEnvironment() {\n    return hasConfigurableGlobal(\"XMLHttpRequest\");\n  }\n  setup() {\n    const logger = this.logger.extend(\"setup\");\n    logger.info('patching \"XMLHttpRequest\" module...');\n    const PureXMLHttpRequest = globalThis.XMLHttpRequest;\n    invariant(!PureXMLHttpRequest[IS_PATCHED_MODULE], 'Failed to patch the \"XMLHttpRequest\" module: already patched.');\n    globalThis.XMLHttpRequest = createXMLHttpRequestProxy({\n      emitter: this.emitter,\n      logger: this.logger\n    });\n    logger.info('native \"XMLHttpRequest\" module patched!', globalThis.XMLHttpRequest.name);\n    Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true\n    });\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n        value: void 0\n      });\n      globalThis.XMLHttpRequest = PureXMLHttpRequest;\n      logger.info('native \"XMLHttpRequest\" module restored!', globalThis.XMLHttpRequest.name);\n    });\n  }\n};\nvar XMLHttpRequestInterceptor = _XMLHttpRequestInterceptor;\nXMLHttpRequestInterceptor.interceptorSymbol = Symbol(\"xhr\");\n\n// src/browser/setupWorker/start/createFallbackRequestListener.ts\nimport { handleRequest as handleRequest3 } from '../core/utils/handleRequest.mjs';\nimport { isHandlerKind as isHandlerKind2 } from '../core/utils/internal/isHandlerKind.mjs';\nfunction createFallbackRequestListener(context, options) {\n  const interceptor = new BatchInterceptor({\n    name: \"fallback\",\n    interceptors: [new FetchInterceptor(), new XMLHttpRequestInterceptor()]\n  });\n  interceptor.on(\"request\", async ({\n    request,\n    requestId,\n    controller\n  }) => {\n    const requestCloneForLogs = request.clone();\n    const response = await handleRequest3(request, requestId, context.getRequestHandlers().filter(isHandlerKind2(\"RequestHandler\")), options, context.emitter, {\n      onMockedResponse(_, {\n        handler,\n        parsedResult\n      }) {\n        if (!options.quiet) {\n          context.emitter.once(\"response:mocked\", ({\n            response: response2\n          }) => {\n            handler.log({\n              request: requestCloneForLogs,\n              response: response2,\n              parsedResult\n            });\n          });\n        }\n      }\n    });\n    if (response) {\n      controller.respondWith(response);\n    }\n  });\n  interceptor.on(\"response\", ({\n    response,\n    isMockedResponse,\n    request,\n    requestId\n  }) => {\n    context.emitter.emit(isMockedResponse ? \"response:mocked\" : \"response:bypass\", {\n      response,\n      request,\n      requestId\n    });\n  });\n  interceptor.apply();\n  return interceptor;\n}\n\n// src/browser/setupWorker/stop/utils/printStopMessage.ts\nimport { devUtils as devUtils7 } from '../core/utils/internal/devUtils.mjs';\nfunction printStopMessage(args = {}) {\n  if (args.quiet) {\n    return;\n  }\n  console.log(`%c${devUtils7.formatMessage(\"Mocking disabled.\")}`, \"color:orangered;font-weight:bold;\");\n}\n\n// src/browser/setupWorker/setupWorker.ts\nvar SetupWorkerApi = class extends SetupApi {\n  context;\n  constructor(...handlers) {\n    super(...handlers);\n    invariant(!isNodeProcess(), devUtils8.formatMessage(\"Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.\"));\n    this.context = this.createWorkerContext();\n  }\n  createWorkerContext() {\n    const workerPromise = new DeferredPromise();\n    return {\n      // Mocking is not considered enabled until the worker\n      // signals back the successful activation event.\n      isMockingEnabled: false,\n      startOptions: null,\n      workerPromise,\n      registration: void 0,\n      getRequestHandlers: () => {\n        return this.handlersController.currentHandlers();\n      },\n      emitter: this.emitter,\n      workerChannel: new WorkerChannel({\n        worker: workerPromise\n      }),\n      supports: {\n        serviceWorkerApi: \"serviceWorker\" in navigator && location.protocol !== \"file:\",\n        readableStreamTransfer: supportsReadableStreamTransfer()\n      }\n    };\n  }\n  async start(options = {}) {\n    if (\"waitUntilReady\" in options) {\n      devUtils8.warn('The \"waitUntilReady\" option has been deprecated. Please remove it from this \"worker.start()\" call. Follow the recommended Browser integration (https://mswjs.io/docs/integrations/browser) to eliminate any race conditions between the Service Worker registration and any requests made by your application on initial render.');\n    }\n    if (this.context.isMockingEnabled) {\n      devUtils8.warn(`Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`);\n      return this.context.registration;\n    }\n    this.context.workerStoppedAt = void 0;\n    this.context.startOptions = mergeRight2(DEFAULT_START_OPTIONS, options);\n    handleWebSocketEvent({\n      getUnhandledRequestStrategy: () => {\n        return this.context.startOptions.onUnhandledRequest;\n      },\n      getHandlers: () => {\n        return this.handlersController.currentHandlers();\n      },\n      onMockedConnection: connection => {\n        if (!this.context.startOptions.quiet) {\n          attachWebSocketLogger(connection);\n        }\n      },\n      onPassthroughConnection() {}\n    });\n    webSocketInterceptor.apply();\n    this.subscriptions.push(() => {\n      webSocketInterceptor.dispose();\n    });\n    if (!this.context.supports.serviceWorkerApi) {\n      const fallbackInterceptor = createFallbackRequestListener(this.context, this.context.startOptions);\n      this.subscriptions.push(() => {\n        fallbackInterceptor.dispose();\n      });\n      this.context.isMockingEnabled = true;\n      printStartMessage({\n        message: \"Mocking enabled (fallback mode).\",\n        quiet: this.context.startOptions.quiet\n      });\n      return void 0;\n    }\n    const startHandler = createStartHandler(this.context);\n    const registration = await startHandler(this.context.startOptions, options);\n    this.context.isMockingEnabled = true;\n    return registration;\n  }\n  stop() {\n    super.dispose();\n    if (!this.context.isMockingEnabled) {\n      devUtils8.warn('Found a redundant \"worker.stop()\" call. Notice that stopping the worker after it has already been stopped has no effect. Consider removing this \"worker.stop()\" call.');\n      return;\n    }\n    this.context.isMockingEnabled = false;\n    this.context.workerStoppedAt = Date.now();\n    this.context.emitter.removeAllListeners();\n    if (this.context.supports.serviceWorkerApi) {\n      this.context.workerChannel.removeAllListeners(\"RESPONSE\");\n      window.clearInterval(this.context.keepAliveInterval);\n    }\n    window.postMessage({\n      type: \"msw/worker:stop\"\n    });\n    printStopMessage({\n      quiet: this.context.startOptions?.quiet\n    });\n  }\n};\nfunction setupWorker(...handlers) {\n  return new SetupWorkerApi(...handlers);\n}\nexport { SetupWorkerApi, setupWorker };","map":{"version":3,"names":["POSITIONALS_EXP","serializePositional","positional","flag","Number","JSON","stringify","json","test","format","message","positionals","length","positionalIndex","formattedMessage","replace","match","isEscaped","_","value","slice","join","STACK_FRAMES_TO_IGNORE","cleanErrorStack","error2","stack","nextStack","split","splice","InvariantError","Error","constructor","name","invariant","predicate","as","ErrorConstructor","formatMessage","Reflect","construct","err","isNodeProcess","navigator","product","process","type","versions","node","mergeRight","DEFAULT_START_OPTIONS","serviceWorker","url","options","quiet","waitUntilReady","onUnhandledRequest","findWorker","scriptURL","mockServiceWorkerUrl","devUtils","devUtils6","until","promise","data","catch","error","getAbsoluteWorkerUrl","workerUrl","URL","location","href","getWorkerByRegistration","registration","absoluteWorkerUrl","allStates","active","installing","waiting","relevantStates","filter","state","worker","find","worker2","getWorkerInstance","mockRegistrations","getRegistrations","then","registrations","controller","reload","existingRegistration","update","registrationResult","register","isWorkerMissing","includes","scopeUrl","scope","createDeferredExecutor","executor","resolve","reject","result","onFulfilled","Promise","reason","queueMicrotask","rejectionReason","DeferredPromise","deferredExecutor","originalResolve","originalReject","onRejected","decorate","finally","onfinally","#decorate","Object","defineProperties","configurable","devUtils2","printStartMessage","args","console","groupCollapsed","log","workerScope","client","id","frameType","groupEnd","enableMocking","context","mockingEnabledPromise","workerChannel","postMessage","once","event","isMockingEnabled","workerPromise","pruneGetRequestBody","request","method","body","deserializeRequest","serializedRequest","Request","RequestHandler","handleRequest","devUtils3","toResponseInit","isHandlerKind","createRequestListener","workerStoppedAt","interceptedAt","requestId","requestCloneForLogs","clone","requestClone","cache","set","getRequestHandlers","emitter","onPassthroughResponse","onMockedResponse","response","handler","parsedResult","responseClone","responseCloneForLogs","responseInit","supports","readableStreamTransfer","responseStreamOrNull","responseBufferOrNull","arrayBuffer","status","statusText","headers","devUtils4","checkWorkerIntegrity","integrityCheckPromise","checksum","packageVersion","warn","encoder","TextEncoder","encodeBuffer","text","encode","decodeBuffer","buffer","encoding","decoder","TextDecoder","decode","toArrayBuffer","array","byteOffset","byteLength","IS_PATCHED_MODULE","Symbol","canParseUrl","_error","getValueBySymbol","symbolName","source","ownSymbols","getOwnPropertySymbols","symbol","symbol2","description","get","_FetchResponse","Response","isConfigurableStatusCode","isRedirectResponse","STATUS_CODES_WITH_REDIRECT","isResponseWithBody","STATUS_CODES_WITHOUT_BODY","setUrl","urlList","push","defineProperty","enumerable","writable","parseRawHeaders","rawHeaders","Headers","line","append","init","_a","safeStatus","finalBody","FetchResponse","kRawRequest","setRawRequest","rawRequest","__defProp","__export","target","all","colors_exports","blue","gray","green","red","yellow","IS_NODE","Logger","prefix","LOGGER_NAME","getVariable","LOGGER_LEVEL","isLoggingEnabled","startsWith","debug","isDefinedAndNotEquals","noop","info","success","warning","only","extend","domain","logEntry","level","colors","performance2","PerformanceEntry","message2","positionals2","measure","deltaTime","timestamp","callback","createEntry","Date","customColors","entry","timestampColor","prefixColor","colorize","write","getWriter","formatTimestamp","concat","serializeInput","map","toLocaleTimeString","getMilliseconds","startTime","endTime","performance","now","toFixed","stdout","stderr","variableName","env","globalThis","toString","expected","MemoryLeakError","count","_Emitter","listenerCount","eventName","events","Map","maxListeners","defaultMaxListeners","hasWarnedAboutPotentialMemoryLeak","_emitInternalEvent","internalEventName","listener","emit","_getListeners","Array","prototype","apply","_removeListener","listeners","index","indexOf","_wrapOnceListener","onceListener","removeListener","setMaxListeners","getMaxListeners","eventNames","from","keys","forEach","addListener","nextListeners","memoryLeakWarning","on","prependListener","prependOnceListener","off","removeAllListeners","delete","clear","rawListeners","Emitter","INTERNAL_REQUEST_ID_HEADER_NAME","getGlobalSymbol","setGlobalSymbol","deleteGlobalSymbol","Interceptor","readyState","subscriptions","logger","checkEnvironment","shouldApply","runningInstance","getInstance","setup","setInstance","dispose","clearInstance","instance","createRequestId","Math","random","BatchInterceptor","interceptors","interceptor","createResponseListener","responseMessage","isMockedResponse","devUtils5","validateWorkerScope","createStartHandler","start","customOptions","startWorkerInstance","missingWorkerMessage","host","window","addEventListener","clearInterval","keepAliveInterval","setInterval","startOptions","workerRegistration","pendingInstance","activationPromise","devUtils8","SetupApi","mergeRight2","supportsReadableStreamTransfer","stream","ReadableStream","close","MessageChannel","port1","webSocketInterceptor","handleWebSocketEvent","attachWebSocketLogger","kDefaultPrevented","kPropagationStopped","kImmediatePropagationStopped","TypedEvent","MessageEvent","returnType","defaultPrevented","preventDefault","stopImmediatePropagation","kListenerOptions","Emitter2","earlyOn","earlyOnce","proxiedEvent","proxyEvent","callListener","revoke","emitAsPromise","pendingListeners","allSettled","results","emitAsGenerator","existingListener","values","flat","#addListener","insertMode","unshift","signal","#proxyEvent","stopPropagation","Proxy","thisArg","argArray","#callListener","returnValue","call","isObject","WorkerEvent","workerEvent","payload","ports","rest","transfer","WorkerChannel","InterceptorError","setPrototypeOf","kRequestHandled","kResponsePromise","RequestController","respondWith","errorWith","emitAsync","listners","isObject2","loose","isPropertyAccessible","obj","key","e","createServerErrorResponse","isResponseError","isResponseLike","isNodeLikeError","handleRequest2","handleResponse","onError","onRequestError","onResponse","handleResponseError","pendingRequestId","requestAbortPromise","aborted","requestListenersPromise","race","unhandledExceptionController","nextResult","hasConfigurableGlobal","propertyName","descriptor","getOwnPropertyDescriptor","createNetworkError","cause","assign","TypeError","REQUEST_BODY_HEADERS","kRedirectCount","followFetchRedirect","requestUrl","locationUrl","protocol","mode","username","password","sameOrigin","requestInit","headerName","fetch","left","right","origin","hostname","port","BrotliDecompressionStream","TransformStream","transform","chunk","enqueue","PipelineStream","transformStreams","strategies","readable","reduce","readable2","pipeThrough","parseContentEncoding","contentEncoding","toLowerCase","coding","trim","createDecompressionStream","codings","transformers","reduceRight","transformers2","DecompressionStream","decompressResponse","decompressionStream","pipeTo","_FetchInterceptor","pureFetch","input","resolvedInput","responsePromise","isRequestHandled","rawResponse","decompressedStream","redirect","response2","requestCloneForResponseEvent","FetchInterceptor","concatArrayBuffer","Uint8Array","EventPolyfill","NONE","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","srcElement","currentTarget","eventPhase","isTrusted","composed","cancelable","bubbles","lengthComputable","loaded","total","cancelBubble","timeStamp","composedPath","initEvent","ProgressEventPolyfill","SUPPORTS_PROGRESS_EVENT","ProgressEvent","createEvent","progressEvents","ProgressEventClass","findPropertySource","hasProperty","hasOwnProperty","getPrototypeOf","createProxy","proxy","optionsToProxyHandler","constructorCall","methodCall","getProperty","setProperty","newTarget","next","bind","nextValue","propertySource","ownDescriptors","receiver","next2","isDomParserSupportedType","supportedTypes","some","supportedType","parseJson","parse","createResponse","responseBodyOrNull","responseURL","createHeadersFromXMLHttpReqestHeaders","getAllResponseHeaders","headersString","lines","parts","getBodyByteLength","explicitContentLength","kIsRequestHandled","IS_NODE2","kFetchRequest","XMLHttpRequestController","initialRequest","uploadEvents","requestHeaders","responseBuffer","invoke","methodName","toAbsoluteUrl","registerEvent","fetchResponse","fetchRequest","requestBody","toFetchApiRequest","onceRequestSettled","onRequest","setRequestHeader","define","upload","registerUploadEvent","prevEvents","nextEvents","totalRequestBodyLength","trigger","getResponseHeader","__","HEADERS_RECEIVED","headerValue","headersList","entries","allHeaders","responseText","responseXML","totalResponseBodyLength","setReadyState","LOADING","finalizeResponse","DONE","reader","getReader","readNextResponseBodyChunk","done","read","responseBufferToText","responseType","responseJson","mimeType","responseBlob","Blob","contentType","DOMParser","parseFromString","nextReadyState","UNSENT","XMLHttpRequestUpload","registeredEventName","resolvedBody","Document","documentElement","innerText","credentials","withCredentials","toUpperCase","proxyHeaders","property","createXMLHttpRequestProxy","XMLHttpRequestProxy","XMLHttpRequest","originalRequest","prototypeDescriptors","getOwnPropertyDescriptors","xhrRequestController","_XMLHttpRequestInterceptor","interceptorSymbol","PureXMLHttpRequest","XMLHttpRequestInterceptor","handleRequest3","isHandlerKind2","createFallbackRequestListener","devUtils7","printStopMessage","SetupWorkerApi","handlers","createWorkerContext","handlersController","currentHandlers","serviceWorkerApi","getUnhandledRequestStrategy","getHandlers","onMockedConnection","connection","onPassthroughConnection","fallbackInterceptor","startHandler","stop","setupWorker"],"sources":["C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\outvariant@1.4.3\\node_modules\\outvariant\\src\\format.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\outvariant@1.4.3\\node_modules\\outvariant\\src\\invariant.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\is-node-process@1.2.0\\node_modules\\is-node-process\\src\\index.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\utils\\prepareStartHandler.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\createStartHandler.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@open-draft+until@2.1.0\\node_modules\\@open-draft\\until\\src\\until.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\utils\\getWorkerInstance.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\utils\\getAbsoluteWorkerUrl.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\utils\\getWorkerByRegistration.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@open-draft+deferred-promise@2.2.0\\node_modules\\@open-draft\\deferred-promise\\src\\createDeferredExecutor.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@open-draft+deferred-promise@2.2.0\\node_modules\\@open-draft\\deferred-promise\\src\\DeferredPromise.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\utils\\printStartMessage.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\utils\\enableMocking.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\utils\\pruneGetRequestBody.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\utils\\deserializeRequest.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\createRequestListener.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\utils\\checkWorkerIntegrity.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\bufferUtils.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\glossary.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\canParseUrl.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\getValueBySymbol.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\fetchUtils.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\getRawRequest.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@open-draft+logger@0.3.0\\node_modules\\@open-draft\\logger\\lib\\index.mjs","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\strict-event-emitter@0.5.1\\node_modules\\strict-event-emitter\\src\\MemoryLeakError.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\strict-event-emitter@0.5.1\\node_modules\\strict-event-emitter\\src\\Emitter.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\Interceptor.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\createRequestId.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\BatchInterceptor.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\getCleanUrl.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\createResponseListener.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\utils\\validateWorkerScope.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\setupWorker.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\utils\\supportsReadableStreamTransfer.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\rettime@0.7.0\\node_modules\\rettime\\src\\index.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\utils\\workerChannel.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\RequestController.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\InterceptorError.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\emitAsync.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\handleRequest.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\isObject.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\isPropertyAccessible.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\responseUtils.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\isNodeLikeError.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\hasConfigurableGlobal.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\fetch\\index.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\fetch\\utils\\createNetworkError.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\fetch\\utils\\followRedirect.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\fetch\\utils\\brotli-decompress.browser.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\fetch\\utils\\decompression.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\index.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\XMLHttpRequestController.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\utils\\concatArrayBuffer.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\polyfills\\EventPolyfill.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\polyfills\\ProgressEventPolyfill.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\utils\\createEvent.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\findPropertySource.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\createProxy.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\utils\\isDomParserSupportedType.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\utils\\parseJson.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\utils\\createResponse.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\utils\\getBodyByteLength.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\node_modules\\.pnpm\\@mswjs+interceptors@0.39.1\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\XMLHttpRequest\\XMLHttpRequestProxy.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\start\\createFallbackRequestListener.ts","C:\\Users\\shiva\\Desktop\\talentflow-mini-hiring-platform\\TalentFlow\\node_modules\\msw\\src\\browser\\setupWorker\\stop\\utils\\printStopMessage.ts"],"sourcesContent":["const POSITIONALS_EXP = /(%?)(%([sdijo]))/g\n\nfunction serializePositional(positional: any, flag: string): any {\n  switch (flag) {\n    // Strings.\n    case 's':\n      return positional\n\n    // Digits.\n    case 'd':\n    case 'i':\n      return Number(positional)\n\n    // JSON.\n    case 'j':\n      return JSON.stringify(positional)\n\n    // Objects.\n    case 'o': {\n      // Preserve stings to prevent extra quotes around them.\n      if (typeof positional === 'string') {\n        return positional\n      }\n\n      const json = JSON.stringify(positional)\n\n      // If the positional isn't serializable, return it as-is.\n      if (json === '{}' || json === '[]' || /^\\[object .+?\\]$/.test(json)) {\n        return positional\n      }\n\n      return json\n    }\n  }\n}\n\nexport function format(message: string, ...positionals: any[]): string {\n  if (positionals.length === 0) {\n    return message\n  }\n\n  let positionalIndex = 0\n  let formattedMessage = message.replace(\n    POSITIONALS_EXP,\n    (match, isEscaped, _, flag) => {\n      const positional = positionals[positionalIndex]\n      const value = serializePositional(positional, flag)\n\n      if (!isEscaped) {\n        positionalIndex++\n        return value\n      }\n\n      return match\n    }\n  )\n\n  // Append unresolved positionals to string as-is.\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(' ')}`\n  }\n\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, '%')\n\n  return formattedMessage\n}\n","import { format } from './format'\n\nconst STACK_FRAMES_TO_IGNORE = 2\n\n/**\n * Remove the \"outvariant\" package trace from the given error.\n * This scopes down the error stack to the relevant parts\n * when used in other applications.\n */\nfunction cleanErrorStack(error: Error): void {\n  if (!error.stack) {\n    return\n  }\n\n  const nextStack = error.stack.split('\\n')\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE)\n  error.stack = nextStack.join('\\n')\n}\n\nexport class InvariantError extends Error {\n  name = 'Invariant Violation'\n\n  constructor(public readonly message: string, ...positionals: any[]) {\n    super(message)\n    this.message = format(message, ...positionals)\n    cleanErrorStack(this)\n  }\n}\n\nexport interface CustomErrorConstructor {\n  new (message: string): Error\n}\n\nexport interface CustomErrorFactory {\n  (message: string): Error\n}\n\nexport type CustomError = CustomErrorConstructor | CustomErrorFactory\n\ntype Invariant = {\n  (\n    predicate: unknown,\n    message: string,\n    ...positionals: any[]\n  ): asserts predicate\n\n  as(\n    ErrorConstructor: CustomError,\n    predicate: unknown,\n    message: string,\n    ...positionals: unknown[]\n  ): asserts predicate\n}\n\nexport const invariant: Invariant = (\n  predicate,\n  message,\n  ...positionals\n): asserts predicate => {\n  if (!predicate) {\n    throw new InvariantError(message, ...positionals)\n  }\n}\n\ninvariant.as = (ErrorConstructor, predicate, message, ...positionals) => {\n  if (!predicate) {\n    const formatMessage =\n      positionals.length === 0 ? message : format(message, ...positionals)\n    let error: Error\n\n    try {\n      error = Reflect.construct(ErrorConstructor as CustomErrorConstructor, [\n        formatMessage,\n      ])\n    } catch (err) {\n      error = (ErrorConstructor as CustomErrorFactory)(formatMessage)\n    }\n\n    throw error\n  }\n}\n","/**\n * Determines if the current process is a Node.js process.\n */\nexport function isNodeProcess(): boolean {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return true\n  }\n\n  if (typeof process !== 'undefined') {\n    // Electron (https://www.electronjs.org/docs/latest/api/process#processtype-readonly)\n    const type = (process as any).type\n    if (type === 'renderer' || type === 'worker') {\n      return false\n    }\n\n\n    return !!(\n      process.versions &&\n      process.versions.node\n    )\n  }\n\n  return false\n}\n","import { RequiredDeep } from '~/core/typeUtils'\nimport { mergeRight } from '~/core/utils/internal/mergeRight'\nimport {\n  SetupWorker,\n  SetupWorkerInternalContext,\n  StartHandler,\n  StartOptions,\n} from '../../glossary'\n\nexport const DEFAULT_START_OPTIONS: RequiredDeep<StartOptions> = {\n  serviceWorker: {\n    url: '/mockServiceWorker.js',\n    options: null as any,\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: 'warn',\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl\n  },\n}\n\n/**\n * Returns resolved worker start options, merging the default options\n * with the given custom options.\n */\nexport function resolveStartOptions(\n  initialOptions?: StartOptions,\n): RequiredDeep<StartOptions> {\n  return mergeRight(\n    DEFAULT_START_OPTIONS,\n    initialOptions || {},\n  ) as RequiredDeep<StartOptions>\n}\n\nexport function prepareStartHandler(\n  handler: StartHandler,\n  context: SetupWorkerInternalContext,\n): SetupWorker['start'] {\n  return (initialOptions) => {\n    context.startOptions = resolveStartOptions(initialOptions)\n    return handler(context.startOptions, initialOptions || {})\n  }\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport { getWorkerInstance } from './utils/getWorkerInstance'\nimport { enableMocking } from './utils/enableMocking'\nimport type { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { createRequestListener } from './createRequestListener'\nimport { checkWorkerIntegrity } from '../../utils/checkWorkerIntegrity'\nimport { createResponseListener } from './createResponseListener'\nimport { validateWorkerScope } from './utils/validateWorkerScope'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\n\nexport const createStartHandler = (\n  context: SetupWorkerInternalContext,\n): StartHandler => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      // Remove all previously existing event listeners.\n      // This way none of the listeners persists between Fast refresh\n      // of the application's code.\n      context.workerChannel.removeAllListeners()\n\n      // Handle requests signaled by the worker.\n      context.workerChannel.on(\n        'REQUEST',\n        createRequestListener(context, options),\n      )\n\n      // Handle responses signaled by the worker.\n      context.workerChannel.on('RESPONSE', createResponseListener(context))\n\n      const instance = await getWorkerInstance(\n        options.serviceWorker.url,\n        options.serviceWorker.options,\n        options.findWorker,\n      )\n\n      const [worker, registration] = instance\n\n      if (!worker) {\n        const missingWorkerMessage = customOptions?.findWorker\n          ? devUtils.formatMessage(\n              `Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`,\n              options.serviceWorker.url,\n            )\n          : devUtils.formatMessage(\n              `Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,\n              options.serviceWorker.url,\n              location.host,\n            )\n\n        throw new Error(missingWorkerMessage)\n      }\n\n      context.workerPromise.resolve(worker)\n      context.registration = registration\n\n      window.addEventListener('beforeunload', () => {\n        if (worker.state !== 'redundant') {\n          // Notify the Service Worker that this client has closed.\n          // Internally, it's similar to disabling the mocking, only\n          // client close event has a handler that self-terminates\n          // the Service Worker when there are no open clients.\n          context.workerChannel.postMessage('CLIENT_CLOSED')\n        }\n\n        // Make sure we're always clearing the interval - there are reports that not doing this can\n        // cause memory leaks in headless browser environments.\n        window.clearInterval(context.keepAliveInterval)\n\n        // Notify others about this client disconnecting.\n        // E.g. this will purge the in-memory WebSocket clients since\n        // starting the worker again will assign them new IDs.\n        window.postMessage({ type: 'msw/worker:stop' })\n      })\n\n      // Check if the active Service Worker has been generated\n      // by the currently installed version of MSW.\n      await checkWorkerIntegrity(context).catch((error) => {\n        devUtils.error(\n          'Error while checking the worker script integrity. Please report this on GitHub (https://github.com/mswjs/msw/issues) and include the original error below.',\n        )\n        console.error(error)\n      })\n\n      context.keepAliveInterval = window.setInterval(\n        () => context.workerChannel.postMessage('KEEPALIVE_REQUEST'),\n        5000,\n      )\n\n      // Warn the user when loading the page that lies outside\n      // of the worker's scope.\n      validateWorkerScope(registration, context.startOptions)\n\n      return registration\n    }\n\n    const workerRegistration = startWorkerInstance().then(\n      async (registration) => {\n        const pendingInstance = registration.installing || registration.waiting\n\n        if (pendingInstance) {\n          const activationPromise = new DeferredPromise<void>()\n\n          pendingInstance.addEventListener('statechange', () => {\n            if (pendingInstance.state === 'activated') {\n              activationPromise.resolve()\n            }\n          })\n\n          // Wait until the worker is activated.\n          // Assume the worker is already activated if there's no pending registration\n          // (i.e. when reloading the page after a successful activation).\n          await activationPromise\n        }\n\n        // Print the activation message only after the worker has been activated.\n        await enableMocking(context, options).catch((error) => {\n          devUtils.error(\n            'Failed to enable mocking. Please report this on GitHub (https://github.com/mswjs/msw/issues) and include the original error below.',\n          )\n          throw error\n        })\n\n        return registration\n      },\n    )\n\n    return workerRegistration\n  }\n}\n","export type AsyncTuple<\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n> =\n  | {\n      error: ErrorType\n      data: null\n    }\n  | { error: null; data: DataType }\n\n/**\n * Gracefully handles a given Promise factory.\n * @example\n * const { error, data } = await until(() => asyncAction())\n */\nexport const until = async <\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n>(\n  promise: () => Promise<DataType>,\n): Promise<AsyncTuple<ErrorType, DataType>> => {\n  try {\n    const data = await promise().catch((error) => {\n      throw error\n    })\n    return { error: null, data }\n  } catch (error) {\n    return { error, data: null }\n  }\n}\n","import { until } from '@open-draft/until'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { getAbsoluteWorkerUrl } from '../../../utils/getAbsoluteWorkerUrl'\nimport { getWorkerByRegistration } from './getWorkerByRegistration'\nimport { ServiceWorkerInstanceTuple, FindWorker } from '../../glossary'\n\n/**\n * Returns an active Service Worker instance.\n * When not found, registers a new Service Worker.\n */\nexport const getWorkerInstance = async (\n  url: string,\n  options: RegistrationOptions = {},\n  findWorker: FindWorker,\n): Promise<ServiceWorkerInstanceTuple> => {\n  // Resolve the absolute Service Worker URL.\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url)\n\n  const mockRegistrations = await navigator.serviceWorker\n    .getRegistrations()\n    .then((registrations) =>\n      registrations.filter((registration) =>\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n      ),\n    )\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    // Reload the page when it has associated workers, but no active controller.\n    // The absence of a controller can mean either:\n    // - page has no Service Worker associated with it\n    // - page has been hard-reloaded and its workers won't be used until the next reload.\n    // Since we've checked that there are registrations associated with this page,\n    // at this point we are sure it's hard reload that falls into this clause.\n    location.reload()\n  }\n\n  const [existingRegistration] = mockRegistrations\n\n  if (existingRegistration) {\n    // Schedule the worker update in the background.\n    // Update ensures the existing worker is up-to-date.\n    existingRegistration.update()\n\n    // Return the worker reference immediately.\n    return [\n      getWorkerByRegistration(\n        existingRegistration,\n        absoluteWorkerUrl,\n        findWorker,\n      ),\n      existingRegistration,\n    ]\n  }\n\n  // When the Service Worker wasn't found, register it anew and return the reference.\n  const registrationResult = await until<Error, ServiceWorkerInstanceTuple>(\n    async () => {\n      const registration = await navigator.serviceWorker.register(url, options)\n      return [\n        // Compare existing worker registration by its worker URL,\n        // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n        registration,\n      ]\n    },\n  )\n\n  // Handle Service Worker registration errors.\n  if (registrationResult.error) {\n    const isWorkerMissing = registrationResult.error.message.includes('(404)')\n\n    // Produce a custom error message when given a non-existing Service Worker url.\n    // Suggest developers to check their setup.\n    if (isWorkerMissing) {\n      const scopeUrl = new URL(options?.scope || '/', location.href)\n\n      throw new Error(\n        devUtils.formatMessage(`\\\nFailed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`),\n      )\n    }\n\n    // Fallback error message for any other registration errors.\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to register the Service Worker:\\n\\n%s',\n        registrationResult.error.message,\n      ),\n    )\n  }\n\n  return registrationResult.data\n}\n","/**\n * Returns an absolute Service Worker URL based on the given\n * relative URL (known during the registration).\n */\nexport function getAbsoluteWorkerUrl(workerUrl: string): string {\n  return new URL(workerUrl, location.href).href\n}\n","import { FindWorker } from '../../glossary'\n\n/**\n * Attempts to resolve a Service Worker instance from a given registration,\n * regardless of its state (active, installing, waiting).\n */\nexport function getWorkerByRegistration(\n  registration: ServiceWorkerRegistration,\n  absoluteWorkerUrl: string,\n  findWorker: FindWorker,\n): ServiceWorker | null {\n  const allStates = [\n    registration.active,\n    registration.installing,\n    registration.waiting,\n  ]\n  const relevantStates = allStates.filter((state): state is ServiceWorker => {\n    return state != null\n  })\n  const worker = relevantStates.find((worker) => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl)\n  })\n\n  return worker || null\n}\n","export type PromiseState = 'pending' | 'fulfilled' | 'rejected'\n\nexport type Executor<Value> = ConstructorParameters<typeof Promise<Value>>[0]\nexport type ResolveFunction<Value> = Parameters<Executor<Value>>[0]\nexport type RejectFunction<Reason> = Parameters<Executor<Reason>>[1]\n\nexport type DeferredPromiseExecutor<Input = never, Output = Input> = {\n  (resolve?: ResolveFunction<Input>, reject?: RejectFunction<any>): void\n\n  resolve: ResolveFunction<Input>\n  reject: RejectFunction<any>\n  result?: Output\n  state: PromiseState\n  rejectionReason?: unknown\n}\nexport function createDeferredExecutor<\n  Input = never,\n  Output = Input\n>(): DeferredPromiseExecutor<Input, Output> {\n  const executor = <DeferredPromiseExecutor<Input, Output>>((\n    resolve,\n    reject\n  ) => {\n    executor.state = 'pending'\n\n    executor.resolve = (data) => {\n      if (executor.state !== 'pending') {\n        return\n      }\n\n      executor.result = data as Output\n\n      const onFulfilled = <Value>(value: Value) => {\n        executor.state = 'fulfilled'\n        return value\n      }\n\n      return resolve(\n        data instanceof Promise ? data : Promise.resolve(data).then(onFulfilled)\n      )\n    }\n\n    executor.reject = (reason) => {\n      if (executor.state !== 'pending') {\n        return\n      }\n\n      queueMicrotask(() => {\n        executor.state = 'rejected'\n      })\n\n      return reject((executor.rejectionReason = reason))\n    }\n  })\n\n  return executor\n}\n","import {\n  type Executor,\n  type RejectFunction,\n  type ResolveFunction,\n  type DeferredPromiseExecutor,\n  createDeferredExecutor,\n} from './createDeferredExecutor'\n\nexport class DeferredPromise<Input, Output = Input> extends Promise<Input> {\n  #executor: DeferredPromiseExecutor\n\n  public resolve: ResolveFunction<Output>\n  public reject: RejectFunction<Output>\n\n  constructor(executor: Executor<Input> | null = null) {\n    const deferredExecutor = createDeferredExecutor()\n    super((originalResolve, originalReject) => {\n      deferredExecutor(originalResolve, originalReject)\n      executor?.(deferredExecutor.resolve, deferredExecutor.reject)\n    })\n\n    this.#executor = deferredExecutor\n    this.resolve = this.#executor.resolve\n    this.reject = this.#executor.reject\n  }\n\n  public get state() {\n    return this.#executor.state\n  }\n\n  public get rejectionReason() {\n    return this.#executor.rejectionReason\n  }\n\n  public then<ThenResult = Input, CatchResult = never>(\n    onFulfilled?: (value: Input) => ThenResult | PromiseLike<ThenResult>,\n    onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>\n  ) {\n    return this.#decorate(super.then(onFulfilled, onRejected))\n  }\n\n  public catch<CatchResult = never>(\n    onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>\n  ) {\n    return this.#decorate(super.catch(onRejected))\n  }\n\n  public finally(onfinally?: () => void | Promise<any>) {\n    return this.#decorate(super.finally(onfinally))\n  }\n\n  #decorate<ChildInput>(\n    promise: Promise<ChildInput>\n  ): DeferredPromise<ChildInput, Output> {\n    return Object.defineProperties(promise, {\n      resolve: { configurable: true, value: this.resolve },\n      reject: { configurable: true, value: this.reject },\n    }) as DeferredPromise<ChildInput, Output>\n  }\n}\n","import type { ServiceWorkerIncomingEventsMap } from '../../glossary'\nimport { devUtils } from '~/core/utils/internal/devUtils'\n\ninterface PrintStartMessageArgs {\n  quiet?: boolean\n  message?: string\n  workerUrl?: string\n  workerScope?: string\n  client?: ServiceWorkerIncomingEventsMap['MOCKING_ENABLED']['client']\n}\n\n/**\n * Prints a worker activation message in the browser's console.\n */\nexport function printStartMessage(args: PrintStartMessageArgs = {}) {\n  if (args.quiet) {\n    return\n  }\n\n  const message = args.message || 'Mocking enabled.'\n\n  console.groupCollapsed(\n    `%c${devUtils.formatMessage(message)}`,\n    'color:orangered;font-weight:bold;',\n  )\n  // eslint-disable-next-line no-console\n  console.log(\n    '%cDocumentation: %chttps://mswjs.io/docs',\n    'font-weight:bold',\n    'font-weight:normal',\n  )\n  // eslint-disable-next-line no-console\n  console.log('Found an issue? https://github.com/mswjs/msw/issues')\n\n  if (args.workerUrl) {\n    // eslint-disable-next-line no-console\n    console.log('Worker script URL:', args.workerUrl)\n  }\n\n  if (args.workerScope) {\n    // eslint-disable-next-line no-console\n    console.log('Worker scope:', args.workerScope)\n  }\n\n  if (args.client) {\n    // eslint-disable-next-line no-console\n    console.log('Client ID: %s (%s)', args.client.id, args.client.frameType)\n  }\n\n  console.groupEnd()\n}\n","import { DeferredPromise } from '@open-draft/deferred-promise'\nimport type { StartOptions, SetupWorkerInternalContext } from '../../glossary'\nimport { printStartMessage } from './printStartMessage'\n\n/**\n * Signals the worker to enable the interception of requests.\n */\nexport function enableMocking(\n  context: SetupWorkerInternalContext,\n  options: StartOptions,\n): Promise<boolean> {\n  const mockingEnabledPromise = new DeferredPromise<boolean>()\n\n  context.workerChannel.postMessage('MOCK_ACTIVATE')\n  context.workerChannel.once('MOCKING_ENABLED', async (event) => {\n    context.isMockingEnabled = true\n    const worker = await context.workerPromise\n\n    printStartMessage({\n      quiet: options.quiet,\n      workerScope: context.registration?.scope,\n      workerUrl: worker.scriptURL,\n      client: event.data.client,\n    })\n\n    mockingEnabledPromise.resolve(true)\n  })\n\n  return mockingEnabledPromise\n}\n","import type { ServiceWorkerIncomingRequest } from '../setupWorker/glossary'\n\ntype Input = Pick<ServiceWorkerIncomingRequest, 'method' | 'body'>\n\n/**\n * Ensures that an empty GET request body is always represented as `undefined`.\n */\nexport function pruneGetRequestBody(\n  request: Input,\n): ServiceWorkerIncomingRequest['body'] {\n  // Force HEAD/GET request body to always be empty.\n  // The worker reads any request's body as ArrayBuffer,\n  // and you cannot re-construct a GET/HEAD Request\n  // with an ArrayBuffer, even if empty. Also note that\n  // \"request.body\" is always undefined in the worker.\n  if (['HEAD', 'GET'].includes(request.method)) {\n    return undefined\n  }\n\n  return request.body\n}\n","import { pruneGetRequestBody } from './pruneGetRequestBody'\nimport type { ServiceWorkerIncomingRequest } from '../setupWorker/glossary'\n\n/**\n * Converts a given request received from the Service Worker\n * into a Fetch `Request` instance.\n */\nexport function deserializeRequest(\n  serializedRequest: ServiceWorkerIncomingRequest,\n): Request {\n  return new Request(serializedRequest.url, {\n    ...serializedRequest,\n    body: pruneGetRequestBody(serializedRequest),\n  })\n}\n","import { Emitter } from 'rettime'\nimport { StartOptions, SetupWorkerInternalContext } from '../glossary'\nimport { deserializeRequest } from '../../utils/deserializeRequest'\nimport { RequestHandler } from '~/core/handlers/RequestHandler'\nimport { handleRequest } from '~/core/utils/handleRequest'\nimport { RequiredDeep } from '~/core/typeUtils'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { toResponseInit } from '~/core/utils/toResponseInit'\nimport { isHandlerKind } from '~/core/utils/internal/isHandlerKind'\n\nexport const createRequestListener = (\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n): Emitter.ListenerType<typeof context.workerChannel, 'REQUEST'> => {\n  return async (event) => {\n    // Treat any incoming requests from the worker as passthrough\n    // if `worker.stop()` has been called for this client.\n    if (\n      !context.isMockingEnabled &&\n      context.workerStoppedAt &&\n      event.data.interceptedAt > context.workerStoppedAt\n    ) {\n      event.postMessage('PASSTHROUGH')\n      return\n    }\n\n    const requestId = event.data.id\n    const request = deserializeRequest(event.data)\n    const requestCloneForLogs = request.clone()\n\n    // Make this the first request clone before the\n    // request resolution pipeline even starts.\n    // Store the clone in cache so the first matching\n    // request handler would skip the cloning phase.\n    const requestClone = request.clone()\n    RequestHandler.cache.set(request, requestClone)\n\n    try {\n      await handleRequest(\n        request,\n        requestId,\n        context.getRequestHandlers().filter(isHandlerKind('RequestHandler')),\n        options,\n        context.emitter,\n        {\n          onPassthroughResponse() {\n            event.postMessage('PASSTHROUGH')\n          },\n          async onMockedResponse(response, { handler, parsedResult }) {\n            // Clone the mocked response so its body could be read\n            // to buffer to be sent to the worker and also in the\n            // \".log()\" method of the request handler.\n            const responseClone = response.clone()\n            const responseCloneForLogs = response.clone()\n            const responseInit = toResponseInit(response)\n\n            /**\n             * @note Safari doesn't support transferring a \"ReadableStream\".\n             * Check that the browser supports that before sending it to the worker.\n             */\n            if (context.supports.readableStreamTransfer) {\n              const responseStreamOrNull = response.body\n\n              event.postMessage(\n                'MOCK_RESPONSE',\n                {\n                  ...responseInit,\n                  body: responseStreamOrNull,\n                },\n                responseStreamOrNull ? [responseStreamOrNull] : undefined,\n              )\n            } else {\n              /**\n               * @note If we are here, this means the current environment doesn't\n               * support \"ReadableStream\" as transferable. In that case,\n               * attempt to read the non-empty response body as ArrayBuffer, if it's not empty.\n               * @see https://github.com/mswjs/msw/issues/1827\n               */\n              const responseBufferOrNull =\n                response.body === null\n                  ? null\n                  : await responseClone.arrayBuffer()\n\n              event.postMessage('MOCK_RESPONSE', {\n                ...responseInit,\n                body: responseBufferOrNull,\n              })\n            }\n\n            if (!options.quiet) {\n              context.emitter.once('response:mocked', () => {\n                handler.log({\n                  request: requestCloneForLogs,\n                  response: responseCloneForLogs,\n                  parsedResult,\n                })\n              })\n            }\n          },\n        },\n      )\n    } catch (error) {\n      if (error instanceof Error) {\n        devUtils.error(\n          `Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/http/mocking-responses/error-responses`,\n          request.method,\n          request.url,\n          error.stack ?? error,\n        )\n\n        // Treat all other exceptions in a request handler as unintended,\n        // alerting that there is a problem that needs fixing.\n        event.postMessage('MOCK_RESPONSE', {\n          status: 500,\n          statusText: 'Request Handler Error',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n          }),\n        })\n      }\n    }\n  }\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport type { SetupWorkerInternalContext } from '../setupWorker/glossary'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\n\n/**\n * Check whether the registered Service Worker has been\n * generated by the installed version of the library.\n * Prints a warning message if the worker scripts mismatch.\n */\nexport function checkWorkerIntegrity(\n  context: SetupWorkerInternalContext,\n): Promise<void> {\n  const integrityCheckPromise = new DeferredPromise<void>()\n\n  // Request the integrity checksum from the registered worker.\n  context.workerChannel.postMessage('INTEGRITY_CHECK_REQUEST')\n  context.workerChannel.once('INTEGRITY_CHECK_RESPONSE', (event) => {\n    const { checksum, packageVersion } = event.data\n\n    // Compare the response from the Service Worker and the\n    // global variable set during the build.\n\n    // The integrity is validated based on the worker script's checksum\n    // that's derived from its minified content during the build.\n    // The \"SERVICE_WORKER_CHECKSUM\" global variable is injected by the build.\n    if (checksum !== SERVICE_WORKER_CHECKSUM) {\n      devUtils.warn(\n        `The currently registered Service Worker has been generated by a different version of MSW (${packageVersion}) and may not be fully compatible with the installed version.\n\nIt's recommended you update your worker script by running this command:\n\n  \\u2022 npx msw init <PUBLIC_DIR>\n\nYou can also automate this process and make the worker script update automatically upon the library installations. Read more: https://mswjs.io/docs/cli/init.`,\n      )\n    }\n\n    integrityCheckPromise.resolve()\n  })\n\n  return integrityCheckPromise\n}\n","const encoder = new TextEncoder()\n\nexport function encodeBuffer(text: string): Uint8Array {\n  return encoder.encode(text)\n}\n\nexport function decodeBuffer(buffer: ArrayBuffer, encoding?: string): string {\n  const decoder = new TextDecoder(encoding)\n  return decoder.decode(buffer)\n}\n\n/**\n * Create an `ArrayBuffer` from the given `Uint8Array`.\n * Takes the byte offset into account to produce the right buffer\n * in the case when the buffer is bigger than the data view.\n */\nexport function toArrayBuffer(array: Uint8Array): ArrayBuffer {\n  return array.buffer.slice(\n    array.byteOffset,\n    array.byteOffset + array.byteLength\n  )\n}\n","import type { RequestController } from './RequestController'\n\nexport const IS_PATCHED_MODULE: unique symbol = Symbol('isPatchedModule')\n\n/**\n * @note Export `RequestController` as a type only.\n * It's never meant to be created in the userland.\n */\nexport type { RequestController }\n\nexport type RequestCredentials = 'omit' | 'include' | 'same-origin'\n\nexport type HttpRequestEventMap = {\n  request: [\n    args: {\n      request: Request\n      requestId: string\n      controller: RequestController\n    }\n  ]\n  response: [\n    args: {\n      response: Response\n      isMockedResponse: boolean\n      request: Request\n      requestId: string\n    }\n  ]\n  unhandledException: [\n    args: {\n      error: unknown\n      request: Request\n      requestId: string\n      controller: RequestController\n    }\n  ]\n}\n","/**\n * Returns a boolean indicating whether the given URL string\n * can be parsed into a `URL` instance.\n * A substitute for `URL.canParse()` for Node.js 18.\n */\nexport function canParseUrl(url: string): boolean {\n  try {\n    new URL(url)\n    return true\n  } catch (_error) {\n    return false\n  }\n}\n","/**\n * Returns the value behind the symbol with the given name.\n */\nexport function getValueBySymbol<T>(\n  symbolName: string,\n  source: object\n): T | undefined {\n  const ownSymbols = Object.getOwnPropertySymbols(source)\n\n  const symbol = ownSymbols.find((symbol) => {\n    return symbol.description === symbolName\n  })\n\n  if (symbol) {\n    return Reflect.get(source, symbol)\n  }\n\n  return\n}\n","import { canParseUrl } from './canParseUrl'\nimport { getValueBySymbol } from './getValueBySymbol'\n\nexport interface FetchResponseInit extends ResponseInit {\n  url?: string\n}\n\ninterface UndiciFetchInternalState {\n  aborted: boolean\n  rangeRequested: boolean\n  timingAllowPassed: boolean\n  requestIncludesCredentials: boolean\n  type: ResponseType\n  status: number\n  statusText: string\n  timingInfo: unknown\n  cacheState: unknown\n  headersList: Record<symbol, Map<string, unknown>>\n  urlList: Array<URL>\n  body?: {\n    stream: ReadableStream\n    source: unknown\n    length: number\n  }\n}\n\nexport class FetchResponse extends Response {\n  /**\n   * Response status codes for responses that cannot have body.\n   * @see https://fetch.spec.whatwg.org/#statuses\n   */\n  static readonly STATUS_CODES_WITHOUT_BODY = [101, 103, 204, 205, 304]\n\n  static readonly STATUS_CODES_WITH_REDIRECT = [301, 302, 303, 307, 308]\n\n  static isConfigurableStatusCode(status: number): boolean {\n    return status >= 200 && status <= 599\n  }\n\n  static isRedirectResponse(status: number): boolean {\n    return FetchResponse.STATUS_CODES_WITH_REDIRECT.includes(status)\n  }\n\n  /**\n   * Returns a boolean indicating whether the given response status\n   * code represents a response that can have a body.\n   */\n  static isResponseWithBody(status: number): boolean {\n    return !FetchResponse.STATUS_CODES_WITHOUT_BODY.includes(status)\n  }\n\n  static setUrl(url: string | undefined, response: Response): void {\n    if (!url || url === 'about:' || !canParseUrl(url)) {\n      return\n    }\n\n    const state = getValueBySymbol<UndiciFetchInternalState>('state', response)\n\n    if (state) {\n      // In Undici, push the URL to the internal list of URLs.\n      // This will respect the `response.url` getter logic correctly.\n      state.urlList.push(new URL(url))\n    } else {\n      // In other libraries, redefine the `url` property directly.\n      Object.defineProperty(response, 'url', {\n        value: url,\n        enumerable: true,\n        configurable: true,\n        writable: false,\n      })\n    }\n  }\n\n  /**\n   * Parses the given raw HTTP headers into a Fetch API `Headers` instance.\n   */\n  static parseRawHeaders(rawHeaders: Array<string>): Headers {\n    const headers = new Headers()\n    for (let line = 0; line < rawHeaders.length; line += 2) {\n      headers.append(rawHeaders[line], rawHeaders[line + 1])\n    }\n    return headers\n  }\n\n  constructor(body?: BodyInit | null, init: FetchResponseInit = {}) {\n    const status = init.status ?? 200\n    const safeStatus = FetchResponse.isConfigurableStatusCode(status)\n      ? status\n      : 200\n    const finalBody = FetchResponse.isResponseWithBody(status) ? body : null\n\n    super(finalBody, {\n      status: safeStatus,\n      statusText: init.statusText,\n      headers: init.headers,\n    })\n\n    if (status !== safeStatus) {\n      /**\n       * @note Undici keeps an internal \"Symbol(state)\" that holds\n       * the actual value of response status. Update that in Node.js.\n       */\n      const state = getValueBySymbol<UndiciFetchInternalState>('state', this)\n\n      if (state) {\n        state.status = status\n      } else {\n        Object.defineProperty(this, 'status', {\n          value: status,\n          enumerable: true,\n          configurable: true,\n          writable: false,\n        })\n      }\n    }\n\n    FetchResponse.setUrl(init.url, this)\n  }\n}\n","const kRawRequest = Symbol('kRawRequest')\n\n/**\n * Returns a raw request instance associated with this request.\n *\n * @example\n * interceptor.on('request', ({ request }) => {\n *   const rawRequest = getRawRequest(request)\n *\n *   if (rawRequest instanceof http.ClientRequest) {\n *     console.log(rawRequest.rawHeaders)\n *   }\n * })\n */\nexport function getRawRequest(request: Request): unknown | undefined {\n  return Reflect.get(request, kRawRequest)\n}\n\nexport function setRawRequest(request: Request, rawRequest: unknown): void {\n  Reflect.set(request, kRawRequest, rawRequest)\n}\n","var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/index.ts\nimport { isNodeProcess } from \"is-node-process\";\nimport { format } from \"outvariant\";\n\n// src/colors.ts\nvar colors_exports = {};\n__export(colors_exports, {\n  blue: () => blue,\n  gray: () => gray,\n  green: () => green,\n  red: () => red,\n  yellow: () => yellow\n});\nfunction yellow(text) {\n  return `\\x1B[33m${text}\\x1B[0m`;\n}\nfunction blue(text) {\n  return `\\x1B[34m${text}\\x1B[0m`;\n}\nfunction gray(text) {\n  return `\\x1B[90m${text}\\x1B[0m`;\n}\nfunction red(text) {\n  return `\\x1B[31m${text}\\x1B[0m`;\n}\nfunction green(text) {\n  return `\\x1B[32m${text}\\x1B[0m`;\n}\n\n// src/index.ts\nvar IS_NODE = isNodeProcess();\nvar Logger = class {\n  constructor(name) {\n    this.name = name;\n    this.prefix = `[${this.name}]`;\n    const LOGGER_NAME = getVariable(\"DEBUG\");\n    const LOGGER_LEVEL = getVariable(\"LOG_LEVEL\");\n    const isLoggingEnabled = LOGGER_NAME === \"1\" || LOGGER_NAME === \"true\" || typeof LOGGER_NAME !== \"undefined\" && this.name.startsWith(LOGGER_NAME);\n    if (isLoggingEnabled) {\n      this.debug = isDefinedAndNotEquals(LOGGER_LEVEL, \"debug\") ? noop : this.debug;\n      this.info = isDefinedAndNotEquals(LOGGER_LEVEL, \"info\") ? noop : this.info;\n      this.success = isDefinedAndNotEquals(LOGGER_LEVEL, \"success\") ? noop : this.success;\n      this.warning = isDefinedAndNotEquals(LOGGER_LEVEL, \"warning\") ? noop : this.warning;\n      this.error = isDefinedAndNotEquals(LOGGER_LEVEL, \"error\") ? noop : this.error;\n    } else {\n      this.info = noop;\n      this.success = noop;\n      this.warning = noop;\n      this.error = noop;\n      this.only = noop;\n    }\n  }\n  prefix;\n  extend(domain) {\n    return new Logger(`${this.name}:${domain}`);\n  }\n  /**\n   * Print a debug message.\n   * @example\n   * logger.debug('no duplicates found, creating a document...')\n   */\n  debug(message, ...positionals) {\n    this.logEntry({\n      level: \"debug\",\n      message: gray(message),\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"gray\"\n      }\n    });\n  }\n  /**\n   * Print an info message.\n   * @example\n   * logger.info('start parsing...')\n   */\n  info(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"blue\"\n      }\n    });\n    const performance2 = new PerformanceEntry();\n    return (message2, ...positionals2) => {\n      performance2.measure();\n      this.logEntry({\n        level: \"info\",\n        message: `${message2} ${gray(`${performance2.deltaTime}ms`)}`,\n        positionals: positionals2,\n        prefix: this.prefix,\n        colors: {\n          prefix: \"blue\"\n        }\n      });\n    };\n  }\n  /**\n   * Print a success message.\n   * @example\n   * logger.success('successfully created document')\n   */\n  success(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: `\\u2714 ${this.prefix}`,\n      colors: {\n        timestamp: \"green\",\n        prefix: \"green\"\n      }\n    });\n  }\n  /**\n   * Print a warning.\n   * @example\n   * logger.warning('found legacy document format')\n   */\n  warning(message, ...positionals) {\n    this.logEntry({\n      level: \"warning\",\n      message,\n      positionals,\n      prefix: `\\u26A0 ${this.prefix}`,\n      colors: {\n        timestamp: \"yellow\",\n        prefix: \"yellow\"\n      }\n    });\n  }\n  /**\n   * Print an error message.\n   * @example\n   * logger.error('something went wrong')\n   */\n  error(message, ...positionals) {\n    this.logEntry({\n      level: \"error\",\n      message,\n      positionals,\n      prefix: `\\u2716 ${this.prefix}`,\n      colors: {\n        timestamp: \"red\",\n        prefix: \"red\"\n      }\n    });\n  }\n  /**\n   * Execute the given callback only when the logging is enabled.\n   * This is skipped in its entirety and has no runtime cost otherwise.\n   * This executes regardless of the log level.\n   * @example\n   * logger.only(() => {\n   *   logger.info('additional info')\n   * })\n   */\n  only(callback) {\n    callback();\n  }\n  createEntry(level, message) {\n    return {\n      timestamp: /* @__PURE__ */ new Date(),\n      level,\n      message\n    };\n  }\n  logEntry(args) {\n    const {\n      level,\n      message,\n      prefix,\n      colors: customColors,\n      positionals = []\n    } = args;\n    const entry = this.createEntry(level, message);\n    const timestampColor = customColors?.timestamp || \"gray\";\n    const prefixColor = customColors?.prefix || \"gray\";\n    const colorize = {\n      timestamp: colors_exports[timestampColor],\n      prefix: colors_exports[prefixColor]\n    };\n    const write = this.getWriter(level);\n    write(\n      [colorize.timestamp(this.formatTimestamp(entry.timestamp))].concat(prefix != null ? colorize.prefix(prefix) : []).concat(serializeInput(message)).join(\" \"),\n      ...positionals.map(serializeInput)\n    );\n  }\n  formatTimestamp(timestamp) {\n    return `${timestamp.toLocaleTimeString(\n      \"en-GB\"\n    )}:${timestamp.getMilliseconds()}`;\n  }\n  getWriter(level) {\n    switch (level) {\n      case \"debug\":\n      case \"success\":\n      case \"info\": {\n        return log;\n      }\n      case \"warning\": {\n        return warn;\n      }\n      case \"error\": {\n        return error;\n      }\n    }\n  }\n};\nvar PerformanceEntry = class {\n  startTime;\n  endTime;\n  deltaTime;\n  constructor() {\n    this.startTime = performance.now();\n  }\n  measure() {\n    this.endTime = performance.now();\n    const deltaTime = this.endTime - this.startTime;\n    this.deltaTime = deltaTime.toFixed(2);\n  }\n};\nvar noop = () => void 0;\nfunction log(message, ...positionals) {\n  if (IS_NODE) {\n    process.stdout.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.log(message, ...positionals);\n}\nfunction warn(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.warn(message, ...positionals);\n}\nfunction error(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.error(message, ...positionals);\n}\nfunction getVariable(variableName) {\n  if (IS_NODE) {\n    return process.env[variableName];\n  }\n  return globalThis[variableName]?.toString();\n}\nfunction isDefinedAndNotEquals(value, expected) {\n  return value !== void 0 && value !== expected;\n}\nfunction serializeInput(message) {\n  if (typeof message === \"undefined\") {\n    return \"undefined\";\n  }\n  if (message === null) {\n    return \"null\";\n  }\n  if (typeof message === \"string\") {\n    return message;\n  }\n  if (typeof message === \"object\") {\n    return JSON.stringify(message);\n  }\n  return message.toString();\n}\nexport {\n  Logger\n};\n","import type { Emitter } from './Emitter'\n\nexport class MemoryLeakError extends Error {\n  constructor(\n    public readonly emitter: Emitter<any>,\n    public readonly type: string | number | symbol,\n    public readonly count: number\n  ) {\n    super(\n      `Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`\n    )\n    this.name = 'MaxListenersExceededWarning'\n  }\n}\n","import { MemoryLeakError } from './MemoryLeakError'\n\nexport type EventMap = {\n  [eventName: string]: Array<unknown>\n}\n\nexport type InternalEventNames = 'newListener' | 'removeListener'\n\nexport type InternalListener<Events extends EventMap> = Listener<\n  [eventName: keyof Events, listener: Listener<Array<unknown>>]\n>\n\nexport type Listener<Data extends Array<unknown>> = (...data: Data) => void\n\n/**\n * Node.js-compatible implementation of `EventEmitter`.\n *\n * @example\n * const emitter = new Emitter<{ hello: [string] }>()\n * emitter.on('hello', (name) => console.log(name))\n * emitter.emit('hello', 'John')\n */\nexport class Emitter<Events extends EventMap> {\n  private events: Map<keyof Events, Array<Listener<any>>>\n  private maxListeners: number\n  private hasWarnedAboutPotentialMemoryLeak: boolean\n\n  static defaultMaxListeners = 10\n\n  static listenerCount<Events extends EventMap>(\n    emitter: Emitter<EventMap>,\n    eventName: keyof Events\n  ): number {\n    return emitter.listenerCount<any>(eventName)\n  }\n\n  constructor() {\n    this.events = new Map()\n    this.maxListeners = Emitter.defaultMaxListeners\n    this.hasWarnedAboutPotentialMemoryLeak = false\n  }\n\n  private _emitInternalEvent(\n    internalEventName: InternalEventNames,\n    eventName: keyof Events,\n    listener: Listener<Array<unknown>>\n  ): void {\n    this.emit(\n      internalEventName,\n      // Anything to make TypeScript happy.\n      ...([eventName, listener] as Events['newListener'] &\n        Events['removeListener'])\n    )\n  }\n\n  private _getListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Array<unknown>>> {\n    // Always return a copy of the listeners array\n    // so they are fixed at the time of the \"_getListeners\" call.\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || []\n  }\n\n  private _removeListener<EventName extends keyof Events>(\n    listeners: Array<Listener<Events[EventName]>>,\n    listener: Listener<Events[EventName]>\n  ): Array<Listener<Events[EventName]>> {\n    const index = listeners.indexOf(listener)\n\n    if (index > -1) {\n      listeners.splice(index, 1)\n    }\n\n    return []\n  }\n\n  private _wrapOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): Listener<Events[EventName]> {\n    const onceListener = (...data: Events[keyof Events]) => {\n      this.removeListener(eventName, onceListener)\n\n      /**\n       * @note Return the result of the original listener.\n       * This way this wrapped preserves listeners that are async.\n       */\n      return listener.apply(this, data)\n    }\n\n    // Inherit the name of the original listener.\n    Object.defineProperty(onceListener, 'name', { value: listener.name })\n\n    return onceListener\n  }\n\n  public setMaxListeners(maxListeners: number): this {\n    this.maxListeners = maxListeners\n    return this\n  }\n\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n  public getMaxListeners(): number {\n    return this.maxListeners\n  }\n\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n  public eventNames(): Array<keyof Events> {\n    return Array.from(this.events.keys())\n  }\n\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n  public emit<EventName extends keyof Events>(\n    eventName: EventName,\n    ...data: Events[EventName]\n  ): boolean {\n    const listeners = this._getListeners(eventName)\n    listeners.forEach((listener) => {\n      listener.apply(this, data)\n    })\n\n    return listeners.length > 0\n  }\n\n  public addListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public addListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public addListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: InternalListener<Events> | Listener<Events[any]>\n  ): this {\n    // Emit the `newListener` event before adding the listener.\n    this._emitInternalEvent('newListener', eventName, listener)\n\n    const nextListeners = this._getListeners(eventName).concat(listener)\n    this.events.set(eventName, nextListeners)\n\n    if (\n      this.maxListeners > 0 &&\n      this.listenerCount(eventName) > this.maxListeners &&\n      !this.hasWarnedAboutPotentialMemoryLeak\n    ) {\n      this.hasWarnedAboutPotentialMemoryLeak = true\n\n      const memoryLeakWarning = new MemoryLeakError(\n        this,\n        eventName,\n        this.listenerCount(eventName)\n      )\n      console.warn(memoryLeakWarning)\n    }\n\n    return this\n  }\n\n  public on(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: 'removeListener' | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(eventName, listener)\n  }\n\n  public once(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: InternalEventNames | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public prependListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners)\n      this.events.set(eventName, nextListeners)\n    } else {\n      this.events.set(eventName, listeners.concat(listener))\n    }\n\n    return this\n  }\n\n  public prependOnceListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependOnceListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.prependListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public removeListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public removeListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public removeListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener)\n      this.events.set(eventName, listeners)\n\n      // Emit the `removeListener` event after removing the listener.\n      this._emitInternalEvent('removeListener', eventName, listener)\n    }\n\n    return this\n  }\n\n  public off(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public off<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n  public off(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.removeListener(eventName, listener)\n  }\n\n  public removeAllListeners(eventName?: InternalEventNames): this\n  public removeAllListeners<EventName extends keyof Events>(\n    eventName?: EventName\n  ): this\n  public removeAllListeners(\n    eventName?: InternalEventNames | keyof Events\n  ): this {\n    if (eventName) {\n      this.events.delete(eventName)\n    } else {\n      this.events.clear()\n    }\n\n    return this\n  }\n\n  public listeners(eventName: InternalEventNames): Array<Listener<any>>\n  public listeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>>\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n  public listeners(eventName: InternalEventNames | keyof Events) {\n    return Array.from(this._getListeners(eventName))\n  }\n\n  public listenerCount(eventName: InternalEventNames): number\n  public listenerCount<EventName extends keyof Events>(\n    eventName: EventName\n  ): number\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n  public listenerCount(eventName: InternalEventNames | keyof Events): number {\n    return this._getListeners(eventName).length\n  }\n\n  public rawListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>> {\n    return this.listeners(eventName)\n  }\n}\n","import { Logger } from '@open-draft/logger'\nimport { Emitter, Listener } from 'strict-event-emitter'\n\nexport type InterceptorEventMap = Record<string, any>\nexport type InterceptorSubscription = () => void\n\n/**\n * Request header name to detect when a single request\n * is being handled by nested interceptors (XHR -> ClientRequest).\n * Obscure by design to prevent collisions with user-defined headers.\n * Ideally, come up with the Interceptor-level mechanism for this.\n * @see https://github.com/mswjs/interceptors/issues/378\n */\nexport const INTERNAL_REQUEST_ID_HEADER_NAME =\n  'x-interceptors-internal-request-id'\n\nexport function getGlobalSymbol<V>(symbol: Symbol): V | undefined {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || undefined\n  )\n}\n\nfunction setGlobalSymbol(symbol: Symbol, value: any): void {\n  // @ts-ignore\n  globalThis[symbol] = value\n}\n\nexport function deleteGlobalSymbol(symbol: Symbol): void {\n  // @ts-ignore\n  delete globalThis[symbol]\n}\n\nexport enum InterceptorReadyState {\n  INACTIVE = 'INACTIVE',\n  APPLYING = 'APPLYING',\n  APPLIED = 'APPLIED',\n  DISPOSING = 'DISPOSING',\n  DISPOSED = 'DISPOSED',\n}\n\nexport type ExtractEventNames<Events extends Record<string, any>> =\n  Events extends Record<infer EventName, any> ? EventName : never\n\nexport class Interceptor<Events extends InterceptorEventMap> {\n  protected emitter: Emitter<Events>\n  protected subscriptions: Array<InterceptorSubscription>\n  protected logger: Logger\n\n  public readyState: InterceptorReadyState\n\n  constructor(private readonly symbol: symbol) {\n    this.readyState = InterceptorReadyState.INACTIVE\n\n    this.emitter = new Emitter()\n    this.subscriptions = []\n    this.logger = new Logger(symbol.description!)\n\n    // Do not limit the maximum number of listeners\n    // so not to limit the maximum amount of parallel events emitted.\n    this.emitter.setMaxListeners(0)\n\n    this.logger.info('constructing the interceptor...')\n  }\n\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  protected checkEnvironment(): boolean {\n    return true\n  }\n\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  public apply(): void {\n    const logger = this.logger.extend('apply')\n    logger.info('applying the interceptor...')\n\n    if (this.readyState === InterceptorReadyState.APPLIED) {\n      logger.info('intercepted already applied!')\n      return\n    }\n\n    const shouldApply = this.checkEnvironment()\n\n    if (!shouldApply) {\n      logger.info('the interceptor cannot be applied in this environment!')\n      return\n    }\n\n    this.readyState = InterceptorReadyState.APPLYING\n\n    // Whenever applying a new interceptor, check if it hasn't been applied already.\n    // This enables to apply the same interceptor multiple times, for example from a different\n    // interceptor, only proxying events but keeping the stubs in a single place.\n    const runningInstance = this.getInstance()\n\n    if (runningInstance) {\n      logger.info('found a running instance, reusing...')\n\n      // Proxy any listeners you set on this instance to the running instance.\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event)\n\n        // Add listeners to the running instance so they appear\n        // at the top of the event listeners list and are executed first.\n        runningInstance.emitter.addListener(event, listener)\n\n        // Ensure that once this interceptor instance is disposed,\n        // it removes all listeners it has appended to the running interceptor instance.\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener)\n          logger.info('removed proxied \"%s\" listener!', event)\n        })\n\n        return this\n      }\n\n      this.readyState = InterceptorReadyState.APPLIED\n\n      return\n    }\n\n    logger.info('no running instance found, setting up a new instance...')\n\n    // Setup the interceptor.\n    this.setup()\n\n    // Store the newly applied interceptor instance globally.\n    this.setInstance()\n\n    this.readyState = InterceptorReadyState.APPLIED\n  }\n\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  protected setup(): void {}\n\n  /**\n   * Listen to the interceptor's public events.\n   */\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    const logger = this.logger.extend('on')\n\n    if (\n      this.readyState === InterceptorReadyState.DISPOSING ||\n      this.readyState === InterceptorReadyState.DISPOSED\n    ) {\n      logger.info('cannot listen to events, already disposed!')\n      return this\n    }\n\n    logger.info('adding \"%s\" event listener:', event, listener)\n\n    this.emitter.on(event, listener)\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.once(event, listener)\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.off(event, listener)\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName\n  ): this {\n    this.emitter.removeAllListeners(event)\n    return this\n  }\n\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  public dispose(): void {\n    const logger = this.logger.extend('dispose')\n\n    if (this.readyState === InterceptorReadyState.DISPOSED) {\n      logger.info('cannot dispose, already disposed!')\n      return\n    }\n\n    logger.info('disposing the interceptor...')\n    this.readyState = InterceptorReadyState.DISPOSING\n\n    if (!this.getInstance()) {\n      logger.info('no interceptors running, skipping dispose...')\n      return\n    }\n\n    // Delete the global symbol as soon as possible,\n    // indicating that the interceptor is no longer running.\n    this.clearInstance()\n\n    logger.info('global symbol deleted:', getGlobalSymbol(this.symbol))\n\n    if (this.subscriptions.length > 0) {\n      logger.info('disposing of %d subscriptions...', this.subscriptions.length)\n\n      for (const dispose of this.subscriptions) {\n        dispose()\n      }\n\n      this.subscriptions = []\n\n      logger.info('disposed of all subscriptions!', this.subscriptions.length)\n    }\n\n    this.emitter.removeAllListeners()\n    logger.info('destroyed the listener!')\n\n    this.readyState = InterceptorReadyState.DISPOSED\n  }\n\n  private getInstance(): this | undefined {\n    const instance = getGlobalSymbol<this>(this.symbol)\n    this.logger.info('retrieved global instance:', instance?.constructor?.name)\n    return instance\n  }\n\n  private setInstance(): void {\n    setGlobalSymbol(this.symbol, this)\n    this.logger.info('set global instance!', this.symbol.description)\n  }\n\n  private clearInstance(): void {\n    deleteGlobalSymbol(this.symbol)\n    this.logger.info('cleared global instance!', this.symbol.description)\n  }\n}\n","/**\n * Generate a random ID string to represent a request.\n * @example\n * createRequestId()\n * // \"f774b6c9c600f\"\n */\nexport function createRequestId(): string {\n  return Math.random().toString(16).slice(2)\n}\n","import { EventMap, Listener } from 'strict-event-emitter'\nimport { Interceptor, ExtractEventNames } from './Interceptor'\n\nexport interface BatchInterceptorOptions<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> {\n  name: string\n  interceptors: InterceptorList\n}\n\nexport type ExtractEventMapType<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> = InterceptorList extends ReadonlyArray<infer InterceptorType>\n  ? InterceptorType extends Interceptor<infer EventMap>\n    ? EventMap\n    : never\n  : never\n\n/**\n * A batch interceptor that exposes a single interface\n * to apply and operate with multiple interceptors at once.\n */\nexport class BatchInterceptor<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>,\n  Events extends EventMap = ExtractEventMapType<InterceptorList>\n> extends Interceptor<Events> {\n  static symbol: symbol\n\n  private interceptors: InterceptorList\n\n  constructor(options: BatchInterceptorOptions<InterceptorList>) {\n    BatchInterceptor.symbol = Symbol(options.name)\n    super(BatchInterceptor.symbol)\n    this.interceptors = options.interceptors\n  }\n\n  protected setup() {\n    const logger = this.logger.extend('setup')\n\n    logger.info('applying all %d interceptors...', this.interceptors.length)\n\n    for (const interceptor of this.interceptors) {\n      logger.info('applying \"%s\" interceptor...', interceptor.constructor.name)\n      interceptor.apply()\n\n      logger.info('adding interceptor dispose subscription')\n      this.subscriptions.push(() => interceptor.dispose())\n    }\n  }\n\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    // Instead of adding a listener to the batch interceptor,\n    // propagate the listener to each of the individual interceptors.\n    for (const interceptor of this.interceptors) {\n      interceptor.on(event, listener)\n    }\n\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.once(event, listener)\n    }\n\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.off(event, listener)\n    }\n\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName | undefined\n  ): this {\n    for (const interceptors of this.interceptors) {\n      interceptors.removeAllListeners(event)\n    }\n\n    return this\n  }\n}\n","/**\n * Removes query parameters and hashes from a given URL.\n */\nexport function getCleanUrl(url: URL, isAbsolute: boolean = true): string {\n  return [isAbsolute && url.origin, url.pathname].filter(Boolean).join('')\n}\n","import { FetchResponse } from '@mswjs/interceptors'\nimport type { Emitter } from 'rettime'\nimport type { SetupWorkerInternalContext } from '../glossary'\nimport { deserializeRequest } from '../../utils/deserializeRequest'\n\nexport function createResponseListener(\n  context: SetupWorkerInternalContext,\n): Emitter.ListenerType<typeof context.workerChannel, 'RESPONSE'> {\n  return (event) => {\n    const responseMessage = event.data\n    const request = deserializeRequest(responseMessage.request)\n\n    /**\n     * CORS requests with `mode: \"no-cors\"` result in \"opaque\" responses.\n     * That kind of responses cannot be manipulated in JavaScript due\n     * to the security considerations.\n     * @see https://fetch.spec.whatwg.org/#concept-filtered-response-opaque\n     * @see https://github.com/mswjs/msw/issues/529\n     */\n    if (responseMessage.response.type?.includes('opaque')) {\n      return\n    }\n\n    const response =\n      responseMessage.response.status === 0\n        ? Response.error()\n        : new FetchResponse(\n            /**\n             * Responses may be streams here, but when we create a response object\n             * with null-body status codes, like 204, 205, 304 Response will\n             * throw when passed a non-null body, so ensure it's null here\n             * for those codes\n             */\n            FetchResponse.isResponseWithBody(responseMessage.response.status)\n              ? responseMessage.response.body\n              : null,\n            {\n              ...responseMessage,\n              /**\n               * Set response URL if it's not set already.\n               * @see https://github.com/mswjs/msw/issues/2030\n               * @see https://developer.mozilla.org/en-US/docs/Web/API/Response/url\n               */\n              url: request.url,\n            },\n          )\n\n    context.emitter.emit(\n      responseMessage.isMockedResponse ? 'response:mocked' : 'response:bypass',\n      {\n        requestId: responseMessage.request.id,\n        request,\n        response,\n      },\n    )\n  }\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport { StartOptions } from '../../glossary'\n\nexport function validateWorkerScope(\n  registration: ServiceWorkerRegistration,\n  options?: StartOptions,\n): void {\n  if (!options?.quiet && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(\n      `\\\nCannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.\\\n`,\n    )\n  }\n}\n","import { invariant } from 'outvariant'\nimport { isNodeProcess } from 'is-node-process'\nimport type {\n  SetupWorkerInternalContext,\n  StartReturnType,\n  StartOptions,\n  SetupWorker,\n} from './glossary'\nimport { RequestHandler } from '~/core/handlers/RequestHandler'\nimport { DEFAULT_START_OPTIONS } from './start/utils/prepareStartHandler'\nimport { createStartHandler } from './start/createStartHandler'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { SetupApi } from '~/core/SetupApi'\nimport { mergeRight } from '~/core/utils/internal/mergeRight'\nimport type { LifeCycleEventsMap } from '~/core/sharedOptions'\nimport type { WebSocketHandler } from '~/core/handlers/WebSocketHandler'\nimport { supportsReadableStreamTransfer } from '../utils/supportsReadableStreamTransfer'\nimport { webSocketInterceptor } from '~/core/ws/webSocketInterceptor'\nimport { handleWebSocketEvent } from '~/core/ws/handleWebSocketEvent'\nimport { attachWebSocketLogger } from '~/core/ws/utils/attachWebSocketLogger'\nimport { WorkerChannel } from '../utils/workerChannel'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { createFallbackRequestListener } from './start/createFallbackRequestListener'\nimport { printStartMessage } from './start/utils/printStartMessage'\nimport { printStopMessage } from './stop/utils/printStopMessage'\n\nexport class SetupWorkerApi\n  extends SetupApi<LifeCycleEventsMap>\n  implements SetupWorker\n{\n  private context: SetupWorkerInternalContext\n\n  constructor(...handlers: Array<RequestHandler | WebSocketHandler>) {\n    super(...handlers)\n\n    invariant(\n      !isNodeProcess(),\n      devUtils.formatMessage(\n        'Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.',\n      ),\n    )\n\n    this.context = this.createWorkerContext()\n  }\n\n  private createWorkerContext(): SetupWorkerInternalContext {\n    const workerPromise = new DeferredPromise<ServiceWorker>()\n\n    return {\n      // Mocking is not considered enabled until the worker\n      // signals back the successful activation event.\n      isMockingEnabled: false,\n      startOptions: null as any,\n      workerPromise,\n      registration: undefined,\n      getRequestHandlers: () => {\n        return this.handlersController.currentHandlers()\n      },\n      emitter: this.emitter,\n      workerChannel: new WorkerChannel({\n        worker: workerPromise,\n      }),\n      supports: {\n        serviceWorkerApi:\n          'serviceWorker' in navigator && location.protocol !== 'file:',\n        readableStreamTransfer: supportsReadableStreamTransfer(),\n      },\n    }\n  }\n\n  public async start(options: StartOptions = {}): StartReturnType {\n    if ('waitUntilReady' in options) {\n      devUtils.warn(\n        'The \"waitUntilReady\" option has been deprecated. Please remove it from this \"worker.start()\" call. Follow the recommended Browser integration (https://mswjs.io/docs/integrations/browser) to eliminate any race conditions between the Service Worker registration and any requests made by your application on initial render.',\n      )\n    }\n\n    // Warn the developer on multiple \"worker.start()\" calls.\n    // While this will not affect the worker in any way,\n    // it likely indicates an issue with the developer's code.\n    if (this.context.isMockingEnabled) {\n      devUtils.warn(\n        `Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`,\n      )\n      return this.context.registration\n    }\n\n    this.context.workerStoppedAt = undefined\n\n    this.context.startOptions = mergeRight(\n      DEFAULT_START_OPTIONS,\n      options,\n    ) as SetupWorkerInternalContext['startOptions']\n\n    // Enable the WebSocket interception.\n    handleWebSocketEvent({\n      getUnhandledRequestStrategy: () => {\n        return this.context.startOptions.onUnhandledRequest\n      },\n      getHandlers: () => {\n        return this.handlersController.currentHandlers()\n      },\n      onMockedConnection: (connection) => {\n        if (!this.context.startOptions.quiet) {\n          // Attach the logger for mocked connections since\n          // those won't be visible in the browser's devtools.\n          attachWebSocketLogger(connection)\n        }\n      },\n      onPassthroughConnection() {},\n    })\n    webSocketInterceptor.apply()\n\n    this.subscriptions.push(() => {\n      webSocketInterceptor.dispose()\n    })\n\n    // Use a fallback interception algorithm in the environments\n    // where the Service Worker API isn't supported.\n    if (!this.context.supports.serviceWorkerApi) {\n      const fallbackInterceptor = createFallbackRequestListener(\n        this.context,\n        this.context.startOptions,\n      )\n\n      this.subscriptions.push(() => {\n        fallbackInterceptor.dispose()\n      })\n\n      this.context.isMockingEnabled = true\n\n      printStartMessage({\n        message: 'Mocking enabled (fallback mode).',\n        quiet: this.context.startOptions.quiet,\n      })\n\n      return undefined\n    }\n\n    const startHandler = createStartHandler(this.context)\n    const registration = await startHandler(this.context.startOptions, options)\n\n    this.context.isMockingEnabled = true\n\n    return registration\n  }\n\n  public stop(): void {\n    super.dispose()\n\n    if (!this.context.isMockingEnabled) {\n      devUtils.warn(\n        'Found a redundant \"worker.stop()\" call. Notice that stopping the worker after it has already been stopped has no effect. Consider removing this \"worker.stop()\" call.',\n      )\n      return\n    }\n\n    this.context.isMockingEnabled = false\n    this.context.workerStoppedAt = Date.now()\n    this.context.emitter.removeAllListeners()\n\n    if (this.context.supports.serviceWorkerApi) {\n      this.context.workerChannel.removeAllListeners('RESPONSE')\n      window.clearInterval(this.context.keepAliveInterval)\n    }\n\n    // Post the internal stop message on the window\n    // to let any logic know when the worker has stopped.\n    // E.g. the WebSocket client manager needs this to know\n    // when to clear its in-memory clients list.\n    window.postMessage({ type: 'msw/worker:stop' })\n\n    printStopMessage({\n      quiet: this.context.startOptions?.quiet,\n    })\n  }\n}\n\n/**\n * Sets up a requests interception in the browser with the given request handlers.\n * @param {RequestHandler[]} handlers List of request handlers.\n *\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker()` API reference}\n */\nexport function setupWorker(\n  ...handlers: Array<RequestHandler | WebSocketHandler>\n): SetupWorker {\n  return new SetupWorkerApi(...handlers)\n}\n","/**\n * Returns a boolean indicating whether the current browser\n * supports `ReadableStream` as a `Transferable` when posting\n * messages.\n */\nexport function supportsReadableStreamTransfer() {\n  try {\n    const stream = new ReadableStream({\n      start: (controller) => controller.close(),\n    })\n    const message = new MessageChannel()\n    message.port1.postMessage(stream, [stream])\n    return true\n  } catch {\n    return false\n  }\n}\n","export type DefaultEventMap = {\n  [eventType: string]: TypedEvent<any, any>\n}\n\nexport interface TypedEvent<\n  DataType = void,\n  ReturnType = any,\n  EventType extends string = string,\n> extends Omit<MessageEvent<DataType>, 'type'> {\n  type: EventType\n}\n\nconst kDefaultPrevented = Symbol('kDefaultPrevented')\nconst kPropagationStopped = Symbol('kPropagationStopped')\nconst kImmediatePropagationStopped = Symbol('kImmediatePropagationStopped')\n\nexport class TypedEvent<\n    DataType = void,\n    ReturnType = any,\n    EventType extends string = string,\n  >\n  extends MessageEvent<DataType>\n  implements TypedEvent<DataType, ReturnType, EventType>\n{\n  /**\n   * @note Keep a placeholder property with the return type\n   * because the type must be set somewhere in order to be\n   * correctly associated and inferred from the event.\n   */\n  #returnType: ReturnType;\n\n  [kDefaultPrevented]: boolean;\n  [kPropagationStopped]?: Emitter<any>;\n  [kImmediatePropagationStopped]?: boolean\n\n  constructor(\n    ...args: [DataType] extends [void]\n      ? [type: EventType]\n      : [type: EventType, init: { data: DataType }]\n  ) {\n    super(args[0], args[1])\n    this[kDefaultPrevented] = false\n  }\n\n  get defaultPrevented(): boolean {\n    return this[kDefaultPrevented]\n  }\n\n  public preventDefault(): void {\n    super.preventDefault()\n    this[kDefaultPrevented] = true\n  }\n\n  public stopImmediatePropagation(): void {\n    /**\n     * @note Despite `.stopPropagation()` and `.stopImmediatePropagation()` being defined\n     * in Node.js, they do nothing. It is safe to re-define them.\n     */\n    super.stopImmediatePropagation()\n    this[kImmediatePropagationStopped] = true\n  }\n}\n\n/**\n * Brands a TypedEvent or its subclass while preserving its (narrower) type.\n */\ntype Brand<Event extends TypedEvent, EventType extends string> = Event & {\n  type: EventType\n}\n\ntype InferEventMap<Target extends Emitter<any>> = Target extends Emitter<\n  infer EventMap\n>\n  ? EventMap\n  : never\n\ntype InternalListenersMap<\n  Target extends Emitter<any>,\n  EventMap extends DefaultEventMap = InferEventMap<Target>,\n  EventType extends string = keyof EventMap & string,\n> = Record<\n  keyof EventMap,\n  Array<Emitter.ListenerType<Target, EventType, EventMap>>\n>\n\nexport type TypedListenerOptions = {\n  once?: boolean\n  signal?: AbortSignal\n}\n\nconst kListenerOptions = Symbol('kListenerOptions')\n\nexport namespace Emitter {\n  /**\n   * Returns an appropriate `Event` type for the given event type.\n   *\n   * @example\n   * const emitter = new Emitter<{ greeting: TypedEvent<string> }>()\n   * type GreetingEvent = Emitter.InferEventType<typeof emitter, 'greeting'>\n   * // TypedEvent<string>\n   */\n  export type EventType<\n    Target extends Emitter<any>,\n    EventType extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > = Brand<EventMap[EventType], EventType>\n\n  export type EventDataType<\n    Target extends Emitter<any>,\n    EventType extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > = EventMap[EventType] extends TypedEvent<infer DataType> ? DataType : never\n\n  /**\n   * Returns the listener type for the given event type.\n   *\n   * @example\n   * const emitter = new Emitter<{ getTotalPrice: TypedEvent<Cart, number> }>()\n   * type Listener = Emitter.ListenerType<typeof emitter, 'getTotalPrice'>\n   * // (event: TypedEvent<Cart>) => number\n   */\n  export type ListenerType<\n    Target extends Emitter<any>,\n    Type extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > = (\n    event: Emitter.EventType<Target, Type, EventMap>,\n  ) => Emitter.ListenerReturnType<Target, Type, EventMap> extends [void]\n    ? void\n    : Emitter.ListenerReturnType<Target, Type, EventMap>\n\n  /**\n   * Returns the return type of the listener for the given event type.\n   *\n   * @example\n   * const emitter = new Emitter<{ getTotalPrice: TypedEvent<Cart, number> }>()\n   * type ListenerReturnType = Emitter.InferListenerReturnType<typeof emitter, 'getTotalPrice'>\n   * // number\n   */\n  export type ListenerReturnType<\n    Target extends Emitter<any>,\n    EventType extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > = EventMap[EventType] extends TypedEvent<unknown, infer ReturnType>\n    ? ReturnType\n    : never\n}\n\nexport class Emitter<EventMap extends DefaultEventMap> {\n  #listeners: InternalListenersMap<typeof this, EventMap>\n\n  constructor() {\n    this.#listeners = {} as InternalListenersMap<typeof this, EventMap>\n  }\n\n  /**\n   * Adds a listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  public on<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options?: TypedListenerOptions,\n  ): typeof this {\n    return this.#addListener(type, listener, options)\n  }\n\n  /**\n   * Adds a one-time listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  public once<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options?: Omit<TypedListenerOptions, 'once'>,\n  ): typeof this {\n    return this.on(type, listener, { ...(options || {}), once: true })\n  }\n\n  /**\n   * Prepends a listener for the given event type.\n   *\n   * @returns {AbortController} An `AbortController` that can be used to remove the listener.\n   */\n  public earlyOn<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options?: TypedListenerOptions,\n  ): typeof this {\n    return this.#addListener(type, listener, options, 'prepend')\n  }\n\n  /**\n   * Prepends a one-time listener for the given event type.\n   */\n  public earlyOnce<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options?: Omit<TypedListenerOptions, 'once'>,\n  ): typeof this {\n    return this.earlyOn(type, listener, { ...(options || {}), once: true })\n  }\n\n  /**\n   * Emits the given typed event.\n   *\n   * @returns {boolean} Returns `true` if the event had any listeners, `false` otherwise.\n   */\n  public emit<EventType extends keyof EventMap & string>(\n    event: Brand<EventMap[EventType], EventType>,\n  ): boolean {\n    if (this.listenerCount(event.type) === 0) {\n      return false\n    }\n\n    const proxiedEvent = this.#proxyEvent(event)\n\n    for (const listener of this.#listeners[event.type]) {\n      if (\n        proxiedEvent.event[kPropagationStopped] != null &&\n        proxiedEvent.event[kPropagationStopped] !== this\n      ) {\n        return false\n      }\n\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break\n      }\n\n      this.#callListener(proxiedEvent.event, listener)\n    }\n\n    proxiedEvent.revoke()\n\n    return true\n  }\n\n  /**\n   * Emits the given typed event and returns a promise that resolves\n   * when all the listeners for that event have settled.\n   *\n   * @returns {Promise<Array<Emitter.ListenerReturnType>>} A promise that resolves\n   * with the return values of all listeners.\n   */\n  public async emitAsPromise<EventType extends keyof EventMap & string>(\n    event: Brand<EventMap[EventType], EventType>,\n  ): Promise<\n    Array<Emitter.ListenerReturnType<typeof this, EventType, EventMap>>\n  > {\n    if (this.listenerCount(event.type) === 0) {\n      return []\n    }\n\n    const pendingListeners: Array<\n      Promise<Emitter.ListenerReturnType<typeof this, EventType, EventMap>>\n    > = []\n\n    const proxiedEvent = this.#proxyEvent(event)\n\n    for (const listener of this.#listeners[event.type]) {\n      if (\n        proxiedEvent.event[kPropagationStopped] != null &&\n        proxiedEvent.event[kPropagationStopped] !== this\n      ) {\n        return []\n      }\n\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break\n      }\n\n      pendingListeners.push(\n        // Awaiting individual listeners guarantees their call order.\n        await Promise.resolve(this.#callListener(proxiedEvent.event, listener)),\n      )\n    }\n\n    proxiedEvent.revoke()\n\n    return Promise.allSettled(pendingListeners).then((results) => {\n      return results.map((result) =>\n        result.status === 'fulfilled' ? result.value : result.reason,\n      )\n    })\n  }\n\n  /**\n   * Emits the given event and returns a generator that yields\n   * the result of each listener in the order of their registration.\n   * This way, you stop exhausting the listeners once you get the expected value.\n   */\n  public *emitAsGenerator<EventType extends keyof EventMap & string>(\n    event: Brand<EventMap[EventType], EventType>,\n  ): Generator<Emitter.ListenerReturnType<typeof this, EventType, EventMap>> {\n    if (this.listenerCount(event.type) === 0) {\n      return\n    }\n\n    const proxiedEvent = this.#proxyEvent(event)\n\n    for (const listener of this.#listeners[event.type]) {\n      if (\n        proxiedEvent.event[kPropagationStopped] != null &&\n        proxiedEvent.event[kPropagationStopped] !== this\n      ) {\n        return\n      }\n\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break\n      }\n\n      yield this.#callListener(proxiedEvent.event, listener)\n    }\n\n    proxiedEvent.revoke()\n  }\n\n  /**\n   * Removes a listener for the given event type.\n   */\n  public removeListener<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n  ): void {\n    if (this.listenerCount(type) === 0) {\n      return\n    }\n\n    const nextListeners: Array<\n      Emitter.ListenerType<typeof this, EventType, EventMap>\n    > = []\n\n    for (const existingListener of this.#listeners[type]) {\n      if (existingListener !== listener) {\n        nextListeners.push(existingListener)\n      }\n    }\n\n    this.#listeners[type] = nextListeners\n  }\n\n  /**\n   * Removes all listeners for the given event type.\n   * If no event type is provided, removes all existing listeners.\n   */\n  public removeAllListeners<EventType extends keyof EventMap & string>(\n    type?: EventType,\n  ): void {\n    if (type == null) {\n      this.#listeners = {} as InternalListenersMap<typeof this>\n      return\n    }\n\n    this.#listeners[type] = []\n  }\n\n  /**\n   * Returns the list of listeners for the given event type.\n   * If no even type is provided, returns all listeners.\n   */\n  public listeners<EventType extends keyof EventMap & string>(\n    type?: EventType,\n  ): Array<Emitter.ListenerType<typeof this, EventType, EventMap>> {\n    if (type == null) {\n      return Object.values(this.#listeners).flat()\n    }\n\n    return this.#listeners[type] || []\n  }\n\n  /**\n   * Returns the number of listeners for the given event type.\n   * If no even type is provided, returns the total number of listeners.\n   */\n  public listenerCount<EventType extends keyof EventMap & string>(\n    type?: EventType,\n  ): number {\n    return this.listeners(type).length\n  }\n\n  #addListener<EventType extends keyof EventMap & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap>,\n    options: TypedListenerOptions | undefined,\n    insertMode: 'append' | 'prepend' = 'append',\n  ): typeof this {\n    this.#listeners[type] ??= []\n\n    if (insertMode === 'prepend') {\n      this.#listeners[type].unshift(listener)\n    } else {\n      this.#listeners[type].push(listener)\n    }\n\n    if (options) {\n      Object.defineProperty(listener, kListenerOptions, {\n        value: options,\n        enumerable: false,\n        writable: false,\n      })\n\n      if (options.signal) {\n        options.signal.addEventListener(\n          'abort',\n          () => {\n            this.removeListener(type, listener)\n          },\n          { once: true },\n        )\n      }\n    }\n\n    return this\n  }\n\n  #proxyEvent<Event extends TypedEvent>(\n    event: Event,\n  ): { event: Event; revoke: () => void } {\n    const { stopPropagation } = event\n\n    event.stopPropagation = new Proxy(event.stopPropagation, {\n      apply: (target, thisArg, argArray) => {\n        event[kPropagationStopped] = this\n        return Reflect.apply(target, thisArg, argArray)\n      },\n    })\n\n    return {\n      event,\n      revoke() {\n        event.stopPropagation = stopPropagation\n      },\n    }\n  }\n\n  #callListener<EventType extends keyof EventMap & string>(\n    event: Event,\n    listener: Emitter.ListenerType<typeof this, EventType, EventMap> & {\n      [kListenerOptions]?: TypedListenerOptions\n    },\n  ) {\n    const returnValue = listener.call(this, event)\n\n    if (listener[kListenerOptions]?.once) {\n      this.removeListener(event.type, listener)\n    }\n\n    return returnValue\n  }\n}\n","import { Emitter, TypedEvent } from 'rettime'\nimport { isObject } from '~/core/utils/internal/isObject'\nimport type { StringifiedResponse } from '../setupWorker/glossary'\n\nexport interface WorkerChannelOptions {\n  worker: Promise<ServiceWorker>\n}\n\nexport type WorkerChannelEventMap = {\n  REQUEST: WorkerEvent<IncomingWorkerRequest>\n  RESPONSE: WorkerEvent<IncomingWorkerResponse>\n  MOCKING_ENABLED: WorkerEvent<{\n    client: {\n      id: string\n      frameType: string\n    }\n  }>\n  INTEGRITY_CHECK_RESPONSE: WorkerEvent<{\n    packageVersion: string\n    checksum: string\n  }>\n  KEEPALIVE_RESPONSE: TypedEvent<never>\n}\n\n/**\n * Request representation received from the worker message event.\n */\nexport interface IncomingWorkerRequest\n  extends Omit<\n    Request,\n    | 'text'\n    | 'body'\n    | 'json'\n    | 'blob'\n    | 'arrayBuffer'\n    | 'formData'\n    | 'clone'\n    | 'signal'\n    | 'isHistoryNavigation'\n    | 'isReloadNavigation'\n  > {\n  /**\n   * Unique ID of the request generated once the request is\n   * intercepted by the \"fetch\" event in the Service Worker.\n   */\n  id: string\n  interceptedAt: number\n  body?: ArrayBuffer | null\n}\n\ntype IncomingWorkerResponse = {\n  isMockedResponse: boolean\n  request: IncomingWorkerRequest\n  response: Pick<\n    Response,\n    'type' | 'ok' | 'status' | 'statusText' | 'body' | 'headers' | 'redirected'\n  >\n}\n\nexport type WorkerEventResponse = {\n  MOCK_RESPONSE: [\n    data: StringifiedResponse,\n    transfer?: [ReadableStream<Uint8Array>],\n  ]\n  PASSTHROUGH: []\n}\n\nexport class WorkerEvent<\n  DataType,\n  ReturnType = any,\n  EventType extends string = string,\n> extends TypedEvent<DataType, ReturnType, EventType> {\n  #workerEvent: MessageEvent\n\n  constructor(workerEvent: MessageEvent) {\n    const type = workerEvent.data.type as EventType\n    const data = workerEvent.data.payload as DataType\n\n    /**\n     * @note This is the only place we're mapping { type, payload }\n     * message structure of the worker. The client references the\n     * payload via `event.data`.\n     */\n    super(\n      // @ts-expect-error Troublesome `TypedEvent` extension.\n      type,\n      { data },\n    )\n    this.#workerEvent = workerEvent\n  }\n\n  get ports() {\n    return this.#workerEvent.ports\n  }\n\n  /**\n   * Reply directly to this event using its `MessagePort`.\n   */\n  public postMessage<Type extends keyof WorkerEventResponse>(\n    type: Type,\n    ...rest: WorkerEventResponse[Type]\n  ): void {\n    this.#workerEvent.ports[0].postMessage(\n      { type, data: rest[0] },\n      { transfer: rest[1] },\n    )\n  }\n}\n\n/**\n * Map of the events that can be sent to the Service Worker\n * from any execution context.\n */\ntype OutgoingWorkerEvents =\n  | 'MOCK_ACTIVATE'\n  | 'INTEGRITY_CHECK_REQUEST'\n  | 'KEEPALIVE_REQUEST'\n  | 'CLIENT_CLOSED'\n\nexport class WorkerChannel extends Emitter<WorkerChannelEventMap> {\n  constructor(protected readonly options: WorkerChannelOptions) {\n    super()\n\n    navigator.serviceWorker.addEventListener('message', async (event) => {\n      const worker = await this.options.worker\n\n      if (event.source != null && event.source !== worker) {\n        return\n      }\n\n      if (event.data && isObject(event.data) && 'type' in event.data) {\n        this.emit(new WorkerEvent<any, any, any>(event))\n      }\n    })\n  }\n\n  /**\n   * Send data to the Service Worker controlling this client.\n   * This triggers the `message` event listener on ServiceWorkerGlobalScope.\n   */\n  public postMessage(type: OutgoingWorkerEvents): void {\n    this.options.worker.then((worker) => {\n      worker.postMessage(type)\n    })\n  }\n}\n","import { invariant } from 'outvariant'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { InterceptorError } from './InterceptorError'\n\nconst kRequestHandled = Symbol('kRequestHandled')\nexport const kResponsePromise = Symbol('kResponsePromise')\n\nexport class RequestController {\n  /**\n   * Internal response promise.\n   * Available only for the library internals to grab the\n   * response instance provided by the developer.\n   * @note This promise cannot be rejected. It's either infinitely\n   * pending or resolved with whichever Response was passed to `respondWith()`.\n   */\n  [kResponsePromise]: DeferredPromise<\n    Response | Record<string, any> | undefined\n  >;\n\n  /**\n   * Internal flag indicating if this request has been handled.\n   * @note The response promise becomes \"fulfilled\" on the next tick.\n   */\n  [kRequestHandled]: boolean\n\n  constructor(private request: Request) {\n    this[kRequestHandled] = false\n    this[kResponsePromise] = new DeferredPromise()\n  }\n\n  /**\n   * Respond to this request with the given `Response` instance.\n   * @example\n   * controller.respondWith(new Response())\n   * controller.respondWith(Response.json({ id }))\n   * controller.respondWith(Response.error())\n   */\n  public respondWith(response: Response): void {\n    invariant.as(\n      InterceptorError,\n      !this[kRequestHandled],\n      'Failed to respond to the \"%s %s\" request: the \"request\" event has already been handled.',\n      this.request.method,\n      this.request.url\n    )\n\n    this[kRequestHandled] = true\n    this[kResponsePromise].resolve(response)\n\n    /**\n     * @note The request controller doesn't do anything\n     * apart from letting the interceptor await the response\n     * provided by the developer through the response promise.\n     * Each interceptor implements the actual respondWith/errorWith\n     * logic based on that interceptor's needs.\n     */\n  }\n\n  /**\n   * Error this request with the given reason.\n   *\n   * @example\n   * controller.errorWith()\n   * controller.errorWith(new Error('Oops!'))\n   * controller.errorWith({ message: 'Oops!'})\n   */\n  public errorWith(reason?: Error | Record<string, any>): void {\n    invariant.as(\n      InterceptorError,\n      !this[kRequestHandled],\n      'Failed to error the \"%s %s\" request: the \"request\" event has already been handled.',\n      this.request.method,\n      this.request.url\n    )\n\n    this[kRequestHandled] = true\n\n    /**\n     * @note Resolve the response promise, not reject.\n     * This helps us differentiate between unhandled exceptions\n     * and intended errors (\"errorWith\") while waiting for the response.\n     */\n    this[kResponsePromise].resolve(reason)\n  }\n}\n","export class InterceptorError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = 'InterceptorError'\n    Object.setPrototypeOf(this, InterceptorError.prototype)\n  }\n}\n","import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Emits an event on the given emitter but executes\n * the listeners sequentially. This accounts for asynchronous\n * listeners (e.g. those having \"sleep\" and handling the request).\n */\nexport async function emitAsync<\n  Events extends EventMap,\n  EventName extends keyof Events\n>(\n  emitter: Emitter<Events>,\n  eventName: EventName,\n  ...data: Events[EventName]\n): Promise<void> {\n  const listners = emitter.listeners(eventName)\n\n  if (listners.length === 0) {\n    return\n  }\n\n  for (const listener of listners) {\n    await listener.apply(emitter, data)\n  }\n}\n","import type { Emitter } from 'strict-event-emitter'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { until } from '@open-draft/until'\nimport type { HttpRequestEventMap } from '../glossary'\nimport { emitAsync } from './emitAsync'\nimport { kResponsePromise, RequestController } from '../RequestController'\nimport {\n  createServerErrorResponse,\n  isResponseError,\n  isResponseLike,\n  ResponseError,\n} from './responseUtils'\nimport { InterceptorError } from '../InterceptorError'\nimport { isNodeLikeError } from './isNodeLikeError'\nimport { isObject } from './isObject'\n\ninterface HandleRequestOptions {\n  requestId: string\n  request: Request\n  emitter: Emitter<HttpRequestEventMap>\n  controller: RequestController\n\n  /**\n   * Called when the request has been handled\n   * with the given `Response` instance.\n   */\n  onResponse: (response: Response) => void | Promise<void>\n\n  /**\n   * Called when the request has been handled\n   * with the given `Response.error()` instance.\n   */\n  onRequestError: (response: ResponseError) => void\n\n  /**\n   * Called when an unhandled error happens during the\n   * request handling. This is never a thrown error/response.\n   */\n  onError: (error: unknown) => void\n}\n\n/**\n * @returns {Promise<boolean>} Indicates whether the request has been handled.\n */\nexport async function handleRequest(\n  options: HandleRequestOptions\n): Promise<boolean> {\n  const handleResponse = async (\n    response: Response | Error | Record<string, any>\n  ) => {\n    if (response instanceof Error) {\n      options.onError(response)\n      return true\n    }\n\n    // Handle \"Response.error()\" instances.\n    if (isResponseError(response)) {\n      options.onRequestError(response)\n      return true\n    }\n\n    /**\n     * Handle normal responses or response-like objects.\n     * @note This must come before the arbitrary object check\n     * since Response instances are, in fact, objects.\n     */\n    if (isResponseLike(response)) {\n      await options.onResponse(response)\n      return true\n    }\n\n    // Handle arbitrary objects provided to `.errorWith(reason)`.\n    if (isObject(response)) {\n      options.onError(response)\n      return true\n    }\n\n    return false\n  }\n\n  const handleResponseError = async (error: unknown): Promise<boolean> => {\n    // Forward the special interceptor error instances\n    // to the developer. These must not be handled in any way.\n    if (error instanceof InterceptorError) {\n      throw result.error\n    }\n\n    // Support mocking Node.js-like errors.\n    if (isNodeLikeError(error)) {\n      options.onError(error)\n      return true\n    }\n\n    // Handle thrown responses.\n    if (error instanceof Response) {\n      return await handleResponse(error)\n    }\n\n    return false\n  }\n\n  // Add the last \"request\" listener to check if the request\n  // has been handled in any way. If it hasn't, resolve the\n  // response promise with undefined.\n  options.emitter.once('request', ({ requestId: pendingRequestId }) => {\n    if (pendingRequestId !== options.requestId) {\n      return\n    }\n\n    if (options.controller[kResponsePromise].state === 'pending') {\n      options.controller[kResponsePromise].resolve(undefined)\n    }\n  })\n\n  const requestAbortPromise = new DeferredPromise<void, unknown>()\n\n  /**\n   * @note `signal` is not always defined in React Native.\n   */\n  if (options.request.signal) {\n    if (options.request.signal.aborted) {\n      requestAbortPromise.reject(options.request.signal.reason)\n    } else {\n      options.request.signal.addEventListener(\n        'abort',\n        () => {\n          requestAbortPromise.reject(options.request.signal.reason)\n        },\n        { once: true }\n      )\n    }\n  }\n\n  const result = await until(async () => {\n    // Emit the \"request\" event and wait until all the listeners\n    // for that event are finished (e.g. async listeners awaited).\n    // By the end of this promise, the developer cannot affect the\n    // request anymore.\n    const requestListenersPromise = emitAsync(options.emitter, 'request', {\n      requestId: options.requestId,\n      request: options.request,\n      controller: options.controller,\n    })\n\n    await Promise.race([\n      // Short-circuit the request handling promise if the request gets aborted.\n      requestAbortPromise,\n      requestListenersPromise,\n      options.controller[kResponsePromise],\n    ])\n\n    // The response promise will settle immediately once\n    // the developer calls either \"respondWith\" or \"errorWith\".\n    return await options.controller[kResponsePromise]\n  })\n\n  // Handle the request being aborted while waiting for the request listeners.\n  if (requestAbortPromise.state === 'rejected') {\n    options.onError(requestAbortPromise.rejectionReason)\n    return true\n  }\n\n  if (result.error) {\n    // Handle the error during the request listener execution.\n    // These can be thrown responses or request errors.\n    if (await handleResponseError(result.error)) {\n      return true\n    }\n\n    // If the developer has added \"unhandledException\" listeners,\n    // allow them to handle the error. They can translate it to a\n    // mocked response, network error, or forward it as-is.\n    if (options.emitter.listenerCount('unhandledException') > 0) {\n      // Create a new request controller just for the unhandled exception case.\n      // This is needed because the original controller might have been already\n      // interacted with (e.g. \"respondWith\" or \"errorWith\" called on it).\n      const unhandledExceptionController = new RequestController(\n        options.request\n      )\n\n      await emitAsync(options.emitter, 'unhandledException', {\n        error: result.error,\n        request: options.request,\n        requestId: options.requestId,\n        controller: unhandledExceptionController,\n      }).then(() => {\n        // If all the \"unhandledException\" listeners have finished\n        // but have not handled the response in any way, preemptively\n        // resolve the pending response promise from the new controller.\n        // This prevents it from hanging forever.\n        if (\n          unhandledExceptionController[kResponsePromise].state === 'pending'\n        ) {\n          unhandledExceptionController[kResponsePromise].resolve(undefined)\n        }\n      })\n\n      const nextResult = await until(\n        () => unhandledExceptionController[kResponsePromise]\n      )\n\n      /**\n       * @note Handle the result of the unhandled controller\n       * in the same way as the original request controller.\n       * The exception here is that thrown errors within the\n       * \"unhandledException\" event do NOT result in another\n       * emit of the same event. They are forwarded as-is.\n       */\n      if (nextResult.error) {\n        return handleResponseError(nextResult.error)\n      }\n\n      if (nextResult.data) {\n        return handleResponse(nextResult.data)\n      }\n    }\n\n    // Otherwise, coerce unhandled exceptions to a 500 Internal Server Error response.\n    options.onResponse(createServerErrorResponse(result.error))\n    return true\n  }\n\n  /**\n   * Handle a mocked Response instance.\n   * @note That this can also be an Error in case\n   * the developer called \"errorWith\". This differentiates\n   * unhandled exceptions from intended errors.\n   */\n  if (result.data) {\n    return handleResponse(result.data)\n  }\n\n  // In all other cases, consider the request unhandled.\n  return false\n}\n","/**\n * Determines if a given value is an instance of object.\n */\nexport function isObject<T>(value: any, loose = false): value is T {\n  return loose\n    ? Object.prototype.toString.call(value).startsWith('[object ')\n    : Object.prototype.toString.call(value) === '[object Object]'\n}\n","/**\n * A function that validates if property access is possible on an object\n * without throwing. It returns `true` if the property access is possible\n * and `false` otherwise.\n *\n * Environments like miniflare will throw on property access on certain objects\n * like Request and Response, for unimplemented properties.\n */\nexport function isPropertyAccessible<Obj extends Record<string, any>>(\n  obj: Obj,\n  key: keyof Obj\n) {\n  try {\n    obj[key]\n    return true\n  } catch {\n    return false\n  }\n}\n","import { isObject } from './isObject'\nimport { isPropertyAccessible } from './isPropertyAccessible'\n\n/**\n * Creates a generic 500 Unhandled Exception response.\n */\nexport function createServerErrorResponse(body: unknown): Response {\n  return new Response(\n    JSON.stringify(\n      body instanceof Error\n        ? {\n            name: body.name,\n            message: body.message,\n            stack: body.stack,\n          }\n        : body\n    ),\n    {\n      status: 500,\n      statusText: 'Unhandled Exception',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    }\n  )\n}\n\nexport type ResponseError = Response & { type: 'error' }\n\n/**\n * Check if the given response is a `Response.error()`.\n *\n * @note Some environments, like Miniflare (Cloudflare) do not\n * implement the \"Response.type\" property and throw on its access.\n * Safely check if we can access \"type\" on \"Response\" before continuing.\n * @see https://github.com/mswjs/msw/issues/1834\n */\nexport function isResponseError(response: unknown): response is ResponseError {\n  return (\n    response != null &&\n    response instanceof Response &&\n    isPropertyAccessible(response, 'type') &&\n    response.type === 'error'\n  )\n}\n\n/**\n * Check if the given value is a `Response` or a Response-like object.\n * This is different from `value instanceof Response` because it supports\n * custom `Response` constructors, like the one when using Undici directly.\n */\nexport function isResponseLike(value: unknown): value is Response {\n  return (\n    isObject<Record<string, any>>(value, true) &&\n    isPropertyAccessible(value, 'status') &&\n    isPropertyAccessible(value, 'statusText') &&\n    isPropertyAccessible(value, 'bodyUsed')\n  )\n}\n","export function isNodeLikeError(\n  error: unknown\n): error is NodeJS.ErrnoException {\n  if (error == null) {\n    return false\n  }\n\n  if (!(error instanceof Error)) {\n    return false\n  }\n\n  return 'code' in error && 'errno' in error\n}\n","/**\n * Returns a boolean indicating whether the given global property\n * is defined and is configurable.\n */\nexport function hasConfigurableGlobal(propertyName: string): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(globalThis, propertyName)\n\n  // The property is not set at all.\n  if (typeof descriptor === 'undefined') {\n    return false\n  }\n\n  // The property is set to a getter that returns undefined.\n  if (\n    typeof descriptor.get === 'function' &&\n    typeof descriptor.get() === 'undefined'\n  ) {\n    return false\n  }\n\n  // The property is set to a value equal to undefined.\n  if (typeof descriptor.get === 'undefined' && descriptor.value == null) {\n    return false\n  }\n\n  if (typeof descriptor.set === 'undefined' && !descriptor.configurable) {\n    console.error(\n      `[MSW] Failed to apply interceptor: the global \\`${propertyName}\\` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.`\n    )\n    return false\n  }\n\n  return true\n}\n","import { invariant } from 'outvariant'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { HttpRequestEventMap, IS_PATCHED_MODULE } from '../../glossary'\nimport { Interceptor } from '../../Interceptor'\nimport { RequestController } from '../../RequestController'\nimport { emitAsync } from '../../utils/emitAsync'\nimport { handleRequest } from '../../utils/handleRequest'\nimport { canParseUrl } from '../../utils/canParseUrl'\nimport { createRequestId } from '../../createRequestId'\nimport { createNetworkError } from './utils/createNetworkError'\nimport { followFetchRedirect } from './utils/followRedirect'\nimport { decompressResponse } from './utils/decompression'\nimport { hasConfigurableGlobal } from '../../utils/hasConfigurableGlobal'\nimport { FetchResponse } from '../../utils/fetchUtils'\nimport { setRawRequest } from '../../getRawRequest'\n\nexport class FetchInterceptor extends Interceptor<HttpRequestEventMap> {\n  static symbol = Symbol('fetch')\n\n  constructor() {\n    super(FetchInterceptor.symbol)\n  }\n\n  protected checkEnvironment() {\n    return hasConfigurableGlobal('fetch')\n  }\n\n  protected async setup() {\n    const pureFetch = globalThis.fetch\n\n    invariant(\n      !(pureFetch as any)[IS_PATCHED_MODULE],\n      'Failed to patch the \"fetch\" module: already patched.'\n    )\n\n    globalThis.fetch = async (input, init) => {\n      const requestId = createRequestId()\n\n      /**\n       * @note Resolve potentially relative request URL\n       * against the present `location`. This is mainly\n       * for native `fetch` in JSDOM.\n       * @see https://github.com/mswjs/msw/issues/1625\n       */\n      const resolvedInput =\n        typeof input === 'string' &&\n        typeof location !== 'undefined' &&\n        !canParseUrl(input)\n          ? new URL(input, location.href)\n          : input\n\n      const request = new Request(resolvedInput, init)\n\n      /**\n       * @note Set the raw request only if a Request instance was provided to fetch.\n       */\n      if (input instanceof Request) {\n        setRawRequest(request, input)\n      }\n\n      const responsePromise = new DeferredPromise<Response>()\n      const controller = new RequestController(request)\n\n      this.logger.info('[%s] %s', request.method, request.url)\n      this.logger.info('awaiting for the mocked response...')\n\n      this.logger.info(\n        'emitting the \"request\" event for %s listener(s)...',\n        this.emitter.listenerCount('request')\n      )\n\n      const isRequestHandled = await handleRequest({\n        request,\n        requestId,\n        emitter: this.emitter,\n        controller,\n        onResponse: async (rawResponse) => {\n          this.logger.info('received mocked response!', {\n            rawResponse,\n          })\n\n          // Decompress the mocked response body, if applicable.\n          const decompressedStream = decompressResponse(rawResponse)\n          const response =\n            decompressedStream === null\n              ? rawResponse\n              : new FetchResponse(decompressedStream, rawResponse)\n\n          FetchResponse.setUrl(request.url, response)\n\n          /**\n           * Undici's handling of following redirect responses.\n           * Treat the \"manual\" redirect mode as a regular mocked response.\n           * This way, the client can manually follow the redirect it receives.\n           * @see https://github.com/nodejs/undici/blob/a6dac3149c505b58d2e6d068b97f4dc993da55f0/lib/web/fetch/index.js#L1173\n           */\n          if (FetchResponse.isRedirectResponse(response.status)) {\n            // Reject the request promise if its `redirect` is set to `error`\n            // and it receives a mocked redirect response.\n            if (request.redirect === 'error') {\n              responsePromise.reject(createNetworkError('unexpected redirect'))\n              return\n            }\n\n            if (request.redirect === 'follow') {\n              followFetchRedirect(request, response).then(\n                (response) => {\n                  responsePromise.resolve(response)\n                },\n                (reason) => {\n                  responsePromise.reject(reason)\n                }\n              )\n              return\n            }\n          }\n\n          if (this.emitter.listenerCount('response') > 0) {\n            this.logger.info('emitting the \"response\" event...')\n\n            // Await the response listeners to finish before resolving\n            // the response promise. This ensures all your logic finishes\n            // before the interceptor resolves the pending response.\n            await emitAsync(this.emitter, 'response', {\n              // Clone the mocked response for the \"response\" event listener.\n              // This way, the listener can read the response and not lock its body\n              // for the actual fetch consumer.\n              response: response.clone(),\n              isMockedResponse: true,\n              request,\n              requestId,\n            })\n          }\n\n          responsePromise.resolve(response)\n        },\n        onRequestError: (response) => {\n          this.logger.info('request has errored!', { response })\n          responsePromise.reject(createNetworkError(response))\n        },\n        onError: (error) => {\n          this.logger.info('request has been aborted!', { error })\n          responsePromise.reject(error)\n        },\n      })\n\n      if (isRequestHandled) {\n        this.logger.info('request has been handled, returning mock promise...')\n        return responsePromise\n      }\n\n      this.logger.info(\n        'no mocked response received, performing request as-is...'\n      )\n\n      /**\n       * @note Clone the request instance right before performing it.\n       * This preserves any modifications made to the intercepted request\n       * in the \"request\" listener. This also allows the user to read the\n       * request body in the \"response\" listener (otherwise \"unusable\").\n       */\n      const requestCloneForResponseEvent = request.clone()\n\n      return pureFetch(request).then(async (response) => {\n        this.logger.info('original fetch performed', response)\n\n        if (this.emitter.listenerCount('response') > 0) {\n          this.logger.info('emitting the \"response\" event...')\n\n          const responseClone = response.clone()\n\n          await emitAsync(this.emitter, 'response', {\n            response: responseClone,\n            isMockedResponse: false,\n            request: requestCloneForResponseEvent,\n            requestId,\n          })\n        }\n\n        return response\n      })\n    }\n\n    Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n        value: undefined,\n      })\n\n      globalThis.fetch = pureFetch\n\n      this.logger.info(\n        'restored native \"globalThis.fetch\"!',\n        globalThis.fetch.name\n      )\n    })\n  }\n}\n","export function createNetworkError(cause?: unknown) {\n  return Object.assign(new TypeError('Failed to fetch'), {\n    cause,\n  })\n}\n","import { createNetworkError } from './createNetworkError'\n\nconst REQUEST_BODY_HEADERS = [\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-type',\n  'content-length',\n]\n\nconst kRedirectCount = Symbol('kRedirectCount')\n\n/**\n * @see https://github.com/nodejs/undici/blob/a6dac3149c505b58d2e6d068b97f4dc993da55f0/lib/web/fetch/index.js#L1210\n */\nexport async function followFetchRedirect(\n  request: Request,\n  response: Response\n): Promise<Response> {\n  if (response.status !== 303 && request.body != null) {\n    return Promise.reject(createNetworkError())\n  }\n\n  const requestUrl = new URL(request.url)\n\n  let locationUrl: URL\n  try {\n    // If the location is a relative URL, use the request URL as the base URL.\n    locationUrl = new URL(response.headers.get('location')!, request.url) \n  } catch (error) {\n    return Promise.reject(createNetworkError(error))\n  }\n\n  if (\n    !(locationUrl.protocol === 'http:' || locationUrl.protocol === 'https:')\n  ) {\n    return Promise.reject(\n      createNetworkError('URL scheme must be a HTTP(S) scheme')\n    )\n  }\n\n  if (Reflect.get(request, kRedirectCount) > 20) {\n    return Promise.reject(createNetworkError('redirect count exceeded'))\n  }\n\n  Object.defineProperty(request, kRedirectCount, {\n    value: (Reflect.get(request, kRedirectCount) || 0) + 1,\n  })\n\n  if (\n    request.mode === 'cors' &&\n    (locationUrl.username || locationUrl.password) &&\n    !sameOrigin(requestUrl, locationUrl)\n  ) {\n    return Promise.reject(\n      createNetworkError('cross origin not allowed for request mode \"cors\"')\n    )\n  }\n\n  const requestInit: RequestInit = {}\n\n  if (\n    ([301, 302].includes(response.status) && request.method === 'POST') ||\n    (response.status === 303 && !['HEAD', 'GET'].includes(request.method))\n  ) {\n    requestInit.method = 'GET'\n    requestInit.body = null\n\n    REQUEST_BODY_HEADERS.forEach((headerName) => {\n      request.headers.delete(headerName)\n    })\n  }\n\n  if (!sameOrigin(requestUrl, locationUrl)) {\n    request.headers.delete('authorization')\n    request.headers.delete('proxy-authorization')\n    request.headers.delete('cookie')\n    request.headers.delete('host')\n  }\n\n  /**\n   * @note Undici \"safely\" extracts the request body.\n   * I suspect we cannot dispatch this request again\n   * since its body has been read and the stream is locked.\n   */\n\n  requestInit.headers = request.headers\n  return fetch(new Request(locationUrl, requestInit))\n}\n\n/**\n * @see https://github.com/nodejs/undici/blob/a6dac3149c505b58d2e6d068b97f4dc993da55f0/lib/web/fetch/util.js#L761\n */\nfunction sameOrigin(left: URL, right: URL): boolean {\n  if (left.origin === right.origin && left.origin === 'null') {\n    return true\n  }\n\n  if (\n    left.protocol === right.protocol &&\n    left.hostname === right.hostname &&\n    left.port === right.port\n  ) {\n    return true\n  }\n\n  return false\n}\n","export class BrotliDecompressionStream extends TransformStream {\n  constructor() {\n    console.warn(\n      '[Interceptors]: Brotli decompression of response streams is not supported in the browser'\n    )\n\n    super({\n      transform(chunk, controller) {\n        // Keep the stream as passthrough, it does nothing.\n        controller.enqueue(chunk)\n      },\n    })\n  }\n}\n","// Import from an internal alias that resolves to different modules\n// depending on the environment. This way, we can keep the fetch interceptor\n// intact while using different strategies for Brotli decompression.\nimport { BrotliDecompressionStream } from 'internal:brotli-decompress'\n\nclass PipelineStream extends TransformStream {\n  constructor(\n    transformStreams: Array<TransformStream>,\n    ...strategies: Array<QueuingStrategy>\n  ) {\n    super({}, ...strategies)\n\n    const readable = [super.readable as any, ...transformStreams].reduce(\n      (readable, transform) => readable.pipeThrough(transform)\n    )\n\n    Object.defineProperty(this, 'readable', {\n      get() {\n        return readable\n      },\n    })\n  }\n}\n\nexport function parseContentEncoding(contentEncoding: string): Array<string> {\n  return contentEncoding\n    .toLowerCase()\n    .split(',')\n    .map((coding) => coding.trim())\n}\n\nfunction createDecompressionStream(\n  contentEncoding: string\n): TransformStream | null {\n  if (contentEncoding === '') {\n    return null\n  }\n\n  const codings = parseContentEncoding(contentEncoding)\n\n  if (codings.length === 0) {\n    return null\n  }\n\n  const transformers = codings.reduceRight<Array<TransformStream>>(\n    (transformers, coding) => {\n      if (coding === 'gzip' || coding === 'x-gzip') {\n        return transformers.concat(new DecompressionStream('gzip'))\n      } else if (coding === 'deflate') {\n        return transformers.concat(new DecompressionStream('deflate'))\n      } else if (coding === 'br') {\n        return transformers.concat(new BrotliDecompressionStream())\n      } else {\n        transformers.length = 0\n      }\n\n      return transformers\n    },\n    []\n  )\n\n  return new PipelineStream(transformers)\n}\n\nexport function decompressResponse(\n  response: Response\n): ReadableStream<any> | null {\n  if (response.body === null) {\n    return null\n  }\n\n  const decompressionStream = createDecompressionStream(\n    response.headers.get('content-encoding') || ''\n  )\n\n  if (!decompressionStream) {\n    return null\n  }\n\n  // Use `pipeTo` and return the decompression stream's readable\n  // instead of `pipeThrough` because that will lock the original\n  // response stream, making it unusable as the input to Response.\n  response.body.pipeTo(decompressionStream.writable)\n  return decompressionStream.readable\n}\n","import { invariant } from 'outvariant'\nimport { Emitter } from 'strict-event-emitter'\nimport { HttpRequestEventMap, IS_PATCHED_MODULE } from '../../glossary'\nimport { Interceptor } from '../../Interceptor'\nimport { createXMLHttpRequestProxy } from './XMLHttpRequestProxy'\nimport { hasConfigurableGlobal } from '../../utils/hasConfigurableGlobal'\n\nexport type XMLHttpRequestEmitter = Emitter<HttpRequestEventMap>\n\nexport class XMLHttpRequestInterceptor extends Interceptor<HttpRequestEventMap> {\n  static interceptorSymbol = Symbol('xhr')\n\n  constructor() {\n    super(XMLHttpRequestInterceptor.interceptorSymbol)\n  }\n\n  protected checkEnvironment() {\n    return hasConfigurableGlobal('XMLHttpRequest')\n  }\n\n  protected setup() {\n    const logger = this.logger.extend('setup')\n\n    logger.info('patching \"XMLHttpRequest\" module...')\n\n    const PureXMLHttpRequest = globalThis.XMLHttpRequest\n\n    invariant(\n      !(PureXMLHttpRequest as any)[IS_PATCHED_MODULE],\n      'Failed to patch the \"XMLHttpRequest\" module: already patched.'\n    )\n\n    globalThis.XMLHttpRequest = createXMLHttpRequestProxy({\n      emitter: this.emitter,\n      logger: this.logger,\n    })\n\n    logger.info(\n      'native \"XMLHttpRequest\" module patched!',\n      globalThis.XMLHttpRequest.name\n    )\n\n    Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n        value: undefined,\n      })\n\n      globalThis.XMLHttpRequest = PureXMLHttpRequest\n      logger.info(\n        'native \"XMLHttpRequest\" module restored!',\n        globalThis.XMLHttpRequest.name\n      )\n    })\n  }\n}\n","import { invariant } from 'outvariant'\nimport { isNodeProcess } from 'is-node-process'\nimport type { Logger } from '@open-draft/logger'\nimport { concatArrayBuffer } from './utils/concatArrayBuffer'\nimport { createEvent } from './utils/createEvent'\nimport {\n  decodeBuffer,\n  encodeBuffer,\n  toArrayBuffer,\n} from '../../utils/bufferUtils'\nimport { createProxy } from '../../utils/createProxy'\nimport { isDomParserSupportedType } from './utils/isDomParserSupportedType'\nimport { parseJson } from '../../utils/parseJson'\nimport { createResponse } from './utils/createResponse'\nimport { INTERNAL_REQUEST_ID_HEADER_NAME } from '../../Interceptor'\nimport { createRequestId } from '../../createRequestId'\nimport { getBodyByteLength } from './utils/getBodyByteLength'\nimport { setRawRequest } from '../../getRawRequest'\n\nconst kIsRequestHandled = Symbol('kIsRequestHandled')\nconst IS_NODE = isNodeProcess()\nconst kFetchRequest = Symbol('kFetchRequest')\n\n/**\n * An `XMLHttpRequest` instance controller that allows us\n * to handle any given request instance (e.g. responding to it).\n */\nexport class XMLHttpRequestController {\n  public request: XMLHttpRequest\n  public requestId: string\n  public onRequest?: (\n    this: XMLHttpRequestController,\n    args: {\n      request: Request\n      requestId: string\n    }\n  ) => Promise<void>\n  public onResponse?: (\n    this: XMLHttpRequestController,\n    args: {\n      response: Response\n      isMockedResponse: boolean\n      request: Request\n      requestId: string\n    }\n  ) => void;\n\n  [kIsRequestHandled]: boolean;\n  [kFetchRequest]?: Request\n  private method: string = 'GET'\n  private url: URL = null as any\n  private requestHeaders: Headers\n  private responseBuffer: Uint8Array\n  private events: Map<keyof XMLHttpRequestEventTargetEventMap, Array<Function>>\n  private uploadEvents: Map<\n    keyof XMLHttpRequestEventTargetEventMap,\n    Array<Function>\n  >\n\n  constructor(readonly initialRequest: XMLHttpRequest, public logger: Logger) {\n    this[kIsRequestHandled] = false\n\n    this.events = new Map()\n    this.uploadEvents = new Map()\n    this.requestId = createRequestId()\n    this.requestHeaders = new Headers()\n    this.responseBuffer = new Uint8Array()\n\n    this.request = createProxy(initialRequest, {\n      setProperty: ([propertyName, nextValue], invoke) => {\n        switch (propertyName) {\n          case 'ontimeout': {\n            const eventName = propertyName.slice(\n              2\n            ) as keyof XMLHttpRequestEventTargetEventMap\n\n            /**\n             * @note Proxy callbacks to event listeners because JSDOM has trouble\n             * translating these properties to callbacks. It seemed to be operating\n             * on events exclusively.\n             */\n            this.request.addEventListener(eventName, nextValue as any)\n\n            return invoke()\n          }\n\n          default: {\n            return invoke()\n          }\n        }\n      },\n      methodCall: ([methodName, args], invoke) => {\n        switch (methodName) {\n          case 'open': {\n            const [method, url] = args as [string, string | undefined]\n\n            if (typeof url === 'undefined') {\n              this.method = 'GET'\n              this.url = toAbsoluteUrl(method)\n            } else {\n              this.method = method\n              this.url = toAbsoluteUrl(url)\n            }\n\n            this.logger = this.logger.extend(`${this.method} ${this.url.href}`)\n            this.logger.info('open', this.method, this.url.href)\n\n            return invoke()\n          }\n\n          case 'addEventListener': {\n            const [eventName, listener] = args as [\n              keyof XMLHttpRequestEventTargetEventMap,\n              Function\n            ]\n\n            this.registerEvent(eventName, listener)\n            this.logger.info('addEventListener', eventName, listener)\n\n            return invoke()\n          }\n\n          case 'setRequestHeader': {\n            const [name, value] = args as [string, string]\n            this.requestHeaders.set(name, value)\n\n            this.logger.info('setRequestHeader', name, value)\n\n            return invoke()\n          }\n\n          case 'send': {\n            const [body] = args as [\n              body?: XMLHttpRequestBodyInit | Document | null\n            ]\n\n            this.request.addEventListener('load', () => {\n              if (typeof this.onResponse !== 'undefined') {\n                // Create a Fetch API Response representation of whichever\n                // response this XMLHttpRequest received. Note those may\n                // be either a mocked and the original response.\n                const fetchResponse = createResponse(\n                  this.request,\n                  /**\n                   * The `response` property is the right way to read\n                   * the ambiguous response body, as the request's \"responseType\" may differ.\n                   * @see https://xhr.spec.whatwg.org/#the-response-attribute\n                   */\n                  this.request.response\n                )\n\n                // Notify the consumer about the response.\n                this.onResponse.call(this, {\n                  response: fetchResponse,\n                  isMockedResponse: this[kIsRequestHandled],\n                  request: fetchRequest,\n                  requestId: this.requestId!,\n                })\n              }\n            })\n\n            const requestBody =\n              typeof body === 'string' ? encodeBuffer(body) : body\n\n            // Delegate request handling to the consumer.\n            const fetchRequest = this.toFetchApiRequest(requestBody)\n            this[kFetchRequest] = fetchRequest.clone()\n\n            const onceRequestSettled =\n              this.onRequest?.call(this, {\n                request: fetchRequest,\n                requestId: this.requestId!,\n              }) || Promise.resolve()\n\n            onceRequestSettled.finally(() => {\n              // If the consumer didn't handle the request (called `.respondWith()`) perform it as-is.\n              if (!this[kIsRequestHandled]) {\n                this.logger.info(\n                  'request callback settled but request has not been handled (readystate %d), performing as-is...',\n                  this.request.readyState\n                )\n\n                /**\n                 * @note Set the intercepted request ID on the original request in Node.js\n                 * so that if it triggers any other interceptors, they don't attempt\n                 * to process it once again.\n                 *\n                 * For instance, XMLHttpRequest is often implemented via \"http.ClientRequest\"\n                 * and we don't want for both XHR and ClientRequest interceptors to\n                 * handle the same request at the same time (e.g. emit the \"response\" event twice).\n                 */\n                if (IS_NODE) {\n                  this.request.setRequestHeader(\n                    INTERNAL_REQUEST_ID_HEADER_NAME,\n                    this.requestId!\n                  )\n                }\n\n                return invoke()\n              }\n            })\n\n            break\n          }\n\n          default: {\n            return invoke()\n          }\n        }\n      },\n    })\n\n    /**\n     * Proxy the `.upload` property to gather the event listeners/callbacks.\n     */\n    define(\n      this.request,\n      'upload',\n      createProxy(this.request.upload, {\n        setProperty: ([propertyName, nextValue], invoke) => {\n          switch (propertyName) {\n            case 'onloadstart':\n            case 'onprogress':\n            case 'onaboart':\n            case 'onerror':\n            case 'onload':\n            case 'ontimeout':\n            case 'onloadend': {\n              const eventName = propertyName.slice(\n                2\n              ) as keyof XMLHttpRequestEventTargetEventMap\n\n              this.registerUploadEvent(eventName, nextValue as Function)\n            }\n          }\n\n          return invoke()\n        },\n        methodCall: ([methodName, args], invoke) => {\n          switch (methodName) {\n            case 'addEventListener': {\n              const [eventName, listener] = args as [\n                keyof XMLHttpRequestEventTargetEventMap,\n                Function\n              ]\n              this.registerUploadEvent(eventName, listener)\n              this.logger.info('upload.addEventListener', eventName, listener)\n\n              return invoke()\n            }\n          }\n        },\n      })\n    )\n  }\n\n  private registerEvent(\n    eventName: keyof XMLHttpRequestEventTargetEventMap,\n    listener: Function\n  ): void {\n    const prevEvents = this.events.get(eventName) || []\n    const nextEvents = prevEvents.concat(listener)\n    this.events.set(eventName, nextEvents)\n\n    this.logger.info('registered event \"%s\"', eventName, listener)\n  }\n\n  private registerUploadEvent(\n    eventName: keyof XMLHttpRequestEventTargetEventMap,\n    listener: Function\n  ): void {\n    const prevEvents = this.uploadEvents.get(eventName) || []\n    const nextEvents = prevEvents.concat(listener)\n    this.uploadEvents.set(eventName, nextEvents)\n\n    this.logger.info('registered upload event \"%s\"', eventName, listener)\n  }\n\n  /**\n   * Responds to the current request with the given\n   * Fetch API `Response` instance.\n   */\n  public async respondWith(response: Response): Promise<void> {\n    /**\n     * @note Since `XMLHttpRequestController` delegates the handling of the responses\n     * to the \"load\" event listener that doesn't distinguish between the mocked and original\n     * responses, mark the request that had a mocked response with a corresponding symbol.\n     *\n     * Mark this request as having a mocked response immediately since\n     * calculating request/response total body length is asynchronous.\n     */\n    this[kIsRequestHandled] = true\n\n    /**\n     * Dispatch request upload events for requests with a body.\n     * @see https://github.com/mswjs/interceptors/issues/573\n     */\n    if (this[kFetchRequest]) {\n      const totalRequestBodyLength = await getBodyByteLength(\n        this[kFetchRequest]\n      )\n\n      this.trigger('loadstart', this.request.upload, {\n        loaded: 0,\n        total: totalRequestBodyLength,\n      })\n      this.trigger('progress', this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength,\n      })\n      this.trigger('load', this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength,\n      })\n      this.trigger('loadend', this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength,\n      })\n    }\n\n    this.logger.info(\n      'responding with a mocked response: %d %s',\n      response.status,\n      response.statusText\n    )\n\n    define(this.request, 'status', response.status)\n    define(this.request, 'statusText', response.statusText)\n    define(this.request, 'responseURL', this.url.href)\n\n    this.request.getResponseHeader = new Proxy(this.request.getResponseHeader, {\n      apply: (_, __, args: [name: string]) => {\n        this.logger.info('getResponseHeader', args[0])\n\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info('headers not received yet, returning null')\n\n          // Headers not received yet, nothing to return.\n          return null\n        }\n\n        const headerValue = response.headers.get(args[0])\n        this.logger.info(\n          'resolved response header \"%s\" to',\n          args[0],\n          headerValue\n        )\n\n        return headerValue\n      },\n    })\n\n    this.request.getAllResponseHeaders = new Proxy(\n      this.request.getAllResponseHeaders,\n      {\n        apply: () => {\n          this.logger.info('getAllResponseHeaders')\n\n          if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n            this.logger.info('headers not received yet, returning empty string')\n\n            // Headers not received yet, nothing to return.\n            return ''\n          }\n\n          const headersList = Array.from(response.headers.entries())\n          const allHeaders = headersList\n            .map(([headerName, headerValue]) => {\n              return `${headerName}: ${headerValue}`\n            })\n            .join('\\r\\n')\n\n          this.logger.info('resolved all response headers to', allHeaders)\n\n          return allHeaders\n        },\n      }\n    )\n\n    // Update the response getters to resolve against the mocked response.\n    Object.defineProperties(this.request, {\n      response: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.response,\n      },\n      responseText: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseText,\n      },\n      responseXML: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseXML,\n      },\n    })\n\n    const totalResponseBodyLength = await getBodyByteLength(response.clone())\n\n    this.logger.info('calculated response body length', totalResponseBodyLength)\n\n    this.trigger('loadstart', this.request, {\n      loaded: 0,\n      total: totalResponseBodyLength,\n    })\n\n    this.setReadyState(this.request.HEADERS_RECEIVED)\n    this.setReadyState(this.request.LOADING)\n\n    const finalizeResponse = () => {\n      this.logger.info('finalizing the mocked response...')\n\n      this.setReadyState(this.request.DONE)\n\n      this.trigger('load', this.request, {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength,\n      })\n\n      this.trigger('loadend', this.request, {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength,\n      })\n    }\n\n    if (response.body) {\n      this.logger.info('mocked response has body, streaming...')\n\n      const reader = response.body.getReader()\n\n      const readNextResponseBodyChunk = async () => {\n        const { value, done } = await reader.read()\n\n        if (done) {\n          this.logger.info('response body stream done!')\n          finalizeResponse()\n          return\n        }\n\n        if (value) {\n          this.logger.info('read response body chunk:', value)\n          this.responseBuffer = concatArrayBuffer(this.responseBuffer, value)\n\n          this.trigger('progress', this.request, {\n            loaded: this.responseBuffer.byteLength,\n            total: totalResponseBodyLength,\n          })\n        }\n\n        readNextResponseBodyChunk()\n      }\n\n      readNextResponseBodyChunk()\n    } else {\n      finalizeResponse()\n    }\n  }\n\n  private responseBufferToText(): string {\n    return decodeBuffer(this.responseBuffer)\n  }\n\n  get response(): unknown {\n    this.logger.info(\n      'getResponse (responseType: %s)',\n      this.request.responseType\n    )\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null\n    }\n\n    switch (this.request.responseType) {\n      case 'json': {\n        const responseJson = parseJson(this.responseBufferToText())\n        this.logger.info('resolved response JSON', responseJson)\n\n        return responseJson\n      }\n\n      case 'arraybuffer': {\n        const arrayBuffer = toArrayBuffer(this.responseBuffer)\n        this.logger.info('resolved response ArrayBuffer', arrayBuffer)\n\n        return arrayBuffer\n      }\n\n      case 'blob': {\n        const mimeType =\n          this.request.getResponseHeader('Content-Type') || 'text/plain'\n        const responseBlob = new Blob([this.responseBufferToText()], {\n          type: mimeType,\n        })\n\n        this.logger.info(\n          'resolved response Blob (mime type: %s)',\n          responseBlob,\n          mimeType\n        )\n\n        return responseBlob\n      }\n\n      default: {\n        const responseText = this.responseBufferToText()\n        this.logger.info(\n          'resolving \"%s\" response type as text',\n          this.request.responseType,\n          responseText\n        )\n\n        return responseText\n      }\n    }\n  }\n\n  get responseText(): string {\n    /**\n     * Throw when trying to read the response body as text when the\n     * \"responseType\" doesn't expect text. This just respects the spec better.\n     * @see https://xhr.spec.whatwg.org/#the-responsetext-attribute\n     */\n    invariant(\n      this.request.responseType === '' || this.request.responseType === 'text',\n      'InvalidStateError: The object is in invalid state.'\n    )\n\n    if (\n      this.request.readyState !== this.request.LOADING &&\n      this.request.readyState !== this.request.DONE\n    ) {\n      return ''\n    }\n\n    const responseText = this.responseBufferToText()\n    this.logger.info('getResponseText: \"%s\"', responseText)\n\n    return responseText\n  }\n\n  get responseXML(): Document | null {\n    invariant(\n      this.request.responseType === '' ||\n        this.request.responseType === 'document',\n      'InvalidStateError: The object is in invalid state.'\n    )\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null\n    }\n\n    const contentType = this.request.getResponseHeader('Content-Type') || ''\n\n    if (typeof DOMParser === 'undefined') {\n      console.warn(\n        'Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly.'\n      )\n      return null\n    }\n\n    if (isDomParserSupportedType(contentType)) {\n      return new DOMParser().parseFromString(\n        this.responseBufferToText(),\n        contentType\n      )\n    }\n\n    return null\n  }\n\n  public errorWith(error?: Error): void {\n    /**\n     * @note Mark this request as handled even if it received a mock error.\n     * This prevents the controller from trying to perform this request as-is.\n     */\n    this[kIsRequestHandled] = true\n    this.logger.info('responding with an error')\n\n    this.setReadyState(this.request.DONE)\n    this.trigger('error', this.request)\n    this.trigger('loadend', this.request)\n  }\n\n  /**\n   * Transitions this request's `readyState` to the given one.\n   */\n  private setReadyState(nextReadyState: number): void {\n    this.logger.info(\n      'setReadyState: %d -> %d',\n      this.request.readyState,\n      nextReadyState\n    )\n\n    if (this.request.readyState === nextReadyState) {\n      this.logger.info('ready state identical, skipping transition...')\n      return\n    }\n\n    define(this.request, 'readyState', nextReadyState)\n\n    this.logger.info('set readyState to: %d', nextReadyState)\n\n    if (nextReadyState !== this.request.UNSENT) {\n      this.logger.info('triggerring \"readystatechange\" event...')\n\n      this.trigger('readystatechange', this.request)\n    }\n  }\n\n  /**\n   * Triggers given event on the `XMLHttpRequest` instance.\n   */\n  private trigger<\n    EventName extends keyof (XMLHttpRequestEventTargetEventMap & {\n      readystatechange: ProgressEvent<XMLHttpRequestEventTarget>\n    })\n  >(\n    eventName: EventName,\n    target: XMLHttpRequest | XMLHttpRequestUpload,\n    options?: ProgressEventInit\n  ): void {\n    const callback = (target as XMLHttpRequest)[`on${eventName}`]\n    const event = createEvent(target, eventName, options)\n\n    this.logger.info('trigger \"%s\"', eventName, options || '')\n\n    // Invoke direct callbacks.\n    if (typeof callback === 'function') {\n      this.logger.info('found a direct \"%s\" callback, calling...', eventName)\n      callback.call(target as XMLHttpRequest, event)\n    }\n\n    // Invoke event listeners.\n    const events =\n      target instanceof XMLHttpRequestUpload ? this.uploadEvents : this.events\n\n    for (const [registeredEventName, listeners] of events) {\n      if (registeredEventName === eventName) {\n        this.logger.info(\n          'found %d listener(s) for \"%s\" event, calling...',\n          listeners.length,\n          eventName\n        )\n\n        listeners.forEach((listener) => listener.call(target, event))\n      }\n    }\n  }\n\n  /**\n   * Converts this `XMLHttpRequest` instance into a Fetch API `Request` instance.\n   */\n  private toFetchApiRequest(\n    body: XMLHttpRequestBodyInit | Document | null | undefined\n  ): Request {\n    this.logger.info('converting request to a Fetch API Request...')\n\n    // If the `Document` is used as the body of this XMLHttpRequest,\n    // set its inner text as the Fetch API Request body.\n    const resolvedBody =\n      body instanceof Document ? body.documentElement.innerText : body\n\n    const fetchRequest = new Request(this.url.href, {\n      method: this.method,\n      headers: this.requestHeaders,\n      /**\n       * @see https://xhr.spec.whatwg.org/#cross-origin-credentials\n       */\n      credentials: this.request.withCredentials ? 'include' : 'same-origin',\n      body: ['GET', 'HEAD'].includes(this.method.toUpperCase())\n        ? null\n        : resolvedBody,\n    })\n\n    const proxyHeaders = createProxy(fetchRequest.headers, {\n      methodCall: ([methodName, args], invoke) => {\n        // Forward the latest state of the internal request headers\n        // because the interceptor might have modified them\n        // without responding to the request.\n        switch (methodName) {\n          case 'append':\n          case 'set': {\n            const [headerName, headerValue] = args as [string, string]\n            this.request.setRequestHeader(headerName, headerValue)\n            break\n          }\n\n          case 'delete': {\n            const [headerName] = args as [string]\n            console.warn(\n              `XMLHttpRequest: Cannot remove a \"${headerName}\" header from the Fetch API representation of the \"${fetchRequest.method} ${fetchRequest.url}\" request. XMLHttpRequest headers cannot be removed.`\n            )\n            break\n          }\n        }\n\n        return invoke()\n      },\n    })\n    define(fetchRequest, 'headers', proxyHeaders)\n    setRawRequest(fetchRequest, this.request)\n\n    this.logger.info('converted request to a Fetch API Request!', fetchRequest)\n\n    return fetchRequest\n  }\n}\n\nfunction toAbsoluteUrl(url: string | URL): URL {\n  /**\n   * @note XMLHttpRequest interceptor may run in environments\n   * that implement XMLHttpRequest but don't implement \"location\"\n   * (for example, React Native). If that's the case, return the\n   * input URL as-is (nothing to be relative to).\n   * @see https://github.com/mswjs/msw/issues/1777\n   */\n  if (typeof location === 'undefined') {\n    return new URL(url)\n  }\n\n  return new URL(url.toString(), location.href)\n}\n\nfunction define(\n  target: object,\n  property: string | symbol,\n  value: unknown\n): void {\n  Reflect.defineProperty(target, property, {\n    // Ensure writable properties to allow redefining readonly properties.\n    writable: true,\n    enumerable: true,\n    value,\n  })\n}\n","/**\n * Concatenate two `Uint8Array` buffers.\n */\nexport function concatArrayBuffer(\n  left: Uint8Array,\n  right: Uint8Array\n): Uint8Array {\n  const result = new Uint8Array(left.byteLength + right.byteLength)\n  result.set(left, 0)\n  result.set(right, left.byteLength)\n  return result\n}\n","export class EventPolyfill implements Event {\n  readonly NONE = 0\n  readonly CAPTURING_PHASE = 1\n  readonly AT_TARGET = 2\n  readonly BUBBLING_PHASE = 3\n\n  public type: string = ''\n  public srcElement: EventTarget | null = null\n  public target: EventTarget | null\n  public currentTarget: EventTarget | null = null\n  public eventPhase: number = 0\n  public timeStamp: number\n  public isTrusted: boolean = true\n  public composed: boolean = false\n  public cancelable: boolean = true\n  public defaultPrevented: boolean = false\n  public bubbles: boolean = true\n  public lengthComputable: boolean = true\n  public loaded: number = 0\n  public total: number = 0\n\n  cancelBubble: boolean = false\n  returnValue: boolean = true\n\n  constructor(\n    type: string,\n    options?: { target: EventTarget; currentTarget: EventTarget }\n  ) {\n    this.type = type\n    this.target = options?.target || null\n    this.currentTarget = options?.currentTarget || null\n    this.timeStamp = Date.now()\n  }\n\n  public composedPath(): EventTarget[] {\n    return []\n  }\n\n  public initEvent(type: string, bubbles?: boolean, cancelable?: boolean) {\n    this.type = type\n    this.bubbles = !!bubbles\n    this.cancelable = !!cancelable\n  }\n\n  public preventDefault() {\n    this.defaultPrevented = true\n  }\n\n  public stopPropagation() {}\n  public stopImmediatePropagation() {}\n}\n","import { EventPolyfill } from './EventPolyfill'\n\nexport class ProgressEventPolyfill extends EventPolyfill {\n  readonly lengthComputable: boolean\n  readonly composed: boolean\n  readonly loaded: number\n  readonly total: number\n\n  constructor(type: string, init?: ProgressEventInit) {\n    super(type)\n\n    this.lengthComputable = init?.lengthComputable || false\n    this.composed = init?.composed || false\n    this.loaded = init?.loaded || 0\n    this.total = init?.total || 0\n  }\n}\n","import { EventPolyfill } from '../polyfills/EventPolyfill'\nimport { ProgressEventPolyfill } from '../polyfills/ProgressEventPolyfill'\n\nconst SUPPORTS_PROGRESS_EVENT = typeof ProgressEvent !== 'undefined'\n\nexport function createEvent(\n  target: XMLHttpRequest | XMLHttpRequestUpload,\n  type: string,\n  init?: ProgressEventInit\n): EventPolyfill | ProgressEvent {\n  const progressEvents = [\n    'error',\n    'progress',\n    'loadstart',\n    'loadend',\n    'load',\n    'timeout',\n    'abort',\n  ]\n\n  /**\n   * `ProgressEvent` is not supported in React Native.\n   * @see https://github.com/mswjs/interceptors/issues/40\n   */\n  const ProgressEventClass = SUPPORTS_PROGRESS_EVENT\n    ? ProgressEvent\n    : ProgressEventPolyfill\n\n  const event = progressEvents.includes(type)\n    ? new ProgressEventClass(type, {\n        lengthComputable: true,\n        loaded: init?.loaded || 0,\n        total: init?.total || 0,\n      })\n    : new EventPolyfill(type, {\n        target,\n        currentTarget: target,\n      })\n\n  return event\n}\n","/**\n * Returns the source object of the given property on the target object\n * (the target itself, any parent in its prototype, or null).\n */\nexport function findPropertySource(\n  target: object,\n  propertyName: string | symbol\n): object | null {\n  if (!(propertyName in target)) {\n    return null\n  }\n\n  const hasProperty = Object.prototype.hasOwnProperty.call(target, propertyName)\n  if (hasProperty) {\n    return target\n  }\n\n  const prototype = Reflect.getPrototypeOf(target)\n  return prototype ? findPropertySource(prototype, propertyName) : null\n}\n","import { findPropertySource } from './findPropertySource'\n\nexport interface ProxyOptions<Target extends Record<string, any>> {\n  constructorCall?(args: Array<unknown>, next: NextFunction<Target>): Target\n\n  methodCall?<F extends keyof Target>(\n    this: Target,\n    data: [methodName: F, args: Array<unknown>],\n    next: NextFunction<void>\n  ): void\n\n  setProperty?(\n    data: [propertyName: string | symbol, nextValue: unknown],\n    next: NextFunction<boolean>\n  ): boolean\n\n  getProperty?(\n    data: [propertyName: string | symbol, receiver: Target],\n    next: NextFunction<void>\n  ): void\n}\n\nexport type NextFunction<ReturnType> = () => ReturnType\n\nexport function createProxy<Target extends object>(\n  target: Target,\n  options: ProxyOptions<Target>\n): Target {\n  const proxy = new Proxy(target, optionsToProxyHandler(options))\n\n  return proxy\n}\n\nfunction optionsToProxyHandler<T extends Record<string, any>>(\n  options: ProxyOptions<T>\n): ProxyHandler<T> {\n  const { constructorCall, methodCall, getProperty, setProperty } = options\n  const handler: ProxyHandler<T> = {}\n\n  if (typeof constructorCall !== 'undefined') {\n    handler.construct = function (target, args, newTarget) {\n      const next = Reflect.construct.bind(null, target as any, args, newTarget)\n      return constructorCall.call(newTarget, args, next)\n    }\n  }\n\n  handler.set = function (target, propertyName, nextValue) {\n    const next = () => {\n      const propertySource = findPropertySource(target, propertyName) || target\n      const ownDescriptors = Reflect.getOwnPropertyDescriptor(\n        propertySource,\n        propertyName\n      )\n\n      // Respect any custom setters present for this property.\n      if (typeof ownDescriptors?.set !== 'undefined') {\n        ownDescriptors.set.apply(target, [nextValue])\n        return true\n      }\n\n      // Otherwise, set the property on the source.\n      return Reflect.defineProperty(propertySource, propertyName, {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: nextValue,\n      })\n    }\n\n    if (typeof setProperty !== 'undefined') {\n      return setProperty.call(target, [propertyName, nextValue], next)\n    }\n\n    return next()\n  }\n\n  handler.get = function (target, propertyName, receiver) {\n    /**\n     * @note Using `Reflect.get()` here causes \"TypeError: Illegal invocation\".\n     */\n    const next = () => target[propertyName as any]\n\n    const value =\n      typeof getProperty !== 'undefined'\n        ? getProperty.call(target, [propertyName, receiver], next)\n        : next()\n\n    if (typeof value === 'function') {\n      return (...args: Array<any>) => {\n        const next = value.bind(target, ...args)\n\n        if (typeof methodCall !== 'undefined') {\n          return methodCall.call(target, [propertyName as any, args], next)\n        }\n\n        return next()\n      }\n    }\n\n    return value\n  }\n\n  return handler\n}\n","export function isDomParserSupportedType(\n  type: string\n): type is DOMParserSupportedType {\n  const supportedTypes: Array<DOMParserSupportedType> = [\n    'application/xhtml+xml',\n    'application/xml',\n    'image/svg+xml',\n    'text/html',\n    'text/xml',\n  ]\n  return supportedTypes.some((supportedType) => {\n    return type.startsWith(supportedType)\n  })\n}\n","/**\n * Parses a given string into JSON.\n * Gracefully handles invalid JSON by returning `null`.\n */\nexport function parseJson(data: string): Record<string, unknown> | null {\n  try {\n    const json = JSON.parse(data)\n    return json\n  } catch (_) {\n    return null\n  }\n}\n","import { FetchResponse } from '../../../utils/fetchUtils'\n\n/**\n * Creates a Fetch API `Response` instance from the given\n * `XMLHttpRequest` instance and a response body.\n */\nexport function createResponse(\n  request: XMLHttpRequest,\n  body: BodyInit | null\n): Response {\n  /**\n   * Handle XMLHttpRequest responses that must have null as the\n   * response body when represented using Fetch API Response.\n   * XMLHttpRequest response will always have an empty string\n   * as the \"request.response\" in those cases, resulting in an error\n   * when constructing a Response instance.\n   * @see https://github.com/mswjs/interceptors/issues/379\n   */\n  const responseBodyOrNull = FetchResponse.isResponseWithBody(request.status)\n    ? body\n    : null\n\n  return new FetchResponse(responseBodyOrNull, {\n    url: request.responseURL,\n    status: request.status,\n    statusText: request.statusText,\n    headers: createHeadersFromXMLHttpReqestHeaders(\n      request.getAllResponseHeaders()\n    ),\n  })\n}\n\nfunction createHeadersFromXMLHttpReqestHeaders(headersString: string): Headers {\n  const headers = new Headers()\n\n  const lines = headersString.split(/[\\r\\n]+/)\n  for (const line of lines) {\n    if (line.trim() === '') {\n      continue\n    }\n\n    const [name, ...parts] = line.split(': ')\n    const value = parts.join(': ')\n\n    headers.append(name, value)\n  }\n\n  return headers\n}\n","/**\n * Return a total byte length of the given request/response body.\n * If the `Content-Length` header is present, it will be used as the byte length.\n */\nexport async function getBodyByteLength(\n  input: Request | Response\n): Promise<number> {\n  const explicitContentLength = input.headers.get('content-length')\n\n  if (explicitContentLength != null && explicitContentLength !== '') {\n    return Number(explicitContentLength)\n  }\n\n  const buffer = await input.arrayBuffer()\n  return buffer.byteLength\n}\n","import type { Logger } from '@open-draft/logger'\nimport { XMLHttpRequestEmitter } from '.'\nimport { RequestController } from '../../RequestController'\nimport { XMLHttpRequestController } from './XMLHttpRequestController'\nimport { handleRequest } from '../../utils/handleRequest'\n\nexport interface XMLHttpRequestProxyOptions {\n  emitter: XMLHttpRequestEmitter\n  logger: Logger\n}\n\n/**\n * Create a proxied `XMLHttpRequest` class.\n * The proxied class establishes spies on certain methods,\n * allowing us to intercept requests and respond to them.\n */\nexport function createXMLHttpRequestProxy({\n  emitter,\n  logger,\n}: XMLHttpRequestProxyOptions) {\n  const XMLHttpRequestProxy = new Proxy(globalThis.XMLHttpRequest, {\n    construct(target, args, newTarget) {\n      logger.info('constructed new XMLHttpRequest')\n\n      const originalRequest = Reflect.construct(\n        target,\n        args,\n        newTarget\n      ) as XMLHttpRequest\n\n      /**\n       * @note Forward prototype descriptors onto the proxied object.\n       * XMLHttpRequest is implemented in JSDOM in a way that assigns\n       * a bunch of descriptors, like \"set responseType()\" on the prototype.\n       * With this propagation, we make sure that those descriptors trigger\n       * when the user operates with the proxied request instance.\n       */\n      const prototypeDescriptors = Object.getOwnPropertyDescriptors(\n        target.prototype\n      )\n      for (const propertyName in prototypeDescriptors) {\n        Reflect.defineProperty(\n          originalRequest,\n          propertyName,\n          prototypeDescriptors[propertyName]\n        )\n      }\n\n      const xhrRequestController = new XMLHttpRequestController(\n        originalRequest,\n        logger\n      )\n\n      xhrRequestController.onRequest = async function ({ request, requestId }) {\n        const controller = new RequestController(request)\n\n        this.logger.info('awaiting mocked response...')\n\n        this.logger.info(\n          'emitting the \"request\" event for %s listener(s)...',\n          emitter.listenerCount('request')\n        )\n\n        const isRequestHandled = await handleRequest({\n          request,\n          requestId,\n          controller,\n          emitter,\n          onResponse: async (response) => {\n            await this.respondWith(response)\n          },\n          onRequestError: () => {\n            this.errorWith(new TypeError('Network error'))\n          },\n          onError: (error) => {\n            this.logger.info('request errored!', { error })\n\n            if (error instanceof Error) {\n              this.errorWith(error)\n            }\n          },\n        })\n\n        if (!isRequestHandled) {\n          this.logger.info(\n            'no mocked response received, performing request as-is...'\n          )\n        }\n      }\n\n      xhrRequestController.onResponse = async function ({\n        response,\n        isMockedResponse,\n        request,\n        requestId,\n      }) {\n        this.logger.info(\n          'emitting the \"response\" event for %s listener(s)...',\n          emitter.listenerCount('response')\n        )\n\n        emitter.emit('response', {\n          response,\n          isMockedResponse,\n          request,\n          requestId,\n        })\n      }\n\n      // Return the proxied request from the controller\n      // so that the controller can react to the consumer's interactions\n      // with this request (opening/sending/etc).\n      return xhrRequestController.request\n    },\n  })\n\n  return XMLHttpRequestProxy\n}\n","import {\n  Interceptor,\n  BatchInterceptor,\n  HttpRequestEventMap,\n} from '@mswjs/interceptors'\nimport { FetchInterceptor } from '@mswjs/interceptors/fetch'\nimport { XMLHttpRequestInterceptor } from '@mswjs/interceptors/XMLHttpRequest'\nimport { SetupWorkerInternalContext, StartOptions } from '../glossary'\nimport type { RequiredDeep } from '~/core/typeUtils'\nimport { handleRequest } from '~/core/utils/handleRequest'\nimport { isHandlerKind } from '~/core/utils/internal/isHandlerKind'\n\nexport function createFallbackRequestListener(\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n): Interceptor<HttpRequestEventMap> {\n  const interceptor = new BatchInterceptor({\n    name: 'fallback',\n    interceptors: [new FetchInterceptor(), new XMLHttpRequestInterceptor()],\n  })\n\n  interceptor.on('request', async ({ request, requestId, controller }) => {\n    const requestCloneForLogs = request.clone()\n\n    const response = await handleRequest(\n      request,\n      requestId,\n      context.getRequestHandlers().filter(isHandlerKind('RequestHandler')),\n      options,\n      context.emitter,\n      {\n        onMockedResponse(_, { handler, parsedResult }) {\n          if (!options.quiet) {\n            context.emitter.once('response:mocked', ({ response }) => {\n              handler.log({\n                request: requestCloneForLogs,\n                response,\n                parsedResult,\n              })\n            })\n          }\n        },\n      },\n    )\n\n    if (response) {\n      controller.respondWith(response)\n    }\n  })\n\n  interceptor.on(\n    'response',\n    ({ response, isMockedResponse, request, requestId }) => {\n      context.emitter.emit(\n        isMockedResponse ? 'response:mocked' : 'response:bypass',\n        {\n          response,\n          request,\n          requestId,\n        },\n      )\n    },\n  )\n\n  interceptor.apply()\n\n  return interceptor\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\n\nexport function printStopMessage(args: { quiet?: boolean } = {}): void {\n  if (args.quiet) {\n    return\n  }\n\n  // eslint-disable-next-line no-console\n  console.log(\n    `%c${devUtils.formatMessage('Mocking disabled.')}`,\n    'color:orangered;font-weight:bold;',\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}