{"ast":null,"code":"import { RequestHandler } from './RequestHandler.mjs';\nimport { getTimestamp } from '../utils/logging/getTimestamp.mjs';\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor.mjs';\nimport { serializeRequest } from '../utils/logging/serializeRequest.mjs';\nimport { serializeResponse } from '../utils/logging/serializeResponse.mjs';\nimport { matchRequestUrl } from '../utils/matching/matchRequestUrl.mjs';\nimport { parseGraphQLRequest, parseDocumentNode } from '../utils/internal/parseGraphQLRequest.mjs';\nimport { toPublicUrl } from '../utils/request/toPublicUrl.mjs';\nimport { devUtils } from '../utils/internal/devUtils.mjs';\nimport { getAllRequestCookies } from '../utils/request/getRequestCookies.mjs';\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n  return typeof value === \"object\" && \"kind\" in value && \"definitions\" in value;\n}\nclass GraphQLHandler extends RequestHandler {\n  endpoint;\n  static parsedRequestCache = /* @__PURE__ */new WeakMap();\n  constructor(operationType, predicate, endpoint, resolver, options) {\n    let resolvedOperationName = predicate;\n    if (isDocumentNode(resolvedOperationName)) {\n      const parsedNode = parseDocumentNode(resolvedOperationName);\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`);\n      }\n      if (!parsedNode.operationName) {\n        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`);\n      }\n      resolvedOperationName = parsedNode.operationName;\n    }\n    const displayOperationName = typeof resolvedOperationName === \"function\" ? \"[custom predicate]\" : resolvedOperationName;\n    const header = operationType === \"all\" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType}${displayOperationName ? ` ${displayOperationName}` : \"\"} (origin: ${endpoint.toString()})`;\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName\n      },\n      resolver,\n      options\n    });\n    this.endpoint = endpoint;\n  }\n  /**\n   * Parses the request body, once per request, cached across all\n   * GraphQL handlers. This is done to avoid multiple parsing of the\n   * request body, which each requires a clone of the request.\n   */\n  async parseGraphQLRequestOrGetFromCache(request) {\n    if (!GraphQLHandler.parsedRequestCache.has(request)) {\n      GraphQLHandler.parsedRequestCache.set(request, await parseGraphQLRequest(request).catch(error => {\n        console.error(error);\n        return void 0;\n      }));\n    }\n    return GraphQLHandler.parsedRequestCache.get(request);\n  }\n  async parse(args) {\n    const match = matchRequestUrl(new URL(args.request.url), this.endpoint);\n    const cookies = getAllRequestCookies(args.request);\n    if (!match.matches) {\n      return {\n        match,\n        cookies\n      };\n    }\n    const parsedResult = await this.parseGraphQLRequestOrGetFromCache(args.request);\n    if (typeof parsedResult === \"undefined\") {\n      return {\n        match,\n        cookies\n      };\n    }\n    return {\n      match,\n      cookies,\n      query: parsedResult.query,\n      operationType: parsedResult.operationType,\n      operationName: parsedResult.operationName,\n      variables: parsedResult.variables\n    };\n  }\n  async predicate(args) {\n    if (args.parsedResult.operationType === void 0) {\n      return false;\n    }\n    if (!args.parsedResult.operationName && this.info.operationType !== \"all\") {\n      const publicUrl = toPublicUrl(args.request.url);\n      devUtils.warn(`Failed to intercept a GraphQL request at \"${args.request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation()\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/#graphqloperationresolver`);\n      return false;\n    }\n    const hasMatchingOperationType = this.info.operationType === \"all\" || args.parsedResult.operationType === this.info.operationType;\n    const hasMatchingOperationName = await this.matchOperationName({\n      request: args.request,\n      parsedResult: args.parsedResult\n    });\n    return args.parsedResult.match.matches && hasMatchingOperationType && hasMatchingOperationName;\n  }\n  async matchOperationName(args) {\n    if (typeof this.info.operationName === \"function\") {\n      const customPredicateResult = await this.info.operationName({\n        request: args.request,\n        ...this.extendResolverArgs({\n          request: args.request,\n          parsedResult: args.parsedResult\n        })\n      });\n      return typeof customPredicateResult === \"boolean\" ? customPredicateResult : customPredicateResult.matches;\n    }\n    if (this.info.operationName instanceof RegExp) {\n      return this.info.operationName.test(args.parsedResult.operationName || \"\");\n    }\n    return args.parsedResult.operationName === this.info.operationName;\n  }\n  extendResolverArgs(args) {\n    return {\n      query: args.parsedResult.query || \"\",\n      operationType: args.parsedResult.operationType,\n      operationName: args.parsedResult.operationName || \"\",\n      variables: args.parsedResult.variables || {},\n      cookies: args.parsedResult.cookies\n    };\n  }\n  async log(args) {\n    const loggedRequest = await serializeRequest(args.request);\n    const loggedResponse = await serializeResponse(args.response);\n    const statusColor = getStatusCodeColor(loggedResponse.status);\n    const requestInfo = args.parsedResult.operationName ? `${args.parsedResult.operationType} ${args.parsedResult.operationName}` : `anonymous ${args.parsedResult.operationType}`;\n    console.groupCollapsed(devUtils.formatMessage(`${getTimestamp()} ${requestInfo} (%c${loggedResponse.status} ${loggedResponse.statusText}%c)`), `color:${statusColor}`, \"color:inherit\");\n    console.log(\"Request:\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response:\", loggedResponse);\n    console.groupEnd();\n  }\n}\nexport { GraphQLHandler, isDocumentNode };\n//# sourceMappingURL=GraphQLHandler.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}