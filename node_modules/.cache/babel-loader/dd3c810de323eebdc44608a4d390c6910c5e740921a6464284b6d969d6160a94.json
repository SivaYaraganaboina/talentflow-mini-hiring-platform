{"ast":null,"code":"/**\n * Implement a factory allowing to plug different implementations of suffix\n * lookup (e.g.: using a trie or the packed hashes datastructures). This is used\n * and exposed in `tldts.ts` and `tldts-experimental.ts` bundle entrypoints.\n */\nimport getDomain from './domain';\nimport getDomainWithoutSuffix from './domain-without-suffix';\nimport extractHostname from './extract-hostname';\nimport isIp from './is-ip';\nimport isValidHostname from './is-valid';\nimport { setDefaults } from './options';\nimport getSubdomain from './subdomain';\nexport function getEmptyResult() {\n  return {\n    domain: null,\n    domainWithoutSuffix: null,\n    hostname: null,\n    isIcann: null,\n    isIp: null,\n    isPrivate: null,\n    publicSuffix: null,\n    subdomain: null\n  };\n}\nexport function resetResult(result) {\n  result.domain = null;\n  result.domainWithoutSuffix = null;\n  result.hostname = null;\n  result.isIcann = null;\n  result.isIp = null;\n  result.isPrivate = null;\n  result.publicSuffix = null;\n  result.subdomain = null;\n}\nexport function parseImpl(url, step, suffixLookup, partialOptions, result) {\n  const options = /*@__INLINE__*/setDefaults(partialOptions);\n  // Very fast approximate check to make sure `url` is a string. This is needed\n  // because the library will not necessarily be used in a typed setup and\n  // values of arbitrary types might be given as argument.\n  if (typeof url !== 'string') {\n    return result;\n  }\n  // Extract hostname from `url` only if needed. This can be made optional\n  // using `options.extractHostname`. This option will typically be used\n  // whenever we are sure the inputs to `parse` are already hostnames and not\n  // arbitrary URLs.\n  //\n  // `mixedInput` allows to specify if we expect a mix of URLs and hostnames\n  // as input. If only hostnames are expected then `extractHostname` can be\n  // set to `false` to speed-up parsing. If only URLs are expected then\n  // `mixedInputs` can be set to `false`. The `mixedInputs` is only a hint\n  // and will not change the behavior of the library.\n  if (!options.extractHostname) {\n    result.hostname = url;\n  } else if (options.mixedInputs) {\n    result.hostname = extractHostname(url, isValidHostname(url));\n  } else {\n    result.hostname = extractHostname(url, false);\n  }\n  // Check if `hostname` is a valid ip address\n  if (options.detectIp && result.hostname !== null) {\n    result.isIp = isIp(result.hostname);\n    if (result.isIp) {\n      return result;\n    }\n  }\n  // Perform hostname validation if enabled. If hostname is not valid, no need to\n  // go further as there will be no valid domain or sub-domain. This validation\n  // is applied before any early returns to ensure consistent behavior across\n  // all API methods including getHostname().\n  if (options.validateHostname && options.extractHostname && result.hostname !== null && !isValidHostname(result.hostname)) {\n    result.hostname = null;\n    return result;\n  }\n  if (step === 0 /* FLAG.HOSTNAME */ || result.hostname === null) {\n    return result;\n  }\n  // Extract public suffix\n  suffixLookup(result.hostname, options, result);\n  if (step === 2 /* FLAG.PUBLIC_SUFFIX */ || result.publicSuffix === null) {\n    return result;\n  }\n  // Extract domain\n  result.domain = getDomain(result.publicSuffix, result.hostname, options);\n  if (step === 3 /* FLAG.DOMAIN */ || result.domain === null) {\n    return result;\n  }\n  // Extract subdomain\n  result.subdomain = getSubdomain(result.hostname, result.domain);\n  if (step === 4 /* FLAG.SUB_DOMAIN */) {\n    return result;\n  }\n  // Extract domain without suffix\n  result.domainWithoutSuffix = getDomainWithoutSuffix(result.domain, result.publicSuffix);\n  return result;\n}\n//# sourceMappingURL=factory.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}