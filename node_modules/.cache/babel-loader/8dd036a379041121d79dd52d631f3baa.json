{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // src/Interceptor.ts\nvar _logger = require('@open-draft/logger');\nvar _stricteventemitter = require('strict-event-emitter');\nvar INTERNAL_REQUEST_ID_HEADER_NAME = \"x-interceptors-internal-request-id\";\nfunction getGlobalSymbol(symbol) {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || void 0\n  );\n}\nfunction setGlobalSymbol(symbol, value) {\n  globalThis[symbol] = value;\n}\nfunction deleteGlobalSymbol(symbol) {\n  delete globalThis[symbol];\n}\nvar InterceptorReadyState = /* @__PURE__ */(InterceptorReadyState2 => {\n  InterceptorReadyState2[\"INACTIVE\"] = \"INACTIVE\";\n  InterceptorReadyState2[\"APPLYING\"] = \"APPLYING\";\n  InterceptorReadyState2[\"APPLIED\"] = \"APPLIED\";\n  InterceptorReadyState2[\"DISPOSING\"] = \"DISPOSING\";\n  InterceptorReadyState2[\"DISPOSED\"] = \"DISPOSED\";\n  return InterceptorReadyState2;\n})(InterceptorReadyState || {});\nvar Interceptor = class {\n  constructor(symbol) {\n    this.symbol = symbol;\n    this.readyState = \"INACTIVE\" /* INACTIVE */;\n    this.emitter = new (0, _stricteventemitter.Emitter)();\n    this.subscriptions = [];\n    this.logger = new (0, _logger.Logger)(symbol.description);\n    this.emitter.setMaxListeners(0);\n    this.logger.info(\"constructing the interceptor...\");\n  }\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  checkEnvironment() {\n    return true;\n  }\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  apply() {\n    const logger = this.logger.extend(\"apply\");\n    logger.info(\"applying the interceptor...\");\n    if (this.readyState === \"APPLIED\" /* APPLIED */) {\n      logger.info(\"intercepted already applied!\");\n      return;\n    }\n    const shouldApply = this.checkEnvironment();\n    if (!shouldApply) {\n      logger.info(\"the interceptor cannot be applied in this environment!\");\n      return;\n    }\n    this.readyState = \"APPLYING\" /* APPLYING */;\n    const runningInstance = this.getInstance();\n    if (runningInstance) {\n      logger.info(\"found a running instance, reusing...\");\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event);\n        runningInstance.emitter.addListener(event, listener);\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener);\n          logger.info('removed proxied \"%s\" listener!', event);\n        });\n        return this;\n      };\n      this.readyState = \"APPLIED\" /* APPLIED */;\n      return;\n    }\n    logger.info(\"no running instance found, setting up a new instance...\");\n    this.setup();\n    this.setInstance();\n    this.readyState = \"APPLIED\" /* APPLIED */;\n  }\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  setup() {}\n  /**\n   * Listen to the interceptor's public events.\n   */\n  on(event, listener) {\n    const logger = this.logger.extend(\"on\");\n    if (this.readyState === \"DISPOSING\" /* DISPOSING */ || this.readyState === \"DISPOSED\" /* DISPOSED */) {\n      logger.info(\"cannot listen to events, already disposed!\");\n      return this;\n    }\n    logger.info('adding \"%s\" event listener:', event, listener);\n    this.emitter.on(event, listener);\n    return this;\n  }\n  once(event, listener) {\n    this.emitter.once(event, listener);\n    return this;\n  }\n  off(event, listener) {\n    this.emitter.off(event, listener);\n    return this;\n  }\n  removeAllListeners(event) {\n    this.emitter.removeAllListeners(event);\n    return this;\n  }\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  dispose() {\n    const logger = this.logger.extend(\"dispose\");\n    if (this.readyState === \"DISPOSED\" /* DISPOSED */) {\n      logger.info(\"cannot dispose, already disposed!\");\n      return;\n    }\n    logger.info(\"disposing the interceptor...\");\n    this.readyState = \"DISPOSING\" /* DISPOSING */;\n    if (!this.getInstance()) {\n      logger.info(\"no interceptors running, skipping dispose...\");\n      return;\n    }\n    this.clearInstance();\n    logger.info(\"global symbol deleted:\", getGlobalSymbol(this.symbol));\n    if (this.subscriptions.length > 0) {\n      logger.info(\"disposing of %d subscriptions...\", this.subscriptions.length);\n      for (const dispose of this.subscriptions) {\n        dispose();\n      }\n      this.subscriptions = [];\n      logger.info(\"disposed of all subscriptions!\", this.subscriptions.length);\n    }\n    this.emitter.removeAllListeners();\n    logger.info(\"destroyed the listener!\");\n    this.readyState = \"DISPOSED\" /* DISPOSED */;\n  }\n  getInstance() {\n    var _a;\n    const instance = getGlobalSymbol(this.symbol);\n    this.logger.info(\"retrieved global instance:\", (_a = instance == null ? void 0 : instance.constructor) == null ? void 0 : _a.name);\n    return instance;\n  }\n  setInstance() {\n    setGlobalSymbol(this.symbol, this);\n    this.logger.info(\"set global instance!\", this.symbol.description);\n  }\n  clearInstance() {\n    deleteGlobalSymbol(this.symbol);\n    this.logger.info(\"cleared global instance!\", this.symbol.description);\n  }\n};\n\n// src/createRequestId.ts\nfunction createRequestId() {\n  return Math.random().toString(16).slice(2);\n}\n\n// src/utils/canParseUrl.ts\nfunction canParseUrl(url) {\n  try {\n    new URL(url);\n    return true;\n  } catch (_error) {\n    return false;\n  }\n}\n\n// src/utils/getValueBySymbol.ts\nfunction getValueBySymbol(symbolName, source) {\n  const ownSymbols = Object.getOwnPropertySymbols(source);\n  const symbol = ownSymbols.find(symbol2 => {\n    return symbol2.description === symbolName;\n  });\n  if (symbol) {\n    return Reflect.get(source, symbol);\n  }\n  return;\n}\n\n// src/utils/fetchUtils.ts\nvar _FetchResponse = class extends Response {\n  static isConfigurableStatusCode(status) {\n    return status >= 200 && status <= 599;\n  }\n  static isRedirectResponse(status) {\n    return _FetchResponse.STATUS_CODES_WITH_REDIRECT.includes(status);\n  }\n  /**\n   * Returns a boolean indicating whether the given response status\n   * code represents a response that can have a body.\n   */\n  static isResponseWithBody(status) {\n    return !_FetchResponse.STATUS_CODES_WITHOUT_BODY.includes(status);\n  }\n  static setUrl(url, response) {\n    if (!url || url === \"about:\" || !canParseUrl(url)) {\n      return;\n    }\n    const state = getValueBySymbol(\"state\", response);\n    if (state) {\n      state.urlList.push(new URL(url));\n    } else {\n      Object.defineProperty(response, \"url\", {\n        value: url,\n        enumerable: true,\n        configurable: true,\n        writable: false\n      });\n    }\n  }\n  /**\n   * Parses the given raw HTTP headers into a Fetch API `Headers` instance.\n   */\n  static parseRawHeaders(rawHeaders) {\n    const headers = new Headers();\n    for (let line = 0; line < rawHeaders.length; line += 2) {\n      headers.append(rawHeaders[line], rawHeaders[line + 1]);\n    }\n    return headers;\n  }\n  constructor(body, init = {}) {\n    var _a;\n    const status = (_a = init.status) != null ? _a : 200;\n    const safeStatus = _FetchResponse.isConfigurableStatusCode(status) ? status : 200;\n    const finalBody = _FetchResponse.isResponseWithBody(status) ? body : null;\n    super(finalBody, {\n      status: safeStatus,\n      statusText: init.statusText,\n      headers: init.headers\n    });\n    if (status !== safeStatus) {\n      const state = getValueBySymbol(\"state\", this);\n      if (state) {\n        state.status = status;\n      } else {\n        Object.defineProperty(this, \"status\", {\n          value: status,\n          enumerable: true,\n          configurable: true,\n          writable: false\n        });\n      }\n    }\n    _FetchResponse.setUrl(init.url, this);\n  }\n};\nvar FetchResponse = _FetchResponse;\n/**\n * Response status codes for responses that cannot have body.\n * @see https://fetch.spec.whatwg.org/#statuses\n */\nFetchResponse.STATUS_CODES_WITHOUT_BODY = [101, 103, 204, 205, 304];\nFetchResponse.STATUS_CODES_WITH_REDIRECT = [301, 302, 303, 307, 308];\nexports.INTERNAL_REQUEST_ID_HEADER_NAME = INTERNAL_REQUEST_ID_HEADER_NAME;\nexports.getGlobalSymbol = getGlobalSymbol;\nexports.deleteGlobalSymbol = deleteGlobalSymbol;\nexports.InterceptorReadyState = InterceptorReadyState;\nexports.Interceptor = Interceptor;\nexports.createRequestId = createRequestId;\nexports.canParseUrl = canParseUrl;\nexports.FetchResponse = FetchResponse;","map":{"version":3,"names":["_logger","require","_stricteventemitter","INTERNAL_REQUEST_ID_HEADER_NAME","getGlobalSymbol","symbol","globalThis","setGlobalSymbol","value","deleteGlobalSymbol","InterceptorReadyState","InterceptorReadyState2","Interceptor","constructor","readyState","emitter","Emitter","subscriptions","logger","Logger","description","setMaxListeners","info","checkEnvironment","apply","extend","shouldApply","runningInstance","getInstance","on","event","listener","addListener","push","removeListener","setup","setInstance","once","off","removeAllListeners","dispose","clearInstance","length","_a","instance","name","createRequestId","Math","random","toString","slice","canParseUrl","url","URL","_error","getValueBySymbol","symbolName","source","ownSymbols","Object","getOwnPropertySymbols","find","symbol2","Reflect","get","_FetchResponse","Response","isConfigurableStatusCode","status","isRedirectResponse","STATUS_CODES_WITH_REDIRECT","includes","isResponseWithBody","STATUS_CODES_WITHOUT_BODY","setUrl","response","state","urlList","defineProperty","enumerable","configurable","writable","parseRawHeaders","rawHeaders","headers","Headers","line","append","body","init","safeStatus","finalBody","statusText","FetchResponse"],"sources":["../../src/Interceptor.ts","../../src/createRequestId.ts","../../src/utils/canParseUrl.ts","../../src/utils/getValueBySymbol.ts","../../src/utils/fetchUtils.ts"],"sourcesContent":["import { Logger } from '@open-draft/logger'\nimport { Emitter, Listener } from 'strict-event-emitter'\n\nexport type InterceptorEventMap = Record<string, any>\nexport type InterceptorSubscription = () => void\n\n/**\n * Request header name to detect when a single request\n * is being handled by nested interceptors (XHR -> ClientRequest).\n * Obscure by design to prevent collisions with user-defined headers.\n * Ideally, come up with the Interceptor-level mechanism for this.\n * @see https://github.com/mswjs/interceptors/issues/378\n */\nexport const INTERNAL_REQUEST_ID_HEADER_NAME =\n  'x-interceptors-internal-request-id'\n\nexport function getGlobalSymbol<V>(symbol: Symbol): V | undefined {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || undefined\n  )\n}\n\nfunction setGlobalSymbol(symbol: Symbol, value: any): void {\n  // @ts-ignore\n  globalThis[symbol] = value\n}\n\nexport function deleteGlobalSymbol(symbol: Symbol): void {\n  // @ts-ignore\n  delete globalThis[symbol]\n}\n\nexport enum InterceptorReadyState {\n  INACTIVE = 'INACTIVE',\n  APPLYING = 'APPLYING',\n  APPLIED = 'APPLIED',\n  DISPOSING = 'DISPOSING',\n  DISPOSED = 'DISPOSED',\n}\n\nexport type ExtractEventNames<Events extends Record<string, any>> =\n  Events extends Record<infer EventName, any> ? EventName : never\n\nexport class Interceptor<Events extends InterceptorEventMap> {\n  protected emitter: Emitter<Events>\n  protected subscriptions: Array<InterceptorSubscription>\n  protected logger: Logger\n\n  public readyState: InterceptorReadyState\n\n  constructor(private readonly symbol: symbol) {\n    this.readyState = InterceptorReadyState.INACTIVE\n\n    this.emitter = new Emitter()\n    this.subscriptions = []\n    this.logger = new Logger(symbol.description!)\n\n    // Do not limit the maximum number of listeners\n    // so not to limit the maximum amount of parallel events emitted.\n    this.emitter.setMaxListeners(0)\n\n    this.logger.info('constructing the interceptor...')\n  }\n\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  protected checkEnvironment(): boolean {\n    return true\n  }\n\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  public apply(): void {\n    const logger = this.logger.extend('apply')\n    logger.info('applying the interceptor...')\n\n    if (this.readyState === InterceptorReadyState.APPLIED) {\n      logger.info('intercepted already applied!')\n      return\n    }\n\n    const shouldApply = this.checkEnvironment()\n\n    if (!shouldApply) {\n      logger.info('the interceptor cannot be applied in this environment!')\n      return\n    }\n\n    this.readyState = InterceptorReadyState.APPLYING\n\n    // Whenever applying a new interceptor, check if it hasn't been applied already.\n    // This enables to apply the same interceptor multiple times, for example from a different\n    // interceptor, only proxying events but keeping the stubs in a single place.\n    const runningInstance = this.getInstance()\n\n    if (runningInstance) {\n      logger.info('found a running instance, reusing...')\n\n      // Proxy any listeners you set on this instance to the running instance.\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event)\n\n        // Add listeners to the running instance so they appear\n        // at the top of the event listeners list and are executed first.\n        runningInstance.emitter.addListener(event, listener)\n\n        // Ensure that once this interceptor instance is disposed,\n        // it removes all listeners it has appended to the running interceptor instance.\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener)\n          logger.info('removed proxied \"%s\" listener!', event)\n        })\n\n        return this\n      }\n\n      this.readyState = InterceptorReadyState.APPLIED\n\n      return\n    }\n\n    logger.info('no running instance found, setting up a new instance...')\n\n    // Setup the interceptor.\n    this.setup()\n\n    // Store the newly applied interceptor instance globally.\n    this.setInstance()\n\n    this.readyState = InterceptorReadyState.APPLIED\n  }\n\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  protected setup(): void {}\n\n  /**\n   * Listen to the interceptor's public events.\n   */\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    const logger = this.logger.extend('on')\n\n    if (\n      this.readyState === InterceptorReadyState.DISPOSING ||\n      this.readyState === InterceptorReadyState.DISPOSED\n    ) {\n      logger.info('cannot listen to events, already disposed!')\n      return this\n    }\n\n    logger.info('adding \"%s\" event listener:', event, listener)\n\n    this.emitter.on(event, listener)\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.once(event, listener)\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.off(event, listener)\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName\n  ): this {\n    this.emitter.removeAllListeners(event)\n    return this\n  }\n\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  public dispose(): void {\n    const logger = this.logger.extend('dispose')\n\n    if (this.readyState === InterceptorReadyState.DISPOSED) {\n      logger.info('cannot dispose, already disposed!')\n      return\n    }\n\n    logger.info('disposing the interceptor...')\n    this.readyState = InterceptorReadyState.DISPOSING\n\n    if (!this.getInstance()) {\n      logger.info('no interceptors running, skipping dispose...')\n      return\n    }\n\n    // Delete the global symbol as soon as possible,\n    // indicating that the interceptor is no longer running.\n    this.clearInstance()\n\n    logger.info('global symbol deleted:', getGlobalSymbol(this.symbol))\n\n    if (this.subscriptions.length > 0) {\n      logger.info('disposing of %d subscriptions...', this.subscriptions.length)\n\n      for (const dispose of this.subscriptions) {\n        dispose()\n      }\n\n      this.subscriptions = []\n\n      logger.info('disposed of all subscriptions!', this.subscriptions.length)\n    }\n\n    this.emitter.removeAllListeners()\n    logger.info('destroyed the listener!')\n\n    this.readyState = InterceptorReadyState.DISPOSED\n  }\n\n  private getInstance(): this | undefined {\n    const instance = getGlobalSymbol<this>(this.symbol)\n    this.logger.info('retrieved global instance:', instance?.constructor?.name)\n    return instance\n  }\n\n  private setInstance(): void {\n    setGlobalSymbol(this.symbol, this)\n    this.logger.info('set global instance!', this.symbol.description)\n  }\n\n  private clearInstance(): void {\n    deleteGlobalSymbol(this.symbol)\n    this.logger.info('cleared global instance!', this.symbol.description)\n  }\n}\n","/**\n * Generate a random ID string to represent a request.\n * @example\n * createRequestId()\n * // \"f774b6c9c600f\"\n */\nexport function createRequestId(): string {\n  return Math.random().toString(16).slice(2)\n}\n","/**\n * Returns a boolean indicating whether the given URL string\n * can be parsed into a `URL` instance.\n * A substitute for `URL.canParse()` for Node.js 18.\n */\nexport function canParseUrl(url: string): boolean {\n  try {\n    new URL(url)\n    return true\n  } catch (_error) {\n    return false\n  }\n}\n","/**\n * Returns the value behind the symbol with the given name.\n */\nexport function getValueBySymbol<T>(\n  symbolName: string,\n  source: object\n): T | undefined {\n  const ownSymbols = Object.getOwnPropertySymbols(source)\n\n  const symbol = ownSymbols.find((symbol) => {\n    return symbol.description === symbolName\n  })\n\n  if (symbol) {\n    return Reflect.get(source, symbol)\n  }\n\n  return\n}\n","import { canParseUrl } from './canParseUrl'\nimport { getValueBySymbol } from './getValueBySymbol'\n\nexport interface FetchResponseInit extends ResponseInit {\n  url?: string\n}\n\ninterface UndiciFetchInternalState {\n  aborted: boolean\n  rangeRequested: boolean\n  timingAllowPassed: boolean\n  requestIncludesCredentials: boolean\n  type: ResponseType\n  status: number\n  statusText: string\n  timingInfo: unknown\n  cacheState: unknown\n  headersList: Record<symbol, Map<string, unknown>>\n  urlList: Array<URL>\n  body?: {\n    stream: ReadableStream\n    source: unknown\n    length: number\n  }\n}\n\nexport class FetchResponse extends Response {\n  /**\n   * Response status codes for responses that cannot have body.\n   * @see https://fetch.spec.whatwg.org/#statuses\n   */\n  static readonly STATUS_CODES_WITHOUT_BODY = [101, 103, 204, 205, 304]\n\n  static readonly STATUS_CODES_WITH_REDIRECT = [301, 302, 303, 307, 308]\n\n  static isConfigurableStatusCode(status: number): boolean {\n    return status >= 200 && status <= 599\n  }\n\n  static isRedirectResponse(status: number): boolean {\n    return FetchResponse.STATUS_CODES_WITH_REDIRECT.includes(status)\n  }\n\n  /**\n   * Returns a boolean indicating whether the given response status\n   * code represents a response that can have a body.\n   */\n  static isResponseWithBody(status: number): boolean {\n    return !FetchResponse.STATUS_CODES_WITHOUT_BODY.includes(status)\n  }\n\n  static setUrl(url: string | undefined, response: Response): void {\n    if (!url || url === 'about:' || !canParseUrl(url)) {\n      return\n    }\n\n    const state = getValueBySymbol<UndiciFetchInternalState>('state', response)\n\n    if (state) {\n      // In Undici, push the URL to the internal list of URLs.\n      // This will respect the `response.url` getter logic correctly.\n      state.urlList.push(new URL(url))\n    } else {\n      // In other libraries, redefine the `url` property directly.\n      Object.defineProperty(response, 'url', {\n        value: url,\n        enumerable: true,\n        configurable: true,\n        writable: false,\n      })\n    }\n  }\n\n  /**\n   * Parses the given raw HTTP headers into a Fetch API `Headers` instance.\n   */\n  static parseRawHeaders(rawHeaders: Array<string>): Headers {\n    const headers = new Headers()\n    for (let line = 0; line < rawHeaders.length; line += 2) {\n      headers.append(rawHeaders[line], rawHeaders[line + 1])\n    }\n    return headers\n  }\n\n  constructor(body?: BodyInit | null, init: FetchResponseInit = {}) {\n    const status = init.status ?? 200\n    const safeStatus = FetchResponse.isConfigurableStatusCode(status)\n      ? status\n      : 200\n    const finalBody = FetchResponse.isResponseWithBody(status) ? body : null\n\n    super(finalBody, {\n      status: safeStatus,\n      statusText: init.statusText,\n      headers: init.headers,\n    })\n\n    if (status !== safeStatus) {\n      /**\n       * @note Undici keeps an internal \"Symbol(state)\" that holds\n       * the actual value of response status. Update that in Node.js.\n       */\n      const state = getValueBySymbol<UndiciFetchInternalState>('state', this)\n\n      if (state) {\n        state.status = status\n      } else {\n        Object.defineProperty(this, 'status', {\n          value: status,\n          enumerable: true,\n          configurable: true,\n          writable: false,\n        })\n      }\n    }\n\n    FetchResponse.setUrl(init.url, this)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}