{"ast":null,"code":"import { WebSocketMemoryClientStore } from './WebSocketMemoryClientStore.mjs';\nimport { WebSocketIndexedDBClientStore } from './WebSocketIndexedDBClientStore.mjs';\nclass WebSocketClientManager {\n  constructor(channel) {\n    this.channel = channel;\n    this.store = typeof indexedDB !== \"undefined\" ? new WebSocketIndexedDBClientStore() : new WebSocketMemoryClientStore();\n    this.runtimeClients = /* @__PURE__ */new Map();\n    this.allClients = /* @__PURE__ */new Set();\n    this.channel.addEventListener(\"message\", message => {\n      if (message.data?.type === \"db:update\") {\n        this.flushDatabaseToMemory();\n      }\n    });\n    if (typeof window !== \"undefined\") {\n      window.addEventListener(\"message\", async message => {\n        if (message.data?.type === \"msw/worker:stop\") {\n          await this.removeRuntimeClients();\n        }\n      });\n    }\n  }\n  store;\n  runtimeClients;\n  allClients;\n  async flushDatabaseToMemory() {\n    const storedClients = await this.store.getAll();\n    this.allClients = new Set(storedClients.map(client => {\n      const runtimeClient = this.runtimeClients.get(client.id);\n      if (runtimeClient) {\n        return runtimeClient;\n      }\n      return new WebSocketRemoteClientConnection(client.id, new URL(client.url), this.channel);\n    }));\n  }\n  async removeRuntimeClients() {\n    await this.store.deleteMany(Array.from(this.runtimeClients.keys()));\n    this.runtimeClients.clear();\n    await this.flushDatabaseToMemory();\n    this.notifyOthersAboutDatabaseUpdate();\n  }\n  /**\n   * All active WebSocket client connections.\n   */\n  get clients() {\n    return this.allClients;\n  }\n  /**\n   * Notify other runtimes about the database update\n   * using the shared `BroadcastChannel` instance.\n   */\n  notifyOthersAboutDatabaseUpdate() {\n    this.channel.postMessage({\n      type: \"db:update\"\n    });\n  }\n  async addClient(client) {\n    await this.store.add(client);\n    await this.flushDatabaseToMemory();\n    this.notifyOthersAboutDatabaseUpdate();\n  }\n  /**\n   * Adds the given `WebSocket` client connection to the set\n   * of all connections. The given connection is always the complete\n   * connection object because `addConnection()` is called only\n   * for the opened connections in the same runtime.\n   */\n  async addConnection(client) {\n    this.runtimeClients.set(client.id, client);\n    await this.addClient(client);\n    const handleExtraneousMessage = message => {\n      const {\n        type,\n        payload\n      } = message.data;\n      if (typeof payload === \"object\" && \"clientId\" in payload && payload.clientId !== client.id) {\n        return;\n      }\n      switch (type) {\n        case \"extraneous:send\":\n          {\n            client.send(payload.data);\n            break;\n          }\n        case \"extraneous:close\":\n          {\n            client.close(payload.code, payload.reason);\n            break;\n          }\n      }\n    };\n    const abortController = new AbortController();\n    this.channel.addEventListener(\"message\", handleExtraneousMessage, {\n      signal: abortController.signal\n    });\n    client.addEventListener(\"close\", () => abortController.abort(), {\n      once: true\n    });\n  }\n}\nclass WebSocketRemoteClientConnection {\n  constructor(id, url, channel) {\n    this.id = id;\n    this.url = url;\n    this.channel = channel;\n  }\n  send(data) {\n    this.channel.postMessage({\n      type: \"extraneous:send\",\n      payload: {\n        clientId: this.id,\n        data\n      }\n    });\n  }\n  close(code, reason) {\n    this.channel.postMessage({\n      type: \"extraneous:close\",\n      payload: {\n        clientId: this.id,\n        code,\n        reason\n      }\n    });\n  }\n  addEventListener(_type, _listener, _options) {\n    throw new Error(\"WebSocketRemoteClientConnection.addEventListener is not supported\");\n  }\n  removeEventListener(_event, _listener, _options) {\n    throw new Error(\"WebSocketRemoteClientConnection.removeEventListener is not supported\");\n  }\n}\nexport { WebSocketClientManager, WebSocketRemoteClientConnection };\n//# sourceMappingURL=WebSocketClientManager.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}